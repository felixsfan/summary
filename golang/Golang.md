# 1. 编译型和解释性

我们编写的源代码是人类语言，我们自己能够轻松理解；但是对于计算机硬件（CPU），源代码就是天书，根本无法执行，计算机只能识别某些特定的二进制指令，在程序真正运行之前必须将源代码转换成二进制指令。

所谓的二进制指令，也就是机器码，是 CPU 能够识别的硬件层面的“代码”，简陋的硬件（比如古老的单片机）只能使用几十个指令，强大的硬件（PC 和智能手机）能使用成百上千个指令。

然而，究竟在什么时候将源代码转换成二进制指令呢？不同的编程语言有不同的规定：

- 有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（Windows 下的 .exe），比如C语言、[C++](http://m.biancheng.net/cplus/)、Golang、Pascal（Delphi）、汇编等，这种编程语言称为编译型语言，使用的转换工具称为编译器。
- 有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 [Python](http://m.biancheng.net/python/)、[JavaScript](http://m.biancheng.net/js/)、[PHP](http://m.biancheng.net/php/)、Shell、[MATLAB](http://m.biancheng.net/matlab/) 等，这种编程语言称为解释型语言，使用的转换工具称为解释器。

简单理解，编译器就是一个“翻译工具”，类似于将中文翻译成英文、将英文翻译成俄文。但是，翻译源代码是一个复杂的过程，大致包括词法分析、语法分析、语义分析、性能优化、生成可执行文件等五个步骤，期间涉及到复杂的算法和硬件架构。解释器与此类似，有兴趣的读者请参考《编译原理》一书，本文不再赘述。

<img src="/Users/fanqingwei/Desktop/学习/golang\images\编译型和解释型执行流程.png" style="zoom:50%;" />

## 1.1 编译型语言

对于编译型语言，开发完成以后需要将所有的源代码都转换成可执行程序，比如 Windows 下的`.exe`文件，可执行程序里面包含的就是机器码。只要我们拥有可执行程序，就可以随时运行，不用再重新编译了，也就是“一次编译，无限次运行”。

在运行的时候，我们只需要编译生成的可执行程序，不再需要源代码和编译器了，所以说编译型语言可以脱离开发环境运行。

编译型语言一般是不能跨平台的，也就是不能在不同的操作系统之间随意切换。

编译型语言不能跨平台表现在两个方面：

**1.可执行程序不能跨平台**

可执行程序不能跨平台很容易理解，因为不同操作系统对可执行文件的内部结构有着截然不同的要求，彼此之间也不能兼容。不能跨平台是天经地义，能跨平台反而才是奇葩。

比如，不能将 Windows 下的可执行程序拿到 Linux 下使用，也不能将 Linux 下的可执行程序拿到 Mac OS 下使用（虽然它们都是[类 Unix 系统](http://m.biancheng.net/view/vip_5038.html)）。

另外，相同操作系统的不同版本之间也不一定兼容，比如不能将 x64 程序（Windows 64 位程序）拿到 x86 平台（Windows 32 位平台）下运行。但是反之一般可行，因为 64 位 Windows 对 32 位程序作了很好的兼容性处理。

**2.源代码不能跨平台**

不同平台支持的函数、类型、变量等都可能不同，基于某个平台编写的源代码一般不能拿到另一个平台下编译。我们以C语言为例来说明。

【实例1】在C语言中要想让程序暂停可以使用“睡眠”函数，在 Windows 平台下该函数是 Sleep()，在 Linux 平台下该函数是 sleep()，首字母大小写不同。其次，Sleep() 的参数是毫秒，sleep() 的参数是秒，单位也不一样。

以上两个原因导致使用暂停功能的C语言程序不能跨平台，除非在代码层面做出兼容性处理，非常麻烦。

【实例2】虽然不同平台的C语言都支持 long 类型，但是不同平台的 long 的长度却不同，例如，Windows 64 位平台下的 long 占用 4 个字节，Linux 64 位平台下的 long 占用 8 个字节。

我们在 Linux 64 位平台下编写代码时，将 0x2f1e4ad23 赋值给 long 类型的变量是完全没有问题的，但是这样的赋值在 Windows 平台下就会导致数值溢出，让程序产生错误的运行结果。

让人苦恼的，这样的错误一般不容易察觉，因为编译器不会报错，我们也记不住不同类型的取值范围。

## 1.2 解释型语言

对于解释型语言，每次执行程序都需要一边转换一边执行，用到哪些源代码就将哪些源代码转换成机器码，用不到的不进行任何处理。每次执行程序时可能使用不同的功能，这个时候需要转换的源代码也不一样。

因为每次执行程序都需要重新转换源代码，所以解释型语言的执行效率天生就低于编译型语言，甚至存在数量级的差距。计算机的一些底层功能，或者关键算法，一般都使用 C/C++ 实现，只有在应用层面（比如网站开发、批处理、小工具等）才会使用解释型语言。

在运行解释型语言的时候，我们始终都需要源代码和解释器，所以说它无法脱离开发环境。

当我们说“下载一个程序（软件）”时，不同类型的语言有不同的含义：

- 对于编译型语言，我们下载到的是可执行文件，源代码被作者保留，所以编译型语言的程序一般是闭源的。
- 对于解释型语言，我们下载到的是所有的源代码，因为作者不给源代码就没法运行，所以解释型语言的程序一般是开源的。


相比于编译型语言，解释型语言几乎都能跨平台，“一次编写，到处运行”是真是存在的，而且比比皆是。那么，为什么解释型语言就能快平台呢？

这一切都要归功于解释器！

我们所说的跨平台，是指源代码跨平台，而不是解释器跨平台。解释器用来将源代码转换成机器码，它就是一个可执行程序，是绝对不能跨平台的。

官方需要针对不同的平台开发不同的解释器，这些解释器必须要能够遵守同样的语法，识别同样的函数，完成同样的功能，只有这样，同样的代码在不同平台的执行结果才是相同的。

你看，解释型语言之所以能够跨平台，是因为有了解释器这个中间层。在不同的平台下，解释器会将相同的源代码转换成不同的机器码，解释器帮助我们屏蔽了不同平台之间的差异。

## 1.3 总结

- golang是编译型语言

  ```c++
  $ go build hello.go #编译
  $ ls
  hello    hello.go
  $ ./hello  运行编译后的文件
  Hello, World!
  #=========================
  $ go run hello.go #快捷命令
  Hello, World!
  ```

- 还有一种混合型语言 为了兼顾效率和跨平台，比如Java

  ```java
  javac hello.java  #编译成hello.class字节码文件
  java hello  #运行编译好的字节码文件
  ```

- python是解释型语言，但是python为了效率：

  当python程序运行时，编译的结果则是保存在位于内存中的PyCodeObject中，当Python程序运行结束时，Python解释器则将PyCodeObject写回到pyc文件中。当python程序第二次运行时，首先程序会在硬盘中寻找pyc文件，如果找到，则直接载入，否则就重复上面的过程。所以我们应该这样来定位PyCodeObject和pyc文件，我们说pyc文件其实是PyCodeObject的一种持久化保存方式。\

- Python与Java编译的过程

![](/Users/fanqingwei/Desktop/学习/golang\images\Java和python区别.png)

# 2.C/C++程序编译过程详解

因为golang是编译型语言，类似于C/C++,所以这里复习一下C/C++程序编译过程。

C语言的编译链接过程要把我们编写的一个c程序（源代码）转换成可以在硬件上运行的程序（可执行代码），需要进行编译和链接。编译就是把文本形式源代码翻译为机器语言形式的目标文件的过程。链接是把目标文件、操作系统的启动代码和用到的库文件进行组织，形成最终生成可执行代码的过程。过程图解如下：

<img src="/Users/fanqingwei/Desktop/学习/golang\images\C编译过程.png" style="zoom:50%;" />

从图上可以看到，整个代码的编译过程分为编译和链接两个过程，编译对应图中的大括号括起的部分，其余则为链接过程。

## 2.1 编译过程

编译过程又可以分成两个阶段：编译和汇编。

### 2.1.1 编译

编译是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码，源文件的编译过程包含两个主要阶段：

#### 编译预处理

读取c源程序，对其中的伪指令（以# 开头的指令）和特殊符号进行处理。

伪指令主要包括以下四个方面：

**1) 宏定义指令**，如# define Name TokenString，# undef等。

对于前一个伪指令，预编译所要做的是将程序中的所有Name用TokenString替换，但作为字符串常量的 Name则不被替换。对于后者，则将取消对某个宏的定义，使以后该串的出现不再被替换。

**2) 条件编译指令**，如# ifdef，# ifndef，# else，# elif，# endif等。

这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。

**3) 头文件包含指令**，如# include "FileName" 或者# include < FileName> 等。

在头文件中一般用伪指令# define定义了大量的宏（最常见的是字符常量），同时包含有各种外部符号的声明。

采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用。因为在需要用到这些定义的C源程序中，只需加上一条# include语句即可，而不必再在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。

包含到c源程序中的头文件可以是系统提供的，这些头文件一般被放在/ usr/ include目录下。在程序中# include它们要使用尖括号（< >）。另外开发人员也可以定义自己的头文件，这些文件一般与c源程序放在同一目录下，此时在# include中要用双引号（""）。

**4) 特殊符号**，预编译程序可以识别一些特殊的符号。

例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。

预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。这个文件的含义同没有经过预处理的源文件是相同的，但内容有所不同。下一步，此输出文件将作为编译程序的输入而被翻译成为机器指令。

#### 编译、优化阶段

经过预编译得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及C语言的关键字，如main, if , else , for , while , { , } , + , - , * , \ 等等。

编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

优化处理是编译系统中一项比较艰深的技术。它涉及到的问题不仅同编译技术本身有关，而且同机器的硬件环境也有很大的关系。优化一部分是对中间代码的优化。这种优化不依赖于具体的计算机。另一种优化则主要针对目标代码的生成而进行的。

对于前一种优化，主要的工作是删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除，等等。

后一种类型的优化同机器的硬件结构密切相关，最主要的是考虑是如何充分利用机器的各个硬件寄存器存放有关变量的值，以减少对于内存的访问次数。另外，如何根据机器硬件执行指令的特点（如流水线、RISC、CISC、VLIW等）而对指令进行一些调整使目标代码比较短，执行的效率比较高，也是一个重要的研究课题。

经过优化得到的汇编代码必须经过汇编程序的汇编转换成相应的机器指令，方可能被机器执行。

### 2.1.2 汇编

汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。

目标文件由段组成。通常一个目标文件中至少有两个段：

**1) 代码段**：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。

**2) 数据段**：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。

UNIX环境下主要有三种类型的目标文件：

**1) 可重定位文件**

其中包含有适合于其它目标文件链接来创建一个可执行的或者共享的目标文件的代码和数据。

**2) 共享的目标文件**

这种文件存放了适合于在两种上下文里链接的代码和数据。

第一种是链接程序可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个目标文件；

第二种是动态链接程序将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。

**3) 可执行文件**

它包含了一个可以被操作系统创建一个进程来执行之的文件。

汇编程序生成的实际上是第一种类型的目标文件。对于后两种还需要其他的一些处理方能得到，这个就是链接程序的工作了。

## 2.2 链接过程

由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。

例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。

链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。

根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：

**1) 静态链接**

在这种链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被**装入到**该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。

**2) 动态链接**

在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被**映射到**运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。

对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

## 2.3 GCC的编译链接

我们在linux使用的gcc编译器便是把以上的几个过程进行捆绑，使用户只使用一次命令就把编译工作完成，这的确方便了编译工作，但对于初学者了解编译过程就很不利了，下图便是gcc代理的编译过程：

<img src="/Users/fanqingwei/Desktop/学习/golang\images\GCC编译过程.png" style="zoom:50%;" />

从上图可以看到：

**1) 预编译**

将.c 文件转化成 .i文件

使用的gcc命令是：gcc –E

对应于预处理命令cpp

**2) 编译**

将.c/.h文件转换成.s文件

使用的gcc命令是：gcc –S

对应于编译命令 cc –S

**3) 汇编**

将.s 文件转化成 .o文件

使用的gcc 命令是：gcc –c

对应于汇编命令是 as

**4) 链接**

将.o文件转化成可执行程序

使用的gcc 命令是： gcc

对应于链接命令是 ld

总结起来编译过程就上面的四个过程：预编译处理(.c) －－> 编译、优化程序（.s、.asm）－－> 汇编程序(.obj、.o、.a、.ko) －－> 链接程序（.exe、.elf、.axf等）。

## 2.4 总结

C语言编译的整个过程是非常复杂的，里面涉及到的编译器知识、硬件知识、工具链知识都是非常多的，深入了解整个编译过程对工程师理解应用程序的编写是有很大帮助的，希望大家可以多了解一些，在遇到问题时多思考、多实践。

一般情况下，我们只需要知道分成编译和链接两个阶段，编译阶段将源程序（*.c) 转换成为目标代码（一般是obj文件，至于具体过程就是上面说的那些阶段），链接阶段是把源程序转换成的目标代码（obj文件）与你程序里面调用的库函数对应的代码连接起来形成对应的可执行文件（exe文件）就可以了，其他的都需要在实践中多多体会才能有更深的理解。

# 3. go语言简介

## 3.1 Go语言工程结构详述

一般的编程语言往往对工程（项目）的目录结构是没有什么规定的，但是Go语言却在这方面做了相关规定，本节我们就来聊聊Go语言在工程结构方面的有关知识。

我们前面讲搭建Go语言开发环境时提到的环境变量 GOPATH，项目的构建主要是靠它来实现的。这么说吧，如果想要构建一个项目，就需要将这个项目的目录添加到 GOPATH 中，多个项目之间可以使用`;`分隔。

如果不配置 GOPATH，即使处于同一目录，代码之间也无法通过绝对路径相互调用。

### 3.1.1 目录结构

一个Go语言项目的目录一般包含以下三个子目录：

- src 目录：放置项目和库的源文件；
- pkg 目录：放置编译后生成的包/库的归档文件；
- bin 目录：放置编译后生成的可执行文件。

三个目录中我们需要重点关注的是 src 目录，其他两个目录了解即可，下面来分别介绍一下这三个目录。

#### src 目录

用于以包（package）的形式组织并存放 Go 源文件，这里的包与 src 下的每个子目录最好是一一对应。例如，若一个源文件被声明属于 log 包，那么它最好保存在 src/log 目录中。

并不是说 src 目录下不能存放 Go 源文件，一般在测试或演示的时候也可以把 Go 源文件直接放在 src 目录下，但是这么做的话就最好声明该源文件属于 main 包了。正常开发中还是建议大家把 Go 源文件放入特定的目录中。

包是Go语言管理代码的重要机制，其作用类似于Java中的 package 和 C/C++ 的头文件。Go 源文件中第一段有效代码必须是`package <包名> `的形式，如 package hello。

另外需要注意的是，Go语言会把通过`go get `命令获取到的库源文件下载到 src 目录下对应的文件夹当中。

总结如下几点：

- **import后面的是目录**
- **包名和目录名没有关系，但是包名最好等于目录名**
- **同一个目录下只能有一种包名。**
- **调用方法的时候使用【import目录下】文件指定的包名调用**

#### pkg 目录

用于存放通过`go install `命令安装某个包后的归档文件。归档文件是指那些名称以“.a”结尾的文件。

该目录与 GOROOT 目录（也就是Go语言的安装目录）下的 pkg 目录功能类似，区别在于这里的 pkg 目录专门用来存放项目代码的归档文件。

编译和安装项目代码的过程一般会以代码包为单位进行，比如 log 包被编译安装后，将生成一个名为 log.a 的归档文件，并存放在当前项目的 pkg 目录下。

#### bin 目录

与 pkg 目录类似，在通过`go install `命令完成安装后，保存由 Go 命令源文件生成的可执行文件。在类 Unix 操作系统下，这个可执行文件的名称与命令源文件的文件名相同。而在 Windows 操作系统下，这个可执行文件的名称则是命令源文件的文件名加 .exe 后缀。

### 3.1.2 源文件

上面我们提到了命令源文件和库源文件，它们到底是什么呢？

- 命令源文件：如果一个 Go 源文件被声明属于 main 包，并且该文件中包含 main 函数，则它就是命令源码文件。命令源文件属于程序的入口，可以通过Go语言的`go run `命令运行或者通过`go build `命令生成可执行文件。
- 库源文件：库源文件则是指存在于某个包中的普通源文件，并且库源文件中不包含 main 函数。

## 3.2 Goland

### 3.2.1 环境配置

<img src="/Users/fanqingwei/Desktop/学习/golang\images\goland运行环境配置.png" style="zoom: 25%;" />

GOROOT: golang 的安装路径

GOPATH:

-  编译后二进制的存放目的地和import包时的搜索路径 （也就是你的工作目录, 你可以在src下创建你自己的go源文件）
- GOPATH之下主要包含三个目录: bin、pkg、src

### 3.2.2 项目配置

![]()<img src="/Users/fanqingwei/Desktop/学习/golang\images\goland环境配置.png" alt="goland环境配置" style="zoom:50%;" />

上图中有以下几点需要注意：

- 名称：为本条配置信息的名称，可以自定义，也可以使用系统默认的值；
- Run kind：这里需要设置为“Directory”；
- Directory：用来设置 main 包所在的目录，不能为空；
- Output directory：用来设置编译后生成的可执行文件的存放目录，可以为空，为空时默认不生成可执行文件；
- Working directory：用来设置程序的运行目录，可以与“Directory”的设置相同，但是不能为空。

# 4. GO 结构体三种主要实例化方法及其内存分配区别

结构体是众多属性的集合，每个属性都有其类型和值。在对结构体的使用中，结构体的初始化必不可少，本文列举Go中主要的几种初始化方法及示例，最后从内存分配角度分析了其区别。

------

## 4.1 三种主要实例化方法

### 1. VAR 声明

```go
type person struct{
	age   int
	name  string
}

func main()  {
	var  fan person
	fan.age = 10
	fan.name = "fan"
}

1234567891011
```

------

### 2.NEW关键字

方式1：

```go
func main()  {
	fan := new(person)
	fan.name = "fan"
	fan.age = 26
}
12345
```

方式2：

```go
func main()  {
	fan := &person{
		26,"fan"
	}
	fmt.Println(fan.age)
}
123456
```

### 3. 赋值初始化

方式1：

```go
func main()  {
	fan := person{
		name: "fan",
		age:  10,
	}
}

1234567
```

方式2：

```go
func main()  {
	fan := person{
		"fan",
		 10,
	}
}

12345678
```

方式1和方式2区别：**赋值顺序**；方式2必须对应结构体定义顺序；

------

## 4.2 内存布局区别

### 1.VAR 声明

![是发哦文件](https://www.freesion.com/images/632/9a8f547e537f90e05f90251ab5a1a878.png)
var p point 为p分配内存，并零值化；

### 2.NEW关键字

![在这里插入图片描述](https://www.freesion.com/images/117/c75042ad357591ce02239932c2ca02cd.png)
new返回一个指向Point的指针；

### 3. 赋值初始化

![在这里插入图片描述](https://www.freesion.com/images/987/39bcfe636380feacdcf1ac220f87e1db.png)

# 5. 常用标准库之-fmt

## 5.1 向外输出

标准库`fmt`提供了以下几种输出相关函数。

### **5.1.1 Print**

`Print`函数直接输出内容

`Printf`函数支持格式化输出字符串

`Println`函数会在输出内容的结尾添加一个换行符

```go
func Print(a ...interface{}) (n int, err error)
func Printf(format string, a ...interface{}) (n int, err error)
func Println(a ...interface{}) (n int, err error)
```

举个简单的例子：

```go
func main() {
    fmt.Print("lqz is NB")
    name := "lqz"
    fmt.Printf("我是：%s\n", name)
    fmt.Println("打印并换行")
}
```

执行上面的代码输出：

```go
lqz is NB我是：lqz
打印并换行
```

### **5.1.2 格式化输出占位符**

`*printf`系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。

#### **通用占位符**

| 占位符 | 说明                                           |
| ------ | ---------------------------------------------- |
| %v     | 值的默认格式输出（不知道用什么占都可以用这个） |
| %+v    | 类似于%v，但输出结构体时会输出字段名           |
| %#v    | 值的Go语法表示                                 |
| %T     | 打印值的类型                                   |
| %%     | 百分号                                         |

示例代码如下：

```go
    fmt.Printf("名字是：%v\n","lqz")
    fmt.Printf("年龄是：%v\n",19)
    p:= struct {
        name string
        age int
    }{"lqz",19}
    fmt.Printf("结构体内容为：%v\n",p)
    fmt.Printf("结构体内容为(带字段名)：%+v\n",p) // 输出结构体是会带name
    fmt.Printf("结构体内容为(值的Go语法表示)：%#v\n",p) // 输出结构体是会带name


    fmt.Printf("切片内容为：%v\n",[]int{4,5,6})
    fmt.Printf("切片内容为(值的Go语法表示)：%#v\n",[]int{4,5,6})

    fmt.Printf("切片值的类型为：%T\n",[]int{4,5,6})
    fmt.Printf("字符串值的类型为：%T\n","lqz")

    fmt.Printf("打印百分百：100%%\n")
```

输出结果如下：

```bash
名字是：lqz
年龄是：19
结构体内容为：{lqz 19}
结构体内容为(带字段名)：{name:lqz age:19}
结构体内容为(值的Go语法表示)：struct { name string; age int }{name:"lqz", age:19}
切片内容为：[4 5 6]
切片内容为(值的Go语法表示)：[]int{4, 5, 6}
切片值的类型为：[]int
字符串值的类型为：string
打印百分百：100%

```

#### **布尔型**

| 占位符 | 说明        |
| ------ | ----------- |
| %t     | true或false |

```go
var limit bool = false;
fmt.Printf("limit=%t \n",limit)
```

#### **整型**

| 占位符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| %b     | 表示为二进制                                                 |
| %c     | 该值对应的unicode码值                                        |
| %d     | 表示为十进制                                                 |
| %o     | 表示为八进制                                                 |
| %x     | 表示为十六进制，使用a-f                                      |
| %X     | 表示为十六进制，使用A-F                                      |
| %U     | 表示为Unicode格式：U+1234，等价于”U+%04X”                    |
| %q     | 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 |

示例代码如下：

```go
    n := 3333
    fmt.Printf("二进制表示：%b\n", n)
    fmt.Printf("unicode对应的字符：%c\n", n)
    fmt.Printf("十进制表示：%d\n", n)
    fmt.Printf("八进制表示：%o\n", 9)
    fmt.Printf("十六进制小写：%x\n", 123)
    fmt.Printf("十六进制大写：%X\n", 123)
    fmt.Printf("用引号引起来的字符字面值：%q\n", 65)
```

输出结果如下：

```bash
二进制表示：110100000101
unicode对应的字符：അ
十进制表示：3333
八进制表示：11
十六进制小写：7b
十六进制大写：7B
用引号引起来的字符字面值：'A'
```

#### **浮点数与复数**

| 占位符 | 说明                                                   |
| ------ | ------------------------------------------------------ |
| %b     | 无小数部分、二进制指数的科学计数法，如-123456p-78      |
| %e     | 科学计数法，如-1234.456e+78                            |
| %E     | 科学计数法，如-1234.456E+78                            |
| %f     | 有小数部分但无指数部分，如123.456                      |
| %F     | 等价于%f                                               |
| %g     | 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） |
| %G     | 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） |

示例代码如下：

```go
	f := 3.14159
	fmt.Printf("无小数部分、二进制指数的科学计数法，(如-123456p-78):%b\n", f)
	fmt.Printf("科学计数法(-1234.456e+78)：%e\n", f)
	fmt.Printf("科学计数法(如-1234.456E+78)：%E\n", f)
	fmt.Printf("有小数部分但无指数部分:%f\n", f)
	fmt.Printf("有小数部分但无指数部分:%F\n", f)
	fmt.Printf("根据实际情况采用%%e或%%f格式（以获得更简洁、准确的输出）:%g\n", f)
	fmt.Printf("根据实际情况采用%%E或%%F格式（以获得更简洁、准确的输出）:%G\n", f)
```

输出结果如下：

```bash
无小数部分、二进制指数的科学计数法，(如-123456p-78):7074231776675438p-51
科学计数法(-1234.456e+78)：3.141590e+00
科学计数法(如-1234.456E+78)：3.141590E+00
有小数部分但无指数部分:3.141590
有小数部分但无指数部分:3.141590
根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）:3.14159
根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）:3.14159
```

#### **字符串和[]byte**

| 占位符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| %s     | 直接输出字符串或者[]byte                                     |
| %q     | 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示 |
| %x     | 每个字节用两字符十六进制数表示（使用a-f）                    |
| %X     | 每个字节用两字符十六进制数表示（使用A-F）                    |

示例代码如下：

```go
	name:="lqz"
	b:=[]byte{'l','q','z',65}
	fmt.Printf("字符串为：%s\n",name)
	fmt.Printf("切片为：%s\n",b)

	fmt.Printf("双引号括起来的go语法字符串字面值：%q\n",name)
	fmt.Printf("双引号括起来的go语法字符串字面值：%q\n",b)

	fmt.Printf("每个字节用两字符十六进制数表示：%x\n",name)
	fmt.Printf("每个字节用两字符十六进制数表示：%x\n",b)

	fmt.Printf("每个字节用两字符十六进制数表示（使用a-f）：%X\n",name)
	fmt.Printf("每个字节用两字符十六进制数表示（使用A-F）：%X\n",b)
```

输出结果如下：

```bash
字符串为：lqz
切片为：lqzA
双引号括起来的go语法字符串字面值："lqz"
双引号括起来的go语法字符串字面值："lqzA"
每个字节用两字符十六进制数表示：6c717a
每个字节用两字符十六进制数表示：6c717a41
每个字节用两字符十六进制数表示（使用a-f）：6c717a
每个字节用两字符十六进制数表示（使用A-F）：6C717A41
```

#### **指针**

| 占位符 | 说明                           |
| ------ | ------------------------------ |
| %p     | 表示为十六进制，并加上前导的0x |

示例代码如下：

```go
	a := 99
	fmt.Printf("%p\n", &a)
	fmt.Printf("%#p\n", &a)
```

输出结果如下：

```bash
0xc000018078
c000018078
```

#### **宽度标识符**

宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：

| 占位符 | 说明               |
| ------ | ------------------ |
| %f     | 默认宽度，默认精度 |
| %9f    | 宽度9，默认精度    |
| %.2f   | 默认宽度，精度2    |
| %9.2f  | 宽度9，精度2       |
| %9.f   | 宽度9，精度0       |

示例代码如下：

```go
n := 12.34
fmt.Printf("%f\n", n)
fmt.Printf("%9f\n", n)
fmt.Printf("%.2f\n", n)
fmt.Printf("%9.2f\n", n)
fmt.Printf("%9.f\n", n)
```

输出结果如下：

```bash
默认宽度，默认精度:3.141593
宽度9，默认精度: 3.141593
默认宽度，精度2:3.14
宽度9，精度2:     3.14
宽度9，精度0:        3
```

#### **其他flag**

| 占位符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 'x'    | 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）； |
| ''     | 对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格 |
| '-'    | 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； |
| '#'    | 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值； |
| '0'    | 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面； |

举个例子：

```go
	s := "刘清政"
	fmt.Printf("正常字符串输出：%s\n", s)
	fmt.Printf("宽度是5，右对齐：%5s\n", s)
	fmt.Printf("宽度是5，左对齐：%-5s\n", s)
	fmt.Printf("总长度为3,截取2个，右对齐：%3.2s\n", s)
	fmt.Printf("总长度为3,截取2个，左对齐：%-3.2s\n", s)
	fmt.Printf("宽度为5，只要2个字符：%5.2s\n", s)
	fmt.Printf("宽度为5，不够用0补齐：%05s\n", s)
```

输出结果如下：

```bash
正常字符串输出：刘清政
宽度是5，右对齐：  刘清政
宽度是5，左对齐：刘清政  
总长度为3,截取2个，右对齐： 刘清
总长度为3,截取2个，左对齐：刘清 
宽度为5，只要2个字符：   刘清
宽度为5，不够用0补齐：00刘清政
```

### **5.1.3 Fprint**

`Fprint`系列函数会将内容输出到一个`io.Writer`接口类型的变量`w`中，我们通常用这个函数往文件中写入内容。

```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
```

举个例子：

```go
func main() {
	// 向标准输出写入内容
	fmt.Fprintln(os.Stdout, "向标准输出(控制台)写入内容")
	fileObj, err := os.OpenFile("./xx.txt", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		fmt.Println("打开文件出错，err:", err)
		return
	}
	name := "lqz is nb"
	// 向打开的文件句柄中写入内容
	fmt.Fprintf(fileObj, "往文件中(标准输出)写如信息：%s", name)

}
```

注意，只要满足`io.Writer`接口的类型都支持写入

### **5.1.4 Sprint**

`Sprint`系列函数会把传入的数据生成并返回一个字符串。

```go
func Sprint(a ...interface{}) string
func Sprintf(format string, a ...interface{}) string
func Sprintln(a ...interface{}) string
```

简单的示例代码如下：

```go
	s1 := fmt.Sprint("lqz")
	name := "lqz"
	age := 18
	s2 := fmt.Sprintf("姓名:%s,年龄:%d", name, age)
	s3 := fmt.Sprintln("lqz is nb")
	fmt.Println(s1, s2, s3)
lqz 姓名:lqz,年龄:18 lqz is nb
```



### **5.1.5 Errorf**

`Errorf`函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。

```go
func Errorf(format string, a ...interface{}) error
```

通常使用这种方式来自定义错误类型，例如：

```go
err := fmt.Errorf("这是一个错误")
```

Go1.13后版本为`fmt.Errorf`函数新加了一个`%w`占位符用来生成一个可以包裹Error的Wrapping Error。

```go
e := errors.New("原始错误e")
w := fmt.Errorf("Wrap了一个错误%w", e)
	err := fmt.Errorf("这是一个错误")
	fmt.Printf("类型是：%T，值是：%v",err,err)
	fmt.Println("-----")
	e := errors.New("原始错误e")
	w := fmt.Errorf("Wrap了一个错误：%w", e)
	fmt.Println(w)
类型是：*errors.errorString，值是：这是一个错误-----
Wrap了一个错误：原始错误e
```

## 5.2 获取输入

Go语言`fmt`包下有`fmt.Scan`、`fmt.Scanf`、`fmt.Scanln`三个函数，可以在程序运行过程中从标准输入获取用户的输入。

### 5.2.1 fmt.Scan

函数定签名如下：

```go
func Scan(a ...interface{}) (n int, err error)
```

- Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。
- 本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。

具体代码示例如下：

```go
	var (
		name string
		age  int
	)
	fmt.Scan(&name, &age)
	fmt.Printf("输入的值为： 姓名:%s 年龄:%d \n", name, age)
```

将上面的代码编译后在终端执行，在终端依次输入`小王子`、`28`和`false`使用空格分隔。

```go
lqz 19
// 或者
lqz
19
```

`fmt.Scan`从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。

### 5.2.2 fmt.Scanf

函数签名如下：

```go
func Scanf(format string, a ...interface{}) (n int, err error)
```

- Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。
- 本函数返回成功扫描的数据个数和遇到的任何错误。

代码示例如下：

```go
var (
		name string
		age  int
	)
	fmt.Scanf("name:%s age:%d", &name, &age) // 在控制台按照该格式输入
	fmt.Printf("扫描结果： 姓名:%s 年龄:%d \n", name, age)
```

将上面的代码编译后在终端执行，在终端按照指定的格式依次输入`小王子`、`28`和`false`。

```go
// 控制台按如下格式输入
name:lqz age:19
扫描结果： 姓名:lqz 年龄:19 
```

`fmt.Scanf`不同于`fmt.Scan`简单的以空格作为输入数据的分隔符，`fmt.Scanf`为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。

例如，我们还是按照上个示例中以空格分隔的方式输入，`fmt.Scanf`就不能正确扫描到输入的数据。

```bash
lqz 19
扫描结果： 姓名: 年龄:0 
```

### 5.2.3 fmt.Scanln

函数签名如下：

```go
func Scanln(a ...interface{}) (n int, err error)
```

- Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。
- 本函数返回成功扫描的数据个数和遇到的任何错误。

具体代码示例如下：

```go
var (
    name    string
    age     int
)
fmt.Scanln(&name, &age)
fmt.Printf("扫描结果 姓名:%s 年龄:%d \n", name, age)
```

将上面的代码编译后在终端执行，在终端依次输入`小王子`、`28`和`false`使用空格分隔。

```go
//输入：   刘清政 19  敲回车
扫描结果 姓名:刘清政 年龄:19 
```

`fmt.Scanln`遇到回车就结束扫描了，这个比较常用。

### 5.2.4 bufio.NewReader

有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用`bufio`包来实现。示例代码如下：

```go
reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象
fmt.Print("请输入内容：")
text, _ := reader.ReadString('\n') // 读到换行
text = strings.TrimSpace(text) // 去掉空白
fmt.Printf("%#v\n", text)
请输入内容：输入的内容
"输入的内容"
```

### 5.2.5 Fscan系列

这几个函数功能分别类似于`fmt.Scan`、`fmt.Scanf`、`fmt.Scanln`三个函数，只不过它们不是从标准输入中读取数据而是从`io.Reader`中读取数据。

```go
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
```

### 5.2.6 Sscan系列

这几个函数功能分别类似于`fmt.Scan`、`fmt.Scanf`、`fmt.Scanln`三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。

```go
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
var name string="lqz"
var newName string=""
fmt.Sscan(name,&newName) // 相当于把name的值赋值给newName
fmt.Println(name)
fmt.Println(newName)
```