[TOC]

# 1. Linux编码问题

大致分为存储乱码和显示乱码

# 2. 系统架构

## 2.1 Linux 接口

Linux 系统是一种金字塔模型的系统，如下所示

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\linux接口.png)

应用程序发起系统调用把参数放在寄存器中(有时候放在栈中)，并发出 `trap` 系统陷入指令切换用户态至内核态。因为不能直接在 C 中编写 trap 指令，因此 C 提供了一个库，库中的函数对应着系统调用。有些函数是使用汇编编写的，但是能够从 C 中调用。每个函数首先把参数放在合适的位置然后执行系统调用指令。因此如果你想要执行 read 系统调用的话，C 程序会调用 read 函数库来执行。这里顺便提一下，是由 POSIX 指定的库接口而不是系统调用接口。也就是说，POSIX 会告诉一个标准系统应该提供哪些库过程，它们的参数是什么，它们必须做什么以及它们必须返回什么结果。

除了操作系统和系统调用库外，Linux 操作系统还要提供一些标准程序，比如文本编辑器、编译器、文件操作工具等。直接和用户打交道的是上面这些应用程序。因此我们可以说 Linux 具有三种不同的接口：**「系统调用接口、库函数接口和应用程序接口」**

## 2.2 Linux 组成部分

事实上，Linux 操作系统可以由下面这几部分构成

- `引导程序(Bootloader)`：引导程序是管理计算机启动过程的软件，对于大多数用户而言，只是弹出一个屏幕，但其实内部操作系统做了很多事情
- `内核(Kernel)`：内核是操作系统的核心，负责管理 CPU、内存和外围设备等。
- `初始化系统(Init System)`：这是一个引导用户空间并负责控制守护程序的子系统。一旦从引导加载程序移交了初始引导，它就是用于管理引导过程的初始化系统。
- `后台进程(Daemon)`：后台进程顾名思义就是在后台运行的程序，比如打印、声音、调度等，它们可以在引导过程中启动，也可以在登录桌面后启动
- `图形服务器(Graphical server)`：这是在监视器上显示图形的子系统。通常将其称为 X 服务器或 X。
- `桌面环境(Desktop environment)`：这是用户与之实际交互的部分，有很多桌面环境可供选择，每个桌面环境都包含内置应用程序，比如文件管理器、Web 浏览器、游戏等
- `应用程序(Applications)`：桌面环境不提供完整的应用程序，就像 Windows 和 macOS 一样，Linux 提供了成千上万个可以轻松找到并安装的高质量软件。

## 2.3 Linux 应用程序

Linux 的命令行也就是 shell，它由大量标准应用程序组成。这些应用程序主要有下面六种

- 文件和目录操作命令
- 过滤器
- 文本程序
- 系统管理
- 程序开发工具，例如编辑器和编译器
- 其他

除了这些标准应用程序外，还有其他应用程序比如 **「Web 浏览器、多媒体播放器、图片浏览器、办公软件和游戏程序等」**。

我们在上面的例子中已经见过了几个 Linux 的应用程序，比如 sort、cp、ls、head

## 2.4 Linux 内核结构

在上面我们看到了 Linux 的整体结构，下面我们从整体的角度来看一下 Linux 的内核结构

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\linux内核结构.webp)

内核直接坐落在硬件上，内核的主要作用就是 I/O 交互、内存管理和控制 CPU 访问。上图中还包括了 `中断` 和 `调度器`，中断是与设备交互的主要方式。中断出现时调度器就会发挥作用。这里的低级代码停止正在运行的进程，将其状态保存在内核进程结构中，并启动驱动程序。进程调度也会发生在内核完成一些操作并且启动用户进程的时候。图中的调度器是 dispatcher

```
注意这里的调度器是 `dispatcher` 而不是 `scheduler`，这两者是有区别的

scheduler 和 dispatcher 都是和进程调度相关的概念，不同的是 scheduler 会从几个进程中随意选取一个进程；而 dispatcher 会给 scheduler 选择的进程分配 CPU注意这里的调度器是 `dispatcher` 而不是 `scheduler`，这两者是有区别的

scheduler 和 dispatcher 都是和进程调度相关的概念，不同的是 scheduler 会从几个进程中随意选取一个进程；而 dispatcher 会给 scheduler 选择的进程分配 CPU
```

然后，我们把内核系统分为三部分。

- I/O 部分负责与设备进行交互以及执行网络和存储 I/O 操作的所有内核部分。

从图中可以看出 I/O 层次的关系，最高层是一个`虚拟文件系统`，也就是说不管文件是来自内存还是磁盘中，都是经过虚拟文件系统中的。从底层看，所有的驱动都是字符驱动或者块设备驱动。二者的主要区别就是是否允许随机访问。网络驱动设备并不是一种独立的驱动设备，它实际上是一种字符设备，不过网络设备的处理方式和字符设备不同。

上面的设备驱动程序中，每个设备类型的内核代码都不同。字符设备有两种使用方式，有`一键式`的比如 vi 或者 emacs ，需要每一个键盘输入。其他的比如 shell ，是需要输入一行按回车键将字符串发送给程序进行编辑。

网络软件通常是模块化的，由不同的设备和协议来支持。大多数 Linux 系统在内核中包含一个完整的硬件路由器的功能，但是这个不能和外部路由器相比，路由器上面是`协议栈`，包括 TCP/IP 协议，协议栈上面是 socket 接口，socket 负责与外部进行通信，充当了门的作用。

磁盘驱动上面是 I/O 调度器，它负责排序和分配磁盘读写操作，以尽可能减少磁头的无用移动。

- I/O 右边的是内存部件，程序被装载进内存，由 CPU 执行，这里会涉及到虚拟内存的部件，页面的换入和换出是如何进行的，坏页面的替换和经常使用的页面会进行缓存。
- 进程模块负责进程的创建和终止、进程的调度、Linux 把进程和线程看作是可运行的实体，并使用统一的调度策略来进行调度。

在内核最顶层的是系统调用接口，所有的系统调用都是经过这里，系统调用会触发一个 trap，将系统从用户态转换为内核态，然后将控制权移交给上面的内核部件。

## 2.5 Linux 进程和线程

系统调用是操作系统本身的接口，它对于创建进程和线程，内存分配，共享文件和 I/O 来说都很重要。

从各个版本的共性出发来进行探讨

### 2.5.1 基本概念

每个进程都会运行一段独立的程序，并且在初始化的时候拥有一个独立的控制线程。换句话说，每个进程都会有一个自己的程序计数器，这个程序计数器用来记录下一个需要被执行的指令。Linux 允许进程在运行时创建额外的线程。

<img src="C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\程序计数器.png" style="zoom:50%;" />

Linux 是一个多道程序设计系统，因此系统中存在彼此相互独立的进程同时运行。此外，每个用户都会同时有几个活动的进程。因为如果是一个大型系统，可能有数百上千的进程在同时运行。

在某些用户空间中，即使用户退出登录，仍然会有一些后台进程在运行，这些进程被称为 `守护进程(daemon)`。

Linux 中有一种特殊的守护进程被称为 `计划守护进程(Cron daemon)` ，计划守护进程可以每分钟醒来一次检查是否有工作要做，做完会继续回到睡眠状态等待下一次唤醒。

```
Cron 是一个守护程序，可以做任何你想做的事情，比如说你可以定期进行系统维护、定期进行系统备份等。在其他操作系统上也有类似的程序，比如 Mac OS X 上 Cron 守护程序被称为 launchd 的守护进程。在 Windows 上可以被称为 计划任务(Task Scheduler)
```

在 Linux 系统中，进程通过非常简单的方式来创建，`fork` 系统调用会创建一个源进程的`拷贝(副本)`。调用 fork 函数的进程被称为 `父进程(parent process)`，使用 fork 函数创建出来的进程被称为 `子进程(child process)`。父进程和子进程都有自己的内存映像。如果在子进程创建出来后，父进程修改了一些变量等，那么子进程是看不到这些变化的，也就是 fork 后，父进程和子进程相互独立。

虽然父进程和子进程保持相互独立，但是它们却能够共享相同的文件，如果在 fork 之前，父进程已经打开了某个文件，那么 fork 后，父进程和子进程仍然共享这个打开的文件。对共享文件的修改会对父进程和子进程同时可见。

那么该如何区分父进程和子进程呢？子进程只是父进程的拷贝，所以它们几乎所有的情况都一样，包括内存映像、变量、寄存器等。区分的关键在于 `fork` 函数调用后的返回值，如果 fork 后返回一个非零值，这个非零值即是子进程的 `进程标识符(Process Identiier, PID)`，而会给子进程返回一个零值，可以用下面代码来进行表示

```shell
pid = fork();    // 调用 fork 函数创建进程
if(pid < 0){
  error()     // pid < 0,创建失败
}
else if(pid > 0){
  parent_handle() // 父进程代码
}
else {
  child_handle()  // 子进程代码
}
```

父进程在 fork 后会得到子进程的 PID，这个 PID 即能代表这个子进程的唯一标识符也就是 PID。如果子进程想要知道自己的 PID，可以调用 `getpid` 方法。当子进程结束运行时，父进程会得到子进程的 PID，因为一个进程会 fork 很多子进程，子进程也会 fork 子进程，所以 PID 是非常重要的。我们把第一次调用 fork 后的进程称为 `原始进程`，一个原始进程可以生成一颗继承树

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\进程树.png)

### 2.5.2Linux 进程间通信

Linux 进程间的通信机制通常被称为 `Internel-Process communication,IPC`下面我们来说一说 Linux 进程间通信的机制，大致来说，Linux 进程间的通信机制可以分为 6 种

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\进程间通信.png)

下面我们分别对其进行概述

#### 信号 signal

信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送`异步事件信号`来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。

你可以在 Linux 系统上输入 `kill -l` 来列出系统使用的信号，下面是我提供的一些信号

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\系统使用的信号.png)

进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：`SIGSTOP` 和 `SIGKILL` 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。

操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。

例如：当进程收到 `SIGFPE` 浮点异常的信号后，默认操作是对其进行 `dump(转储)`和退出。信号没有优先级的说法。如果同时为某个进程产生了两个信号，则可以将它们呈现给进程或者以任意的顺序进行处理。

下面我们就来看一下这些信号是干什么用的

- SIGABRT 和 SIGIOT

SIGABRT 和 SIGIOT 信号发送给进程，告诉其进行终止，这个 信号通常在调用 C标准库的`abort()`函数时由进程本身启动

- SIGALRM 、 SIGVTALRM、SIGPROF

当设置的时钟功能超时时会将 SIGALRM 、 SIGVTALRM、SIGPROF 发送给进程。当实际时间或时钟时间超时时，发送 SIGALRM。当进程使用的 CPU 时间超时时，将发送 SIGVTALRM。当进程和系统代表进程使用的CPU 时间超时时，将发送 SIGPROF。

- SIGBUS

SIGBUS 将造成`总线中断`错误时发送给进程

- SIGCHLD

当子进程终止、被中断或者被中断恢复，将 SIGCHLD 发送给进程。此信号的一种常见用法是指示操作系统在子进程终止后清除其使用的资源。

- SIGCONT

SIGCONT 信号指示操作系统继续执行先前由 SIGSTOP 或 SIGTSTP 信号暂停的进程。该信号的一个重要用途是在 Unix shell 中的作业控制中。

- SIGFPE

SIGFPE 信号在执行错误的算术运算（例如除以零）时将被发送到进程。

- SIGUP

当 SIGUP 信号控制的终端关闭时，会发送给进程。许多守护程序将重新加载其配置文件并重新打开其日志文件，而不是在收到此信号时退出。

- SIGILL

SIGILL 信号在尝试执行非法、格式错误、未知或者特权指令时发出

- SIGINT

当用户希望中断进程时，操作系统会向进程发送 SIGINT 信号。用户输入 ctrl - c 就是希望中断进程。

- SIGKILL

SIGKILL 信号发送到进程以使其马上进行终止。与 SIGTERM 和 SIGINT 相比，这个信号无法捕获和忽略执行，并且进程在接收到此信号后无法执行任何清理操作，下面是一些例外情况

僵尸进程无法杀死，因为僵尸进程已经死了，它在等待父进程对其进行捕获

处于阻塞状态的进程只有再次唤醒后才会被 kill 掉

`init` 进程是 Linux 的初始化进程，这个进程会忽略任何信号。

SIGKILL 通常是作为最后杀死进程的信号、它通常作用于 SIGTERM 没有响应时发送给进程。

- SIGPIPE

SIGPIPE 尝试写入进程管道时发现管道未连接无法写入时发送到进程

- SIGPOLL

当在明确监视的文件描述符上发生事件时，将发送 SIGPOLL 信号。

- SIGRTMIN 至 SIGRTMAX

SIGRTMIN 至 SIGRTMAX 是`实时信号`

- SIGQUIT

当用户请求退出进程并执行核心转储时，SIGQUIT 信号将由其控制终端发送给进程。

- SIGSEGV

当 SIGSEGV 信号做出无效的虚拟内存引用或分段错误时，即在执行分段违规时，将其发送到进程。

- SIGSTOP

SIGSTOP 指示操作系统终止以便以后进行恢复时

- SIGSYS

当 SIGSYS 信号将错误参数传递给系统调用时，该信号将发送到进程。

- SYSTERM

我们上面简单提到过了 SYSTERM 这个名词，这个信号发送给进程以请求终止。与 SIGKILL 信号不同，该信号可以被过程捕获或忽略。这允许进程执行良好的终止，从而释放资源并在适当时保存状态。SIGINT 与SIGTERM 几乎相同。

- SIGTSIP

SIGTSTP 信号由其控制终端发送到进程，以请求终端停止。

- SIGTTIN 和 SIGTTOU

当 SIGTTIN 和SIGTTOU 信号分别在后台尝试从 tty 读取或写入时，信号将发送到该进程。

- SIGTRAP

在发生异常或者 trap 时，将 SIGTRAP 信号发送到进程

- SIGURG

当套接字具有可读取的紧急或带外数据时，将 SIGURG 信号发送到进程。

- SIGUSR1 和 SIGUSR2

SIGUSR1 和 SIGUSR2 信号被发送到进程以指示用户定义的条件。

- SIGXCPU

当 SIGXCPU 信号耗尽 CPU 的时间超过某个用户可设置的预定值时，将其发送到进程

- SIGXFSZ

当 SIGXFSZ 信号增长超过最大允许大小的文件时，该信号将发送到该进程。

- SIGWINCH

SIGWINCH 信号在其控制终端更改其大小（窗口更改）时发送给进程。

#### 管道 pipe

Linux 系统中的进程可以通过建立管道 pipe 进行通信。

在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。**管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止**。shell 中的`管线 pipelines` 就是用管道实现的，当 shell 发现输出

```shell
sort <f | head
```

它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据

<img src="C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\管道.png" style="zoom:50%;" />

管道实际上就是 `|`，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。

#### 共享内存 shared memory

两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。

<img src="C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\共享内存.png" style="zoom:50%;" />

在使用共享内存前，需要经过一系列的调用流程，流程如下

- 创建共享内存段或者使用已创建的共享内存段`(shmget())`
- 将进程附加到已经创建的内存段中`(shmat())`
- 从已连接的共享内存段分离进程`(shmdt())`
- 对共享内存段执行控制操作`(shmctl())`

#### 先入先出队列 FIFO

先入先出队列 FIFO 通常被称为 `命名管道(Named Pipes)`，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\FIFO.png)

写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。

#### 消息队列 Message Queue

一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是`严格模式`， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 `非严格模式`，消息的顺序性不是非常重要。

#### 套接字 Socket

还有一种管理两个进程间通信的是使用 `socket`，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如`TCP（传输控制协议）`或较低级别`UDP（用户数据报协议）`等基础协议的支持。

套接字有以下几种分类

- `顺序包套接字(Sequential Packet Socket)`：此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。
- `数据报套接字(Datagram Socket)`：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。
- `流式套接字(Stream Socket)`：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。
- `原始套接字(Raw Socket)`：可以使用原始套接字访问基础通信协议。

### 2.5.3 Linux 中进程管理系统调用

现在关注一下 Linux 系统中与进程管理相关的系统调用。在了解之前你需要先知道一下什么是系统调用。

操作系统为我们屏蔽了硬件和软件的差异，它的最主要功能就是为用户提供一种抽象，隐藏内部实现，让用户只关心在 GUI 图形界面下如何使用即可。操作系统可以分为两种模式

- 内核态：操作系统内核使用的模式
- 用户态：用户应用程序所使用的模式

我们常说的`上下文切换` 指的就是内核态模式和用户态模式的频繁切换。而`系统调用`指的就是引起内核态和用户态切换的一种方式，系统调用通常在后台静默运行，表示计算机程序向其操作系统内核请求服务。

系统调用指令有很多，下面是一些与进程管理相关的最主要的系统调用

#### fork

fork 调用用于创建一个与父进程相同的子进程，创建完进程后的子进程拥有和父进程一样的程序计数器、相同的 CPU 寄存器、相同的打开文件。

#### exec

exec 系统调用用于执行驻留在活动进程中的文件，调用 exec 后，新的可执行文件会替换先前的可执行文件并获得执行。也就是说，调用 exec 后，会将旧文件或程序替换为新文件或执行，然后执行文件或程序。新的执行程序被加载到相同的执行空间中，因此进程的 `PID`不会修改，因为我们**「没有创建新进程，只是替换旧进程」**。但是进程的数据、代码、堆栈都已经被修改。如果当前要被替换的进程包含多个线程，那么所有的线程将被终止，新的进程映像被加载执行。

这里需要解释一下`进程映像(Process image)` 的概念

**「什么是进程映像呢」**？进程映像是执行程序时所需要的可执行文件，通常会包括下面这些东西

- **「代码段（codesegment/textsegment）」**

又称文本段，用来存放指令，运行代码的一块内存空间

此空间大小在代码运行前就已经确定

内存空间一般属于只读，某些架构的代码也允许可写

在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

- **「数据段（datasegment）」**

可读可写

存储初始化的全局变量和初始化的 static 变量

数据段中数据的生存期是随程序持续性（随进程持续性） 随进程持续性：进程创建就存在，进程死亡就消失

- **「bss 段（bsssegment）：」**

可读可写

存储未初始化的全局变量和未初始化的 static 变量

bss 段中的数据一般默认为 0

- **「Data 段」**

是可读写的，因为变量的值可以在运行时更改。此段的大小也固定。

- **「栈（stack）：」**

可读可写

存储的是函数或代码中的局部变量(非 static 变量)

栈的生存期随代码块持续性，代码块运行就给你分配空间，代码块结束，就自动回收空间

- **「堆（heap）：」**

可读可写

存储的是程序运行期间动态分配的 malloc/realloc 的空间

堆的生存期随进程持续性，从 malloc/realloc 到 free 一直存在

下面是这些区域的构成图

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQrdzMycWgsR1zHCPYrzanUU9Wc7libxmgcdJ42KWXuqUjtiaepribovqRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

exec 系统调用是一些函数的集合，这些函数是

- execl
- execle
- execlp
- execv
- execve
- execvp

下面来看一下 exec 的工作原理

1. 当前进程映像被替换为新的进程映像
2. 新的进程映像是你做为 exec 传递的灿睡
3. 结束当前正在运行的进程
4. 新的进程映像有 PID，相同的环境和一些文件描述符(因为未替换进程，只是替换了进程映像)
5. CPU 状态和虚拟内存受到影响，当前进程映像的虚拟内存映射被新进程映像的虚拟内存代替。

#### waitpid

等待子进程结束或终止

#### exit

在许多计算机操作系统上，计算机进程的终止是通过执行 `exit` 系统调用命令执行的。0 表示进程能够正常结束，其他值表示进程以非正常的行为结束。

其他一些常见的系统调用如下

| 系统调用指令 | 描述                             |
| :----------- | :------------------------------- |
| pause        | 挂起信号                         |
| nice         | 改变分时进程的优先级             |
| ptrace       | 进程跟踪                         |
| kill         | 向进程发送信号                   |
| pipe         | 创建管道                         |
| mkfifo       | 创建 fifo 的特殊文件（命名管道） |
| sigaction    | 设置对指定信号的处理方法         |
| msgctl       | 消息控制操作                     |
| semctl       | 信号量控制                       |

### 2.5.4 Linux 进程和线程的实现

#### Linux 进程

在 Linux 内核结构中，进程会被表示为 `任务`，通过结构体 `structure` 来创建。不像其他的操作系统会区分进程、轻量级进程和线程，Linux 统一使用任务结构来代表执行上下文。因此，对于每个单线程进程来说，单线程进程将用一个任务结构表示，对于多线程进程来说，将为每一个用户级线程分配一个任务结构。Linux 内核是多线程的，并且内核级线程不与任何用户级线程相关联。

对于每个进程来说，在内存中都会有一个 `task_struct` 进程描述符与之对应。进程描述符包含了内核管理进程所有有用的信息，包括 **「调度参数、打开文件描述符等等」**。进程描述符从进程创建开始就一直存在于内核堆栈中。

Linux 和 Unix 一样，都是通过 `PID` 来区分不同的进程，内核会将所有进程的任务结构组成为一个双向链表。PID 能够直接被映射称为进程的任务结构所在的地址，从而不需要遍历双向链表直接访问。

我们上面提到了进程描述符，这是一个非常重要的概念，我们上面还提到了进程描述符是位于内存中的，这里我们省略了一句话，那就是进程描述符是存在用户的任务结构中，当进程位于内存并开始运行时，进程描述符才会被调入内存。

```
进程位于内存被称为 PIM(Process In Memory) ，这是冯诺伊曼体系架构的一种体现，加载到内存中并执行的程序称为进程。简单来说，一个进程就是正在执行的程序。
```

进程描述符可以归为下面这几类

- `调度参数(scheduling parameters)`：进程优先级、最近消耗 CPU 的时间、最近睡眠时间一起决定了下一个需要运行的进程
- `内存映像(memory image)`：我们上面说到，进程映像是执行程序时所需要的可执行文件，它由数据和代码组成。
- `信号(signals)`：显示哪些信号被捕获、哪些信号被执行
- `寄存器`：当发生内核陷入 (trap) 时，寄存器的内容会被保存下来。
- `系统调用状态(system call state)`：当前系统调用的信息，包括参数和结果
- `文件描述符表(file descriptor table)`：有关文件描述符的系统被调用时，文件描述符作为索引在文件描述符表中定位相关文件的 i-node 数据结构
- `统计数据(accounting)`：记录用户、进程占用系统 CPU 时间表的指针，一些操作系统还保存进程最多占用的 CPU 时间、进程拥有的最大堆栈空间、进程可以消耗的页面数等。
- `内核堆栈(kernel stack)`：进程的内核部分可以使用的固定堆栈
- `其他`：当前进程状态、事件等待时间、距离警报的超时时间、PID、父进程的 PID 以及用户标识符等

有了上面这些信息，现在就很容易描述在 Linux 中是如何创建这些进程的了，创建新流程实际上非常简单。**「为子进程开辟一块新的用户空间的进程描述符，然后从父进程复制大量的内容。为这个子进程分配一个 PID，设置其内存映射，赋予它访问父进程文件的权限，注册并启动」**。

当执行 fork 系统调用时，调用进程会陷入内核并创建一些和任务相关的数据结构，比如`内核堆栈(kernel stack)` 和 `thread_info` 结构。

> 关于 thread_info 结构可以参考
>
> https://docs.huihoo.com/doxygen/linux/kernel/3.7/arch_2avr32_2include_2asm_2thread__info_8h_source.html

这个结构中包含进程描述符，进程描述符位于固定的位置，使得 Linux 系统只需要很小的开销就可以定位到一个运行中进程的数据结构。

进程描述符的主要内容是根据`父进程`的描述符来填充。Linux 操作系统会寻找一个可用的 PID，并且此 PID 没有被任何进程使用，更新进程标示符使其指向一个新的数据结构即可。为了减少 hash table 的碰撞，进程描述符会形成`链表`。它还将 task_struct 的字段设置为指向任务数组上相应的上一个/下一个进程。

> task_struct ：Linux 进程描述符，内部涉及到众多 C++ 源码，我们会在后面进行讲解。

从原则上来说，为子进程开辟内存区域并为子进程分配数据段、堆栈段，并且对父进程的内容进行复制，但是实际上 fork 完成后，子进程和父进程没有共享内存，所以需要复制技术来实现同步，但是复制开销比较大，因此 Linux 操作系统使用了一种 `欺骗` 方式。即为子进程分配页表，然后新分配的页表指向父进程的页面，同时这些页面是只读的。当进程向这些页面进行写入的时候，会开启保护错误。内核发现写入操作后，会为进程分配一个副本，使得写入时把数据复制到这个副本上，这个副本是共享的，这种方式称为 `写入时复制(copy on write)`，这种方式避免了在同一块内存区域维护两个副本的必要，节省内存空间。

在子进程开始运行后，操作系统会调用 exec 系统调用，内核会进行查找验证可执行文件，把参数和环境变量复制到内核，释放旧的地址空间。

现在新的地址空间需要被创建和填充。如果系统支持映射文件，就像 Unix 系统一样，那么新的页表就会创建，表明内存中没有任何页，除非所使用的页面是堆栈页，其地址空间由磁盘上的可执行文件支持。新进程开始运行时，立刻会收到一个`缺页异常(page fault)`，这会使具有代码的页面加载进入内存。最后，参数和环境变量被复制到新的堆栈中，重置信号，寄存器全部清零。新的命令开始运行。

下面是一个示例，用户输出 ls，shell 会调用 fork 函数复制一个新进程，shell 进程会调用 exec 函数用可执行文件 ls 的内容覆盖它的内存。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQy1WGaMLqg7H8TV6Jd6Lqx9FdGp1j0HbQTpq3GmwYicWriaprubULUZaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### Linux 线程

现在我们来讨论一下 Linux 中的线程，线程是轻量级的进程，想必这句话你已经听过很多次了，`轻量级`体现在所有的进程切换都需要清除所有的表、进程间的共享信息也比较麻烦，一般来说通过管道或者共享内存，如果是 fork 函数后的父子进程则使用共享文件，然而线程切换不需要像进程一样具有昂贵的开销，而且线程通信起来也更方便。线程分为两种：用户级线程和内核级线程

##### 用户级线程

用户级线程避免使用内核，通常，每个线程会显示调用开关，发送信号或者执行某种切换操作来放弃 CPU，同样，计时器可以强制进行开关，用户线程的切换速度通常比内核线程快很多。在用户级别实现线程会有一个问题，即单个线程可能会垄断 CPU 时间片，导致其他线程无法执行从而 `饿死`。如果执行一个 I/O 操作，那么 I/O 会阻塞，其他线程也无法运行。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQ7xWcmN5ckaVRG3C2cbxAHKg0RPlU59TVia9PUatgmPB3OGk06QqvZgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

一种解决方案是，一些用户级的线程包解决了这个问题。可以使用时钟周期的监视器来控制第一时间时间片独占。然后，一些库通过特殊的包装来解决系统调用的 I/O 阻塞问题，或者可以为非阻塞 I/O 编写任务。

##### 内核级线程

内核级线程通常使用几个进程表在内核中实现，每个任务都会对应一个进程表。在这种情况下，内核会在每个进程的时间片内调度每个线程。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQFlf11vC57houOssnBYDFHDJm0qRMdyG2Wu0BP6dKle92jWicJ0DTnLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。

从用户空间 -> 内核空间 -> 用户空间的开销比较大，但是线程初始化的时间损耗可以忽略不计。这种实现的好处是由时钟决定线程切换时间，因此不太可能将时间片与任务中的其他线程占用时间绑定到一起。同样，I/O 阻塞也不是问题。

##### 混合实现

结合用户空间和内核空间的优点，设计人员采用了一种`内核级线程`的方式，然后将用户级线程与某些或者全部内核线程多路复用起来

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQibAKmae0rHnNZibGIR27jWIHSkQmzjd5OH6S2CMX6l6G0WNVHfjbf9Bw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。

### 2.5.5 Linux 调度

下面我们来关注一下 Linux 系统的调度算法，首先需要认识到，Linux 系统的线程是内核线程，所以 Linux 系统是基于线程的，而不是基于进程的。

为了进行调度，Linux 系统将线程分为三类

- 实时先入先出
- 实时轮询
- 分时

实时先入先出线程具有最高优先级，它不会被其他线程所抢占，除非那是一个刚刚准备好的，拥有更高优先级的线程进入。实时轮转线程与实时先入先出线程基本相同，只是每个实时轮转线程都有一个时间量，时间到了之后就可以被抢占。如果多个实时线程准备完毕，那么每个线程运行它时间量所规定的时间，然后插入到实时轮转线程末尾。

> ❝
>
> 注意这个实时只是相对的，无法做到绝对的实时，因为线程的运行时间无法确定。它们相对分时系统来说，更加具有实时性
>
> ❞

Linux 系统会给每个线程分配一个 `nice` 值，这个值代表了优先级的概念。nice 值默认值是 0 ，但是可以通过系统调用 nice 值来修改。修改值的范围从 -20 - +19。nice 值决定了线程的静态优先级。一般系统管理员的 nice 值会比一般线程的优先级高，它的范围是 -20 - -1。

下面我们更详细的讨论一下 Linux 系统的两个调度算法，它们的内部与`调度队列(runqueue)` 的设计很相似。运行队列有一个数据结构用来监视系统中所有可运行的任务并选择下一个可以运行的任务。每个运行队列和系统中的每个 CPU 有关。

`Linux O(1)` 调度器是历史上很流行的一个调度器。这个名字的由来是因为它能够在常数时间内执行任务调度。在 O(1) 调度器里，调度队列被组织成两个数组，一个是任务**「正在活动」**的数组，一个是任务**「过期失效」**的数组。如下图所示，每个数组都包含了 140 个链表头，每个链表头具有不同的优先级。

<img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQKFHGLD5YOFKPSxF4vrFCmHsMnlIRb31709cJeL9rTJN5IBffkh8aLg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" style="zoom:50%;" />

大致流程如下：

调度器从正在活动数组中选择一个优先级最高的任务。如果这个任务的时间片过期失效了，就把它移动到过期失效数组中。如果这个任务阻塞了，比如说正在等待 I/O 事件，那么在它的时间片过期失效之前，一旦 I/O 操作完成，那么这个任务将会继续运行，它将被放回到之前正在活动的数组中，因为这个任务之前已经消耗一部分 CPU 时间片，所以它将运行剩下的时间片。当这个任务运行完它的时间片后，它就会被放到过期失效数组中。一旦正在活动的任务数组中没有其他任务后，调度器将会交换指针，使得正在活动的数组变为过期失效数组，过期失效数组变为正在活动的数组。使用这种方式可以保证每个优先级的任务都能够得到执行，不会导致线程饥饿。

在这种调度方式中，不同优先级的任务所得到 CPU 分配的时间片也是不同的，高优先级进程往往能得到较长的时间片，低优先级的任务得到较少的时间片。

这种方式为了保证能够更好的提供服务，通常会为 `交互式进程` 赋予较高的优先级，交互式进程就是`用户进程`。

Linux 系统不知道一个任务究竟是 I/O 密集型的还是 CPU 密集型的，它只是依赖于交互式的方式，Linux 系统会区分是`静态优先级` 还是 `动态优先级`。动态优先级是采用一种奖励机制来实现的。奖励机制有两种方式：**「奖励交互式线程、惩罚占用 CPU 的线程」**。在 Linux O(1) 调度器中，最高的优先级奖励是 -5，注意这个优先级越低越容易被线程调度器接受，所以最高惩罚的优先级是 +5。具体体现就是操作系统维护一个名为 `sleep_avg` 的变量，任务唤醒会增加 sleep_avg 变量的值，当任务被抢占或者时间量过期会减少这个变量的值，反映在奖励机制上。

> ❝
>
> O(1) 调度算法是 2.6 内核版本的调度器，最初引入这个调度算法的是不稳定的 2.5 版本。早期的调度算法在多处理器环境中说明了通过访问正在活动数组就可以做出调度的决定。使调度可以在固定的时间 O(1) 完成。
>
> ❞

O(1) 调度器使用了一种 `启发式` 的方式，这是什么意思？

> ❝
>
> 在计算机科学中，启发式是一种当传统方式解决问题很慢时用来快速解决问题的方式，或者找到一个在传统方法无法找到任何精确解的情况下找到近似解。
>
> ❞

O(1) 使用启发式的这种方式，会使任务的优先级变得复杂并且不完善，从而导致在处理交互任务时性能很糟糕。

为了改进这个缺点，O(1) 调度器的开发者又提出了一个新的方案，即 `公平调度器(Completely Fair Scheduler, CFS)`。CFS 的主要思想是使用一颗`红黑树`作为调度队列。

> ❝
>
> 数据结构太重要了。
>
> ❞

CFS 会根据任务在 CPU 上的运行时间长短而将其有序地排列在树中，时间精确到纳秒级。下面是 CFS 的构造模型

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQy2zU3onRpOs31WFJF9XnNdqek1LFRBMytu7MbXeoia6tdne8BUvEISg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

CFS 的调度过程如下：

CFS 算法总是优先调度哪些使用 CPU 时间最少的任务。最小的任务一般都是在最左边的位置。当有一个新的任务需要运行时，CFS 会把这个任务和最左边的数值进行对比，如果此任务具有最小时间值，那么它将进行运行，否则它会进行比较，找到合适的位置进行插入。然后 CPU 运行红黑树上当前比较的最左边的任务。

在红黑树中选择一个节点来运行的时间可以是常数时间，但是插入一个任务的时间是 `O(loog(N))`，其中 N 是系统中的任务数。考虑到当前系统的负载水平，这是可以接受的。

调度器只需要考虑可运行的任务即可。这些任务被放在适当的调度队列中。不可运行的任务和正在等待的各种 I/O 操作或内核事件的任务被放入一个`等待队列`中。等待队列头包含一个指向任务链表的指针和一个自旋锁。自旋锁对于并发处理场景下用处很大。

## 2.6 Linux 启动

当计算机电源通电后，`BIOS`会进行`开机自检(Power-On-Self-Test, POST)`，对硬件进行检测和初始化。因为操作系统的启动会使用到磁盘、屏幕、键盘、鼠标等设备。下一步，磁盘中的第一个分区，也被称为 `MBR(Master Boot Record)` 主引导记录，被读入到一个固定的内存区域并执行。这个分区中有一个非常小的，只有 512 字节的程序。程序从磁盘中调入 boot 独立程序，boot 程序将自身复制到高位地址的内存从而为操作系统释放低位地址的内存。

复制完成后，boot 程序读取启动设备的根目录。boot 程序要理解文件系统和目录格式。然后 boot 程序被调入内核，把控制权移交给内核。直到这里，boot 完成了它的工作。系统内核开始运行。

内核启动代码是使用`汇编语言`完成的，主要包括创建内核堆栈、识别 CPU 类型、计算内存、禁用中断、启动内存管理单元等，然后调用 C 语言的 main 函数执行操作系统部分。

这部分也会做很多事情，首先会分配一个消息缓冲区来存放调试出现的问题，调试信息会写入缓冲区。如果调试出现错误，这些信息可以通过诊断程序调出来。

然后操作系统会进行自动配置，检测设备，加载配置文件，被检测设备如果做出响应，就会被添加到已链接的设备表中，如果没有相应，就归为未连接直接忽略。

配置完所有硬件后，接下来要做的就是仔细手工处理进程0，设置其堆栈，然后运行它，执行初始化、配置时钟、挂载文件系统。创建 `init 进程(进程 1 )` 和 `守护进程(进程 2)`。

init 进程会检测它的标志以确定它是否为单用户还是多用户服务。在前一种情况中，它会调用 fork 函数创建一个 shell 进程，并且等待这个进程结束。后一种情况调用 fork 函数创建一个运行系统初始化的 shell 脚本（即 /etc/rc）的进程，这个进程可以进行文件系统一致性检测、挂载文件系统、开启守护进程等。

然后 /etc/rc 这个进程会从 /etc/ttys 中读取数据，/etc/ttys 列出了所有的终端和属性。对于每一个启用的终端，这个进程调用 fork 函数创建一个自身的副本，进行内部处理并运行一个名为 `getty` 的程序。

getty 程序会在终端上输入

```shell
login:
```

等待用户输入用户名，在输入用户名后，getty 程序结束，登陆程序 `/bin/login` 开始运行。login 程序需要输入密码，并与保存在 `/etc/passwd` 中的密码进行对比，如果输入正确，login 程序以用户 shell 程序替换自身，等待第一个命令。如果不正确，login 程序要求输入另一个用户名。

整个系统启动过程如下

<img src="C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\启动过程.png" style="zoom:50%;" />

## 2.7 Linux 内存管理

### 2.7.1 基本概念

每个 Linux 进程都会有地址空间，这些地址空间由三个段区域组成：**「text 段、data 段、stack 段」**。下面是进程地址空间的示例。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQGIsOaYrW0qBfsbKmpvRC9krgybwGxAiaSOJcxX4icBQdwnrDU1B2heMQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

`数据段(data segment)` 包含了程序的变量、字符串、数组和其他数据的存储。数据段分为两部分，已经初始化的数据和尚未初始化的数据。其中`尚未初始化的数据`就是我们说的 BSS。数据段部分的初始化需要编译就期确定的常量以及程序启动就需要一个初始值的变量。所有 BSS 部分中的变量在加载后被初始化为 0 。

和 `代码段(Text segment)` 不一样，data segment 数据段可以改变。程序总是修改它的变量。而且，许多程序需要在执行时动态分配空间。Linux 允许数据段随着内存的分配和回收从而增大或者减小。为了分配内存，程序可以增加数据段的大小。在 C 语言中有一套标准库 `malloc` 经常用于分配内存。进程地址空间描述符包含动态分配的内存区域称为 `堆(heap)`。

第三部分段是 `栈段(stack segment)`。在大部分机器上，栈段会在虚拟内存地址顶部地址位置处，并向低位置处（向地址空间为 0 处）拓展。举个例子来说，在 32 位 x86 架构的机器上，栈开始于 `0xC0000000`，这是用户模式下进程允许可见的 3GB 虚拟地址限制。如果栈一直增大到超过栈段后，就会发生硬件故障并把页面下降一个页面。

当程序启动时，栈区域并不是空的，相反，它会包含所有的 shell 环境变量以及为了调用它而向 shell 输入的命令行。举个例子，当你输入

```
cp cxuan lx
```

时，cp 程序会运行并在栈中带着字符串 `cp cxuan lx` ，这样就能够找出源文件和目标文件的名称。

当两个用户运行在相同程序中，例如`编辑器(editor)`，那么就会在内存中保持编辑器程序代码的两个副本，但是这种方式并不高效。Linux 系统支持`共享文本段作`为替代。下面图中我们会看到 A 和 B 两个进程，它们有着相同的文本区域。

<img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQiaDc002s7h67ZPaynMwwVwnR5YDQ2xcBnrwUPETMJZtf4DlCem4oHibw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" style="zoom:50%;" />

数据段和栈段只有在 fork 之后才会共享，共享也是共享未修改过的页面。如果任何一个都需要变大但是没有相邻空间容纳的话，也不会有问题，因为相邻的虚拟页面不必映射到相邻的物理页面上。

除了动态分配更多的内存，Linux 中的进程可以通过`内存映射文件`来访问文件数据。这个特性可以使我们把一个文件映射到进程空间的一部分而该文件就可以像位于内存中的字节数组一样被读写。把一个文件映射进来使得随机读写比使用 read 和 write 之类的 I/O 系统调用要容易得多。共享库的访问就是使用了这种机制。如下所示

<img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQCicSciaEFlvMc9H4bHPHhu72diavPfmKCCQwbCiaqrV3OQiaNsBVvFU58fQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" style="zoom:50%;" />

我们可以看到两个相同文件会被映射到相同的物理地址上，但是它们属于不同的地址空间。

映射文件的优点是，两个或多个进程可以同时映射到同一文件中，任意一个进程对文件的写操作对其他文件可见。通过使用映射临时文件的方式，可以为多线程共享内存`提供高带宽`，临时文件在进程退出后消失。但是实际上，并没有两个相同的地址空间，因为每个进程维护的打开文件和信号不同。

### 2.7.2 Linux 内存管理系统调用

下面我们探讨一下关于内存管理的系统调用方式。事实上，POSIX 并没有给内存管理指定任何的系统调用。然而，Linux 却有自己的内存系统调用，主要系统调用如下

| 系统调用                                | 描述           |
| :-------------------------------------- | :------------- |
| s = brk(addr)                           | 改变数据段大小 |
| a = mmap(addr,len,prot,flags,fd,offset) | 进行映射       |
| s = unmap(addr,len)                     | 取消映射       |

如果遇到错误，那么 s 的返回值是 -1，a 和 addr 是内存地址，len 表示的是长度，prot 表示的是控制保护位，flags 是其他标志位，fd 是文件描述符，offset 是文件偏移量。

`brk` 通过给出超过数据段之外的第一个字节地址来指定数据段的大小。如果新的值要比原来的大，那么数据区会变得越来越大，反之会越来越小。

`mmap` 和 `unmap` 系统调用会控制映射文件。mmp 的第一个参数 addr 决定了文件映射的地址。它必须是页面大小的倍数。如果参数是 0，系统会分配地址并返回 a。第二个参数是长度，它告诉了需要映射多少字节。它也是页面大小的倍数。prot 决定了映射文件的保护位，保护位可以标记为 **「可读、可写、可执行或者这些的结合」**。第四个参数 flags 能够控制文件是私有的还是可读的以及 addr 是必须的还是只是进行提示。第五个参数 fd 是要映射的文件描述符。只有打开的文件是可以被映射的，因此如果想要进行文件映射，必须打开文件；最后一个参数 offset 会指示文件从什么时候开始，并不一定每次都要从零开始。

### 2.7.3 Linux 内存管理实现

内存管理系统是操作系统最重要的部分之一。从计算机早期开始，我们实际使用的内存都要比系统中实际存在的内存多。`内存分配策略`克服了这一限制，并且其中最有名的就是 `虚拟内存(virtual memory)`。通过在多个竞争的进程之间共享虚拟内存，虚拟内存得以让系统有更多的内存。虚拟内存子系统主要包括下面这些概念。

**「大地址空间」**

操作系统使系统使用起来好像比实际的物理内存要大很多，那是因为虚拟内存要比物理内存大很多倍。

**「保护」**

系统中的每个进程都会有自己的虚拟地址空间。这些虚拟地址空间彼此完全分开，因此运行一个应用程序的进程不会影响另一个。并且，硬件虚拟内存机制允许内存保护关键内存区域。

**「内存映射」**

内存映射用来向进程地址空间映射图像和数据文件。在内存映射中，文件的内容直接映射到进程的虚拟空间中。

**「公平的物理内存分配」**

内存管理子系统允许系统中的每个正在运行的进程公平分配系统的物理内存。

**「共享虚拟内存」**

尽管虚拟内存让进程有自己的内存空间，但是有的时候你是需要共享内存的。例如几个进程同时在 shell 中运行，这会涉及到 IPC 的进程间通信问题，这个时候你需要的是共享内存来进行信息传递而不是通过拷贝每个进程的副本独立运行。

下面我们就正式探讨一下什么是 `虚拟内存`

#### 虚拟内存的抽象模型

在考虑 Linux 用于支持虚拟内存的方法之前，考虑一个不会被太多细节困扰的抽象模型是很有用的。

处理器在执行指令时，会从内存中读取指令并将其`解码(decode)`，在指令解码时会获取某个位置的内容并将他存到内存中。然后处理器继续执行下一条指令。这样，处理器总是在访问存储器以获取指令和存储数据。

在虚拟内存系统中，所有的地址空间都是虚拟的而不是物理的。但是实际存储和提取指令的是物理地址，所以需要让处理器根据操作系统维护的一张表将虚拟地址转换为物理地址。

为了简单的完成转换，虚拟地址和物理地址会被分为固定大小的块，称为 `页(page)`。这些页有相同大小，如果页面大小不一样的话，那么操作系统将很难管理。Alpha AXP系统上的 Linux 使用 8 KB 页面，而 Intel x86 系统上的 Linux 使用 4 KB 页面。每个页面都有一个唯一的编号，即`页面框架号（PFN）`。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQZmuBGqTDD9iaYonIwn8JmQCP6uyV8HWzkAMhNlibYsgGGk7QEicF9Tia9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

上面就是 Linux 内存映射模型了，在这个页模型中，虚拟地址由两部分组成：**「偏移量和虚拟页框号」**。每次处理器遇到虚拟地址时都会提取偏移量和虚拟页框号。处理器必须将虚拟页框号转换为物理页号，然后以正确的偏移量的位置访问物理页。

上图中展示了两个进程 A 和 B 的虚拟地址空间，每个进程都有自己的页表。这些页表将进程中的虚拟页映射到内存中的物理页中。页表中每一项均包含

- `有效标志(valid flag)`：表明此页表条目是否有效
- 该条目描述的物理页框号
- 访问控制信息，页面使用方式，是否可写以及是否可以执行代码

要将处理器的虚拟地址映射为内存的物理地址，首先需要计算虚拟地址的页框号和偏移量。页面大小为 2 的次幂，可以通过移位完成操作。

如果当前进程尝试访问虚拟地址，但是访问不到的话，这种情况称为 `缺页异常`，此时虚拟操作系统的错误地址和页面错误的原因将通知操作系统。

通过以这种方式将虚拟地址映射到物理地址，虚拟内存可以以任何顺序映射到系统的物理页面。

#### 按需分页

由于物理内存要比虚拟内存少很多，因此操作系统需要注意尽量避免直接使用`低效`的物理内存。节省物理内存的一种方式是仅加载执行程序当前使用的页面（这何尝不是一种懒加载的思想呢？）。例如，可以运行数据库来查询数据库，在这种情况下，不是所有的数据都装入内存，只装载需要检查的数据。这种仅仅在需要时才将虚拟页面加载进内中的技术称为按需分页。

#### 交换

如果某个进程需要将虚拟页面传入内存，但是此时没有可用的物理页面，那么操作系统必须丢弃物理内存中的另一个页面来为该页面腾出空间。

如果页面已经修改过，那么操作系统必须保留该页面的内容，以便以后可以访问它。这种类型的页面被称为脏页，当将其从内存中移除时，它会保存在称为`交换文件`的特殊文件中。相对于处理器和物理内存的速度，对交换文件的访问非常慢，并且操作系统需要兼顾将页面写到磁盘的以及将它们保留在内存中以便再次使用。

Linux 使用`最近最少使用(LRU)`页面老化技术来公平的选择可能会从系统中删除的页面，这个方案涉及系统中的每个页面，页面的年龄随着访问次数的变化而变化，如果某个页面访问次数多，那么该页就表示越 `年轻`，如果某个呃页面访问次数太少，那么该页越容易被`换出`。

#### 物理和虚拟寻址模式

大多数多功能处理器都支持 `物理地址`模式和`虚拟地址`模式的概念。物理寻址模式不需要页表，并且处理器不会在此模式下尝试执行任何地址转换。Linux 内核被链接在物理地址空间中运行。

Alpha AXP 处理器没有物理寻址模式。相反，它将内存空间划分为几个区域，并将其中两个指定为物理映射的地址。此内核地址空间称为 KSEG 地址空间，它包含从 0xfffffc0000000000 向上的所有地址。为了从 KSEG 中链接的代码（按照定义，内核代码）执行或访问其中的数据，该代码必须在内核模式下执行。链接到 Alpha 上的 Linux内核以从地址 0xfffffc0000310000 执行。

#### 访问控制

页面表的每一项还包含访问控制信息，访问控制信息主要检查进程是否应该访问内存。

必要时需要对内存进行`访问限制`。例如包含可执行代码的内存，自然是只读内存；操作系统不应允许进程通过其可执行代码写入数据。相比之下，包含数据的页面可以被写入，但是尝试执行该内存的指令将失败。大多数处理器至少具有两种执行模式：内核态和用户态。你不希望访问用户执行内核代码或内核数据结构，除非处理器以内核模式运行。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQtjKNcrH7FvLZHLjMXPQayp50UFWgxH0tHtkvriauDWYd7nES9rb4z9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

访问控制信息被保存在上面的 Page Table Entry ，页表项中，上面这幅图是 Alpha AXP的 PTE。位字段具有以下含义

- V

表示 valid ，是否有效位

- FOR

读取时故障，在尝试读取此页面时出现故障

- FOW

写入时错误，在尝试写入时发生错误

- FOE

执行时发生错误，在尝试执行此页面中的指令时，处理器都会报告页面错误并将控制权传递给操作系统，

- ASM

地址空间匹配，当操作系统希望清除转换缓冲区中的某些条目时，将使用此选项。

- GH

当在使用`单个转换缓冲区`条目而不是`多个转换缓冲区`条目映射整个块时使用的提示。

- KRE

内核模式运行下的代码可以读取页面

- URE

用户模式下的代码可以读取页面

- KWE

以内核模式运行的代码可以写入页面

- UWE

以用户模式运行的代码可以写入页面

- 页框号

对于设置了 V 位的 PTE，此字段包含此 PTE 的物理页面帧号（页面帧号）。对于无效的 PTE，如果此字段不为零，则包含有关页面在交换文件中的位置的信息。

除此之外，Linux 还使用了两个位

- _PAGE_DIRTY

如果已设置，则需要将页面写出到交换文件中

- _PAGE_ACCESSED

Linux 用来将页面标记为已访问。

## 2.8 缓存

上面的虚拟内存抽象模型可以用来实施，但是效率不会太高。操作系统和处理器设计人员都尝试提高性能。但是除了提高处理器，内存等的速度之外，最好的方法就是维护有用信息和数据的高速缓存，从而使某些操作更快。在 Linux 中，使用很多和内存管理有关的缓冲区，使用缓冲区来提高效率。

### 2.8.1 缓冲区缓存

缓冲区高速缓存包含`块设备`驱动程序使用的数据缓冲区。

还记得什么是块设备么？这里回顾下

块设备是一个能存储`固定大小块`信息的设备，它支持**「以固定大小的块，扇区或群集读取和（可选）写入数据」**。每个块都有自己的`物理地址`。通常块的大小在 512 - 65536 之间。所有传输的信息都会以`连续`的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 **「硬盘、蓝光光盘、USB 盘」**

与字符设备相比，块设备通常需要较少的引脚。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQfPTic1x1ic97je4CMia9wobOwfKtrwYgricwiaEITUoHEPib40jZmKpQqWKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

缓冲区高速缓存通过`设备标识符`和块编号用于快速查找数据块。如果可以在缓冲区高速缓存中找到数据，则无需从物理块设备中读取数据，这种访问方式要快得多。

#### 页缓存

页缓存用于加快对磁盘上图像和数据的访问

它用于一次一页地缓存文件中的内容，并且可以通过文件和文件中的偏移量进行访问。当页面从磁盘读入内存时，它们被缓存在页面缓存中。

#### 交换区缓存

仅仅已修改（脏页）被保存在交换文件中

只要这些页面在写入交换文件后没有修改，则下次交换该页面时，无需将其写入交换文件，因为该页面已在交换文件中。可以直接丢弃。在大量交换的系统中，这节省了许多不必要的和昂贵的磁盘操作。

#### 硬件缓存

处理器中通常使用一种硬件缓存。页表条目的缓存。在这种情况下，处理器并不总是直接读取页表，而是根据需要缓存页的翻译。这些是`转换后备缓冲区` 也被称为 `TLB`，包含来自系统中一个或多个进程的页表项的缓存副本。

引用虚拟地址后，处理器将尝试查找匹配的 TLB 条目。如果找到，则可以将虚拟地址直接转换为物理地址，并对数据执行正确的操作。如果处理器找不到匹配的 TLB 条目， 它通过向操作系统发信号通知已发生 TLB 丢失获得操作系统的支持和帮助。系统特定的机制用于将该异常传递给可以修复问题的操作系统代码。操作系统为地址映射生成一个新的 TLB 条目。清除异常后，处理器将再次尝试转换虚拟地址。这次能够执行成功。

使用缓存也存在缺点，为了节省精力，Linux 必须使用更多的时间和空间来维护这些缓存，并且如果缓存损坏，系统将会崩溃。

### 2.8.2 Linux 页表

Linux 假定页表分为三个级别。访问的每个页表都包含下一级页表

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQIJKn4zf6zQZugRQV6hxsK8B8KfibsMpiaEbNvVv2DRWWGWxIFoTmwllw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

图中的 PDG 表示全局页表，当创建一个新的进程时，都要为新进程创建一个新的页面目录，即 PGD。

要将虚拟地址转换为物理地址，处理器必须获取每个级别字段的内容，将其转换为包含页表的物理页的偏移量，并读取下一级页表的页框号。这样重复三次，直到找到包含虚拟地址的物理页面的页框号为止。

Linux 运行的每个平台都必须提供翻译宏，这些宏允许内核遍历特定进程的页表。这样，内核无需知道页表条目的格式或它们的排列方式。

### 2.8.3 页分配和取消分配

对系统中物理页面有很多需求。例如，当图像加载到内存中时，操作系统需要分配页面。

系统中所有物理页面均由 `mem_map` 数据结构描述，这个数据结构是 `mem_map_t` 的列表。它包括一些重要的属性

- count ：这是页面的用户数计数，当页面在多个进程之间共享时，计数大于 1
- age：这是描述页面的年龄，用于确定页面是否适合丢弃或交换
- map_nr ：这是此mem_map_t描述的物理页框号。

页面分配代码使用 `free_area`向量查找和释放页面，free_area 的每个元素都包含有关页面块的信息。

#### 页面分配

Linux 的页面分配使用一种著名的伙伴算法来进行页面的分配和取消分配。页面以 2 的幂为单位进行块分配。这就意味着它可以分配 1页、2 页、4页等等，只要系统中有足够可用的页面来满足需求就可以。判断的标准是**「nr_free_pages> min_free_pages」**，如果满足，就会在 free_area 中搜索所需大小的页面块完成分配。free_area 的每个元素都有该大小的块的已分配页面和空闲页面块的映射。

分配算法会搜索请求大小的页面块。如果没有任何请求大小的页面块可用的话，会搜寻一个是请求大小二倍的页面块，然后重复，直到一直搜寻完 free_area 找到一个页面块为止。如果找到的页面块要比请求的页面块大，就会对找到的页面块进行细分，直到找到合适的大小块为止。

因为每个块都是 2 的次幂，所以拆分过程很容易，因为你只需将块分成两半即可。空闲块在适当的队列中排队，分配的页面块返回给调用者。

<img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQVSF9Iw1AZxY7rwjiaib1n8L4l4TX7BBcptsbONjHrSneNY3mfLsYKH2Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" style="zoom:50%;" />

如果请求一个 2 个页的块，则 4 页的第一个块（从第 4 页的框架开始）将被分成两个 2 页的块。第一个页面（从第 4 页的帧开始）将作为分配的页面返回给调用方，第二个块（从第 6 页的页面开始）将作为 2 页的空闲块排队到 free_area 数组的元素 1 上。

#### 页面取消分配

上面的这种内存方式最造成一种后果，那就是内存的碎片化，会将较大的空闲页面分成较小的页面。页面解除分配代码会尽可能将页面重新组合成为更大的空闲块。每释放一个页面，都会检查相同大小的相邻的块，以查看是否空闲。如果是，则将其与新释放的页面块组合以形成下一个页面大小块的新的自由页面块。每次将两个页面块重新组合为更大的空闲页面块时，页面释放代码就会尝试将该页面块重新组合为更大的空闲页面。通过这种方式，可用页面的块将尽可能多地使用内存。

例如上图，如果要释放第 1 页的页面，则将其与已经空闲的第 0 页页面框架组合在一起，并作为大小为 2页的空闲块排队到 free_area 的元素 1 中

### 2.8.4 内存映射

内核有两种类型的内存映射：`共享型(shared)` 和`私有型(private)`。私有型是当进程为了只读文件，而不写文件时使用，这时，私有映射更加高效。但是，任何对私有映射页的写操作都会导致内核停止映射该文件中的页。所以，写操作既不会改变磁盘上的文件，对访问该文件的其它进程也是不可见的。

### 2.8.5 按需分页

一旦可执行映像被内存映射到虚拟内存后，它就可以被执行了。因为只将映像的开头部分物理的拉入到内存中，因此它将很快访问物理内存尚未存在的虚拟内存区域。当进程访问没有有效页表的虚拟地址时，操作系统会报告这项错误。

页面错误描述页面出错的虚拟地址和引起的内存访问（RAM）类型。

Linux 必须找到代表发生页面错误的内存区域的 vm_area_struct 结构。由于搜索 vm_area_struct 数据结构对于有效处理页面错误至关重要，因此它们以 `AVL（Adelson-Velskii和Landis）`树结构链接在一起。如果引起故障的虚拟地址没有 `vm_area_struct` 结构，则此进程已经访问了非法地址，Linux 会向进程发出 `SIGSEGV` 信号，如果进程没有用于该信号的处理程序，那么进程将会终止。

然后，Linux 会针对此虚拟内存区域所允许的访问类型，检查发生的页面错误类型。如果该进程以非法方式访问内存，例如写入仅允许读的区域，则还会发出内存访问错误信号。

现在，Linux 已确定页面错误是合法的，因此必须对其进行处理。

## **2.9文件系统**

见下面文件系统

## 2.10 I/O

见I/O总结

# 3. 文件系统

## 3.1 系统目录结构

登录系统后，在当前命令窗口下输入命令：

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\4_20.png)

树状目录结构：

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\d0c50-linux2bfile2bsystem2bhierarchy.jpg)

## 3.2 各目录的功能

以下是对这些目录的解释：

- **/bin**：
  bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。

- **/boot：**
  这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。

- **/dev ：**
  dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。

- **/etc：**
  etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。

- **/home**：
  用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。

- **/lib**：
  lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。

- **/lost+found**：
  这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。

- **/media**：
  linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。

- **/mnt**：
  系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。

- **/opt**：
  opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。

- **/proc**：
  proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。
  这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：

  ```
  echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all
  ```

- **/root**：
  该目录为系统管理员，也称作超级权限者的用户主目录。

- **/sbin**：
  s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。

- **/selinux**：
   这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。

- **/srv**：
   该目录存放一些服务启动之后需要提取的数据。

- **/sys**：

  这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。

  sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。

  该文件系统是内核设备树的一个直观反映。

  当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。

- **/tmp**：
  tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。

- **/usr**：
   usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。

- **/usr/bin：**
  系统用户使用的应用程序。

- **/usr/sbin：**
  超级用户使用的比较高级的管理程序和系统守护程序。

- **/usr/src：**
  内核源代码默认的放置目录。

- **/var**：
  var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。

- **/run**：
  是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。

在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。

**/etc**： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。

**/bin, /sbin, /usr/bin, /usr/sbin**: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。

值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令。

**/var**： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。

我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。

其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。

## 3.3 文件的基本属性

Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。

为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。

### 3.3.1 修改文件或目录的所属用户与权限

- chown (change ownerp) ： 修改所属用户与组。
- chmod (change mode) ： 修改用户的权限。

### 3.3.2 显示一个文件的属性以及文件所属的用户和组

```
[root@www /]# ls -l
total 64
dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin
dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot
……
```

### 3.3.3 参数作用

实例中，**bin** 文件的第一个属性用 **d** 表示。**d** 在 Linux 中代表该文件是一个目录文件。

在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。

- 当为 **d** 则是目录
- 当为 **-** 则是文件；
- 若是 **l** 则表示为链接文档(link file)；
- 若是 **b** 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
- 若是 **c** 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。

接下来的字符中，以三个为一组，且均为 **rwx** 的三个参数的组合。其中， **r** 代表可读(read)、 **w** 代表可写(write)、 **x** 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 **-** 而已。

![img](https://www.runoob.com/wp-content/uploads/2014/06/file-llls22.jpg)

每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。

![363003_1227493859FdXT](https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png)

从左至右用 **0-9** 这些数字来表示。

第 **0** 位确定文件类型，第 **1-3** 位确定属主（该文件的所有者）拥有该文件的权限。

第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。



其中，第 **1、4、7** 位表示读权限，如果用 **r** 字符表示，则有读权限，如果用 **-** 字符表示，则没有读权限；

第 **2、5、8** 位表示写权限，如果用 **w** 字符表示，则有写权限，如果用 **-** 字符表示没有写权限；第 **3、6、9** 位表示可执行权限，如果用 **x** 字符表示，则有执行权限，如果用 **-** 字符表示，则没有执行权限。

## 3.4 更改文件属性

### 3.4.1 chgrp：更改文件属组

语法：

```
chgrp [-R] 属组名 文件名
```

参数选项

- -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。

### 3.4.2 chown：更改文件属主，也可以同时更改文件属组

语法：

```
chown [–R] 属主名 文件名
chown [-R] 属主名：属组名 文件名
```

进入 /root 目录（~）将install.log的拥有者改为bin这个账号：

```
[root@www ~] cd ~
[root@www ~]# chown bin install.log
[root@www ~]# ls -l
-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log
```

将install.log的拥有者与群组改回为root：

```
[root@www ~]# chown root:root install.log
[root@www ~]# ls -l
-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log
```

### 3.4.3 chmod：更改文件9个属性

Linux文件属性有两种设置方法，一种是数字，一种是符号。

Linux 文件的基本权限就有九个，分别是 **owner/group/others(拥有者/组/其他)** 三种身份各有自己的 **read/write/execute** 权限。

先复习一下刚刚上面提到的数据：文件的权限字符为： **-rwxrwxrwx** ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：

- r:4
- w:2
- x:1

每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： **-rwxrwx---** 分数则是：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others= --- = 0+0+0 = 0

所以等一下我们设定权限的变更时，该文件的权限数字就是 **770**。变更权限的指令 chmod 的语法是这样的：

```
 chmod [-R] xyz 文件或目录
```

选项与参数：

- xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。
- -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更

举例来说，如果要将 .bashrc 这个文件所有的权限都设定启用，那么命令如下：

```
[root@www ~]# ls -al .bashrc
-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc
[root@www ~]# chmod 777 .bashrc
[root@www ~]# ls -al .bashrc
-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc
```

那如果要将权限变成 *-rwxr-xr--* 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。

### 3.4.4 符号类型改变文件权限

还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：

- user：用户
- group：组
- others：其他

那么我们就可以使用 **u, g, o** 来代表三种身份的权限。

此外， **a** 则代表 **all**，即全部的身份。读写的权限可以写成 **r, w, x**，也就是可以使用下表的方式来看：



| chmod | u <br />g <br />o <br />a | +(加入) <br />-(除去) <br />=(设定) | r w x | 文件或目录 |
| ----- | ------------------------- | ----------------------------------- | ----- | ---------- |
|       |                           |                                     |       |            |

如果我们需要将文件权限设置为 **-rwxr-xr--** ，可以使用 **chmod u=rwx,g=rx,o=r 文件名** 来设定:

```
#  touch test1    // 创建 test1 文件
# ls -al test1    // 查看 test1 默认权限
-rw-r--r-- 1 root root 0 Nov 15 10:32 test1
# chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限
# ls -al test1
-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1
```

而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：

```shell
#  chmod  a-x test1
# ls -al test1
-rw-r--r-- 1 root root 0 Nov 15 10:32 test1
```

## 3.5 文件的目录管理

### 3.5.1 绝对路径和相对路径

- **绝对路径：**
  路径的写法，由根目录 **/** 写起，例如： /usr/share/doc 这个目录。
- **相对路径：**
  路径的写法，不是由 **/** 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： **cd ../man** 这就是相对路径的写法。

### 3.5.2 处理目录的常用命令

- ls（英文全拼：list files）: 列出目录及文件名
- cd（英文全拼：change directory）：切换目录
- pwd（英文全拼：print work directory）：显示目前的目录
- mkdir（英文全拼：make directory）：创建一个新的目录
- rmdir（英文全拼：remove directory）：删除一个空的目录
- cp（英文全拼：copy file）: 复制文件或目录
- rm（英文全拼：remove）: 移除文件或目录
- mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称

你可以使用 *man [命令]* 来查看各个命令的使用文档，如 ：man cp。

#### ls (列出目录)

语法：

```shell
[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称
[root@www ~]# ls [--color={never,auto,always}] 目录名称
[root@www ~]# ls [--full-time] 目录名称
```

选项与参数：

- -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)
- -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)
- -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)

#### cd (切换目录)

语法：

```shell
 cd [相对路径或绝对路径]
```

#### pwd (显示目前所在的目录)

```
[root@www ~]# pwd [-P]
```

选项与参数：

- **-P** ：显示出确实的路径，而非使用连结 (link) 路径。

```shell
[root@www ~]# cd /var/mail   <==注意，/var/mail是一个连结档
[root@www mail]# pwd
/var/mail         <==列出目前的工作目录
[root@www mail]# pwd -P
/var/spool/mail   <==怎么回事？有没有加 -P 差很多～
[root@www mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -> spool/mail
# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail 
# 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！
```

#### mkdir (创建新目录)

语法：

```
mkdir [-mp] 目录名称
```

选项与参数：

- -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～
- -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！

实例：请到/tmp底下尝试创建数个新目录看看：

```
[root@www ~]# cd /tmp
[root@www tmp]# mkdir test    <==创建一名为 test 的新目录
[root@www tmp]# mkdir test1/test2/test3/test4
mkdir: cannot create directory `test1/test2/test3/test4': 
No such file or directory       <== 没办法直接创建此目录啊！
[root@www tmp]# mkdir -p test1/test2/test3/test4
```

加了这个 -p 的选项，可以自行帮你创建多层目录！

实例：创建权限为 **rwx--x--x** 的目录。

```
[root@www tmp]# mkdir -m 711 test2
[root@www tmp]# ls -l
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
```

上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。

如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx--x--x 的权限。

#### rmdir (删除空的目录)

语法：

```
 rmdir [-p] 目录名称
```

选项与参数：

- **-p ：**连同上一级『空的』目录也一起删除

删除 runoob 目录

```
[root@www tmp]# rmdir runoob/
```

#### cp (复制文件或目录)

cp 即拷贝文件和目录。

语法:

```
[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)
[root@www ~]# cp [options] source1 source2 source3 .... directory
```

选项与参数：

- **-a：**相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)
- **-d：**若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；
- **-f：**为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；
- **-i：**若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)
- **-l：**进行硬式连结(hard link)的连结档创建，而非复制文件本身；
- **-p：**连同文件的属性一起复制过去，而非使用默认属性(备份常用)；
- **-r：**递归持续复制，用於目录的复制行为；(常用)
- **-s：**复制成为符号连结档 (symbolic link)，亦即『捷径』文件；
- **-u：**若 destination 比 source 旧才升级 destination ！

用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc

```
[root@www ~]# cp ~/.bashrc /tmp/bashrc
[root@www ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite `/tmp/bashrc'? n  <==n不覆盖，y为覆盖
```

#### rm (移除文件或目录)

语法：

```
 rm [-fir] 文件或目录
```

选项与参数：

- -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
- -i ：互动模式，在删除前会询问使用者是否动作
- -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！

将刚刚在 cp 的实例中创建的 bashrc 删除掉！

```
[root@www tmp]# rm -i bashrc
rm: remove regular file `bashrc'? y
```

如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！

#### mv (移动文件与目录，或修改名称)

语法：

```
[root@www ~]# mv [-fiu] source destination
[root@www ~]# mv [options] source1 source2 source3 .... directory
```

选项与参数：

- -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
- -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！
- -u ：若目标文件已经存在，且 source 比较新，才会升级 (update)

复制一文件，创建一目录，将文件移动到目录中

```
[root@www ~]# cd /tmp
[root@www tmp]# cp ~/.bashrc bashrc
[root@www tmp]# mkdir mvtest
[root@www tmp]# mv bashrc mvtest
```

将刚刚的目录名称更名为 mvtest2

```
[root@www tmp]# mv mvtest mvtest2
```

## 3.6 Linux 文件内容查看

Linux系统中使用以下命令来查看文件的内容：

- cat 由第一行开始显示文件内容
- tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
- nl  显示的时候，顺道输出行号！
- more 一页一页的显示文件内容
- less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行

## 3.7 创建一个空文件

### touch

```shell
[root@VM-4-15-centos ~]# touch tencent.txt
[root@VM-4-15-centos ~]# ll
total 8
drwxr-xr-x 11 root root 4096 Nov  2 21:03 Directory
-rw-r--r--  1 root root    5 Nov  7 22:08 felix
-rw-r--r--  1 root root    0 Nov 17 16:07 tencent.txt
```

### vim

## 3.8 重定向和追加

'>'输出重定向和'>>'追加

### 基本语法

```
ls -l>文件 #列表的内容写入文件a.txt中（覆盖写）
ls -al>>文件 # 列表的内容追加到文件aa.txt的末尾
cat 文件1>文件2 # 将文件1的内容覆盖到文件2
echo "内容">>文件
```

# 4. 用户管理

## 4.1 添加新的用户账号

```shell
useradd 选项 用户名
```

参数说明：

- 选项:
  - -c comment 指定一段注释性描述。
  - -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
  - -g 用户组 指定用户所属的用户组。
  - -G 用户组，用户组 指定用户所属的附加组。
  - -s Shell文件 指定用户的登录Shell。
  - -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

#### 实例1

```
# useradd –d  /home/sam -m sam
```

此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。

#### 实例2

```
# useradd -s /bin/sh -g group –G adm,root gem
```

此命令新建了一个用户gem，该用户的登录Shell是 `/bin/sh`，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。

这里可能新建组：`#groupadd group及groupadd adm`

增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。

Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。

## 4.2 删除帐号

如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。

删除一个已有的用户账号使用`userdel`命令，其格式如下：

```
userdel 选项 用户名
```

常用的选项是 **-r**，它的作用是把用户的主目录一起删除。

例如：

```
# userdel -r sam
```

此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。

## 4.3 修改帐号

修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。

修改已有用户的信息使用`usermod`命令，其格式如下：

```
usermod 选项 用户名
```

常用的选项包括`-c, -d, -m, -g, -G, -s, -u以及-o等`，这些选项的意义与`useradd`命令中的选项一样，可以为用户指定新的资源值。

```
# usermod -s /bin/ksh -d /home/z –g developer sam
```

此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer

## 4.4 用户口令的管理

用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。

指定和修改用户口令的Shell命令是`passwd`。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：

```
passwd 选项 用户名
```

可使用的选项：

- -l 锁定口令，即禁用账号。
- -u 口令解锁。
- -d 使账号无口令。
- -f 强迫用户下次登录时修改口令。

如果默认用户名，则修改当前用户的口令。

例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：

```
$ passwd 
Old password:****** 
New password:******* 
Re-enter new password:*******
```

如果是超级用户，可以用下列形式指定任何用户的口令：

```
# passwd sam 
New password:******* 
Re-enter new password:*******
```

普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。

## 4.5 查看用户信息

```shell
[root@VM-4-15-centos ~]# id root
uid=0(root) gid=0(root) groups=0(root)
[root@VM-4-15-centos ~]# id lighthouse
uid=1000(lighthouse) gid=1000(lighthouse) groups=1000(lighthouse)
```

## 4.6 切换用户

```shell
[root@VM-4-15-centos ~]# su - lighthouse
Last login: Sun Nov  8 20:15:19 CST 2020 on pts/0
```

## 4.7 查看当前用户

```shell
[root@VM-4-15-centos ~]# whoami
root
```



# 5. Linux系统用户组的管理

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。

用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。

### 5.1 增加一个新的用户组使用groupadd命令。其格式如下：

```
groupadd 选项 用户组
```

可以使用的选项有：

- -g GID 指定新用户组的组标识号（GID）。
- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

#### 实例1

```
# groupadd group1
```

此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。

#### 实例2

```
# groupadd -g 101 group2
```

此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。

### 5.2 如果要删除一个已有的用户组，使用groupdel命令，其格式如下

```
groupdel 用户组
```

例如：

```
# groupdel group1
```

此命令从系统中删除组group1。

### 5.3 修改用户组的属性使用groupmod命令。其语法如下

```
groupmod 选项 用户组
```

常用的选项有：

- -g GID 为用户组指定新的组标识号。
- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
- -n新用户组 将用户组的名字改为新名字

#### 实例1

```
# groupmod -g 102 group2
```

此命令将组group2的组标识号修改为102。

#### 实例2

```
# groupmod –g 10000 -n group3 group2
```

此命令将组group2的标识号改为10000，组名修改为group3。

### 5.4 如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。

用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：

```
$ newgrp root
```

这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。

### 5.5 与用户账号有关的系统文件

- #### /etc/passwd

- #### **/etc/shadow**

- #### /etc/group

# 6.磁盘的管理

Linux磁盘管理好坏直接关系到整个系统的性能问题。

Linux磁盘管理常用三个命令为df、du和fdisk。

- df：列出文件系统的整体磁盘使用量
- du：检查磁盘空间使用量
- fdisk：用于磁盘分区

# 7. shell

> http://c.biancheng.net/view/773.html

## 7.1 运行 Shell 脚本有两种方法

```shell
#!/bin/bash
echo "Hello World !"
```

## 7.1执行Shell脚本（多种方法）

运行 Shell 脚本有两种方法，一种在新进程中运行，一种是在当前 Shell 进程中运行。

### 7.1.1 在新进程中运行 Shell 脚本

在新进程中运行 Shell 脚本有多种方法。

#### 7.1.1.1 将 Shell 脚本作为程序运行

Shell 脚本也是一种解释执行的程序，可以在终端直接调用（需要使用 chmod 命令给 Shell 脚本加上执行权限），如下所示：

```shell
[mozhiyan@localhost ~]$ cd demo                #切换到 test.sh 所在的目录
[mozhiyan@localhost demo]$ chmod +x ./test.sh  #给脚本添加执行权限
[mozhiyan@localhost demo]$ ./test.sh           #执行脚本文件
Hello World !                                  #运行结果
```

第 2 行中，`chmod +x`表示给 test.sh 增加执行权限。

第 3 行中，`./`表示当前目录，整条命令的意思是执行当前目录下的 test.sh 脚本。如果不写`./`，Linux 会到系统路径（由 PATH 环境变量指定）下查找 test.sh，而系统路径下显然不存在这个脚本，所以会执行失败。

通过这种方式运行脚本，脚本文件第一行的`#!/bin/bash`一定要写对，好让系统查找到正确的解释器。

#### 7.1.1.2 将 Shell 脚本作为参数传递给 Bash 解释器

你也可以直接运行 Bash 解释器，将脚本文件的名字作为参数传递给 Bash，如下所示：

```shell
[mozhiyan@localhost ~]$ cd demo               #切换到 test.sh 所在的目录
[mozhiyan@localhost demo]$ /bin/bash test.sh  #使用Bash的绝对路径
Hello World !                                 #运行结果
```

通过这种方式运行脚本，不需要在脚本文件的第一行指定解释器信息，写了也没用。

更加简洁的写法是运行 bash 命令。bash 是一个外部命令，Shell 会在 /bin 目录中找到对应的应用程序，也即 /bin/bash，这点我们已在《[Shell命令的本质到底是什么](http://m.biancheng.net/view/vip_3229.html)》一节中提到。

```shell
[mozhiyan@localhost ~]$ cd demo
[mozhiyan@localhost demo]$ bash test.sh
Hello World !
```

这两种写法在本质上是一样的：第一种写法给出了绝对路径，会直接运行 Bash 解释器；第二种写法通过 bash 命令找到 Bash 解释器所在的目录，然后再运行，只不过多了一个查找的过程而已。

#### 7.1.1.3 检测是否开启了新进程

Linux 中的每一个进程都有一个唯一的 ID，称为 PID，使用`$$`变量就可以获取当前进程的 PID。`$$`是 Shell 中的特殊变量，稍后我会在《[Shell特殊变量](http://m.biancheng.net/view/806.html)》一节中展开讲解，读者在此不必深究。

首先编写如下的脚本文件，并命名为 check.sh：

```shell
#!/bin/bash
echo $$  #输出当前进程PID
```

然后使用以上两种方式来运行 check.sh：

```shell
[mozhiyan@localhost demo]$ echo $$
2861  #当前进程的PID
[mozhiyan@localhost demo]$ chmod +x ./check.sh
[mozhiyan@localhost demo]$ ./check.sh
4597  #新进程的PID
[mozhiyan@localhost demo]$ echo $$
2861  #当前进程的PID
[mozhiyan@localhost demo]$ /bin/bash check.sh
4584  #新进程的PID
```

你看，进程的 PID 都不一样，当然就是两个进程了。

### 7.1.2 在当前进程中运行 Shell 脚本

#### 7.1.2.1 source

这里需要引入一个新的命令——source 命令。source 是 [Shell 内置命令](http://m.biancheng.net/view/1136.html)的一种，它会读取脚本文件中的代码，并依次执行所有语句。你也可以理解为，source 命令会强制执行脚本文件中的全部命令，而忽略脚本文件的权限。

source 命令的用法为：

```shell
source filename
```

也可以简写为：

```shell
. filename
```

两种写法的效果相同。对于第二种写法，注意点号`.`和文件名中间有一个空格。

例如，使用 source 运行上节的 test.sh：

```shell
[mozhiyan@localhost ~]$ cd demo              #切换到test.sh所在的目录
[mozhiyan@localhost demo]$ source ./test.sh  #使用source
Hello World !
[mozhiyan@localhost demo]$ source test.sh    #使用source
Hello World !
[mozhiyan@localhost demo]$ . ./test.sh       #使用点号
Hello World !
[mozhiyan@localhost demo]$ . test.sh         #使用点号
Hello World !
```

你看，使用 source 命令不用给脚本增加执行权限，并且写不写`./`都行，是不是很方便呢？

#### 7.1.2.2 检测是否在当前 Shell 进程中

我们仍然借助`$$`变量来输出进程的 PID，如下所示：

```shell
[mozhiyan@localhost ~]$ cd demo
[mozhiyan@localhost demo]$ echo $$
5169  #当前进程PID
[mozhiyan@localhost demo]$ source ./check.sh
5169  #Shell脚本所在进程PID
[mozhiyan@localhost demo]$ echo $$
5169  #当前进程PID
[mozhiyan@localhost demo]$ . ./check.sh
5169  #Shell脚本所在进程PID
```

你看，进程的 PID 都是一样的，当然是同一个进程了。

### 7.1.3 总结

如果需要在新进程中运行 Shell 脚本，我一般使用`bash test.sh`这种写法；如果在当前进程中运行 Shell 脚本，我一般使用`. ./test.sh`这种写法。

## 7.2 shell变量

Shell 变量的作用域（Scope），就是 Shell 变量的有效范围（可以使用的范围）。

在不同的作用域中，同名的变量不会相互干涉，就好像 A 班有个叫小明的同学，B 班也有个叫小明的同学，虽然他们都叫小明（对应于变量名），但是由于所在的班级（对应于作用域）不同，所以不会造成混乱。但是如果同一个班级中有两个叫小明的同学，就必须用类似于“大小明”、“小小明”这样的命名来区分他们。

Shell 变量的作用域可以分为三种：

- 有的变量只能在函数内部使用，这叫做**局部变量**（local variable）；
- 有的变量可以在当前 Shell 进程中使用，这叫做**全局变量**（global variable）；
- 而有的变量还可以在子进程中使用，这叫做**环境变量**（environment variable）。

### 7.2.1 Shell 局部变量

Shell 也支持自定义函数，但是 Shell 函数和 [C++](http://c.biancheng.net/cplus/)、[Java](http://c.biancheng.net/java/)、[C#](http://c.biancheng.net/csharp/) 等其他编程语言函数的一个不同点就是：在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果。请看下面的代码：

```shell
#!/bin/bash
#定义函数
function func(){
    a=99
}
#调用函数
func
#输出函数内部的变量
echo $a
```

输出结果：
99

a 是在函数内部定义的，但是在函数外部也可以得到它的值，证明它的作用域是全局的，而不是仅限于函数内部。

要想变量的作用域仅限于函数内部，可以在定义时加上`local`命令，此时该变量就成了局部变量。请看下面的代码：

```shell
#!/bin/bash
#定义函数
function func(){
    local a=99
}
#调用函数
func
#输出函数内部的变量
echo $a
```

输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。

Shell 变量的这个特性和 [JavaScript](http://c.biancheng.net/js/) 中的变量是类似的。在 JavaScript 函数内部定义的变量，默认也是全局变量，只有加上`var`关键字，它才会变成局部变量。

### 7.2.2 Shell 全局变量

所谓全局变量，就是指变量在当前的整个 Shell 进程中都有效。每个 Shell 进程都有自己的作用域，彼此之间互不影响。在 Shell 中定义的变量，默认就是全局变量。

想要实际演示全局变量在不同 Shell 进程中的互不相关性，可在图形界面下同时打开两个 Shell，或使用两个终端远程连接到服务器（SSH）。

首先打开一个 Shell 窗口，定义一个变量 a 并赋值为 99，然后打印，这时在同一个 Shell 窗口中是可正确打印变量 a 的值的。然后再打开一个新的 Shell 窗口，同样打印变量 a 的值，但结果却为空，如图 1 所示。

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\shell全局变量.png)

这说明全局变量 a 仅仅在定义它的第一个 Shell 进程中有效，对新的 Shell 进程没有影响。这很好理解，就像小王家和小徐家都有一部电视机（变量名相同），但是同一时刻小王家和小徐家的电视中播放的节目可以是不同的（变量值不同）。

需要强调的是，全局变量的作用范围是当前的 Shell 进程，而不是当前的 Shell 脚本文件，它们是不同的概念。打开一个 Shell 窗口就创建了一个 Shell 进程，打开多个 Shell 窗口就创建了多个 Shell 进程，每个 Shell 进程都是独立的，拥有不同的进程 ID。在一个 Shell 进程中可以使用 source 命令执行多个 Shell 脚本文件，此时全局变量在这些脚本文件中都有效。

例如，现在有两个 Shell 脚本文件，分别是 a.sh 和 b.sh。a.sh 的代码如下：

```shell
#!/bin/bash
echo $a
b=200
```

b.sh 的代码如下：

```shell
#!/bin/bash
echo $b
```

打开一个 Shell 窗口，输入以下命令：

```shell
[c.biancheng.net]$ a=99
[c.biancheng.net]$ . ./a.sh
99
[c.biancheng.net]$ . ./b.sh
200
```

这三条命令都是在一个进程中执行的，从输出结果可以发现，在 Shell 窗口中以命令行的形式定义的变量 a，在 a.sh 中有效；在 a.sh 中定义的变量 b，在 b.sh 中也有效，变量 b 的作用范围已经超越了 a.sh。

### 7.2.3 Shell 环境变量

全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用`export`命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。

环境变量被创建时所处的 Shell 进程称为父进程，如果在父进程中再创建一个新的进程来执行 Shell 命令，那么这个新的进程被称作 Shell 子进程。当 Shell 子进程产生时，它会继承父进程的环境变量为自己所用，所以说环境变量可从父进程传给子进程。不难理解，环境变量还可以传递给孙进程。

注意，两个没有父子关系的 Shell 进程是不能传递环境变量的，并且环境变量只能向下传递而不能向上传递，即“传子不传父”。

创建 Shell 子进程最简单的方式是运行 bash 命令，如图 2 所示。

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\进入shell子进程.gif)

​                                图2：进入 Shell 子进程  

通过`exit`命令可以一层一层地退出 Shell。

下面演示一下环境变量的使用：

```shell
[c.biancheng.net]$ a=22       #定义一个全局变量
[c.biancheng.net]$ echo $a    #在当前Shell中输出a，成功
22
[c.biancheng.net]$ bash       #进入Shell子进程
[c.biancheng.net]$ echo $a    #在子进程中输出a，失败

[c.biancheng.net]$ exit       #退出Shell子进程，返回上一级Shell
exit
[c.biancheng.net]$ export a   #将a导出为环境变量
[c.biancheng.net]$ bash       #重新进入Shell子进程
[c.biancheng.net]$ echo $a    #在子进程中再次输出a，成功
22
[c.biancheng.net]$ exit       #退出Shell子进程
exit
[c.biancheng.net]$ exit       #退出父进程，结束整个Shell会话
```

可以发现，默认情况下，a 在 Shell 子进程中是无效的；使用 export 将 a 导出为环境变量后，在子进程中就可以使用了。

`export a`这种形式是在定义变量 a 以后再将它导出为环境变量，如果想在定义的同时导出为环境变量，可以写作`export a=22`。

我们一直强调的是环境变量在 Shell 子进程中有效，并没有说它在所有的 Shell 进程中都有效；如果你通过终端创建了一个新的 Shell 窗口，那它就不是当前 Shell 的子进程，环境变量对这个新的 Shell 进程仍然是无效的。请看下图：

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\shell1号窗口.gif)

第一个窗口中的环境变量 a 在第二个窗口中就无效。

#### 7.2.3.1环境变量也是临时的

通过 export 导出的环境变量只对当前 Shell 进程以及所有的子进程有效，如果最顶层的父进程被关闭了，那么环境变量也就随之消失了，其它的进程也就无法使用了，所以说环境变量也是临时的。

<u>有读者可能会问，如果我想让一个变量在所有 Shell 进程中都有效，不管它们之间是否存在父子关系，该怎么办呢？</u>

<u>只有将变量写入 Shell 配置文件中才能达到这个目的！Shell 进程每次启动时都会执行配置文件中的代码做一些初始化工作，如果将变量放在配置文件中，那么每次启动进程都会定义这个变量。不知道如何修改配置文件的读者请猛击《[Shell配置文件的加载](http://c.biancheng.net/view/vip_3232.html)》《[编写自己的Shell配置文件](http://c.biancheng.net/view/vip_3233.html)》。</u>

#### 7.2.3.2 设置环境变量

Linux 下设置环境变量有三种方法，一种用于当前终端，一种用于当前用户，一种用于所有用户：

##### 用于当前终端

在当前终端中输入：

```shell
export PATH=$PATH:<你的要加入的路径>
```

不过上面的方法**只适用于当前终端**，一旦当前终端关闭或在另一个终端中，则无效

##### **用于当前用户**

在用户主目录下有一个 .bashrc 隐藏文件，可以在此文件中加入 PATH 的设置如下：

```shell
[root@VM-4-15-centos bin]# vim ~/.bashrc
```

加入：

```shell
export PATH=<你的要加入的路径>:$PATH
```

如果要加入多个路径，只要：

```shell
export PATH=<你要加入的路径1>:<你要加入的路径2>: ...... :$PATH
```

当中每个路径要以冒号分隔。

这样每次登录都会生效

添加PYTHONPATH的方法也是这样，在.bashrc中添加

export PYTHONPATH=/home/felix/setup/caffe-master/python:/home/felix/setup/mypy:$PYTHONPATH 

保存后在终端输入

```shell
 $ source ~/.bashrc 
```

使环境变量立即生效

##### 用于所有用户

```
$ sudo vim /etc/profile 
```

加入：

```shell
export PATH=<你要加入的路径>:$PATH
```

就可以了。

终端输入：

```shell
echo $PATH
```

 可以查看环境变量

##### 注意

修改环境变量后，除了第一种方法立即生效外，第二第三种方法要立即生效，可以**source ~/.bashrc**或者注销再次登录后就可以了

**基础语法**

- export 变量名=变量值 （将shell变量输出为环境变量）
- source 配置文件 （让修改后的配置文件立即生效）
- echo $变量名 （查询环境变量的值）

#### 7.2.3.3 export

全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用`export`命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。

参考”shell环境变量“标题

### 7.2.4 Shell四种运行方式（启动方式）

Shell 是一个应用程序，它的一端连接着 Linux 内核，另一端连接着用户。Shell 是用户和 Linux 系统沟通的桥梁，我们都是通过 Shell 来管理 Linux 系统。

我们可以直接使用 Shell，也可以输入用户名和密码后再使用 Shell；第一种叫做非登录式，第二种叫做登录式。

我们可以在 Shell 中一个个地输入命令并及时查看它们的输出结果，整个过程都在跟 Shell 不停地互动，这叫做交互式。我们也可以运行一个 Shell 脚本文件，让所有命令批量化、一次性地执行，这叫做非交互式。

总起来说，Shell 一共有四种运行方式：

- 交互式的登录 Shell；
- 交互式的非登录 Shell；
- 非交互式的登录 Shell；
- 非交互式的非登录 Shell。

#### 判断 Shell 是否是交互式

判断是否为交互式 Shell 有两种简单的方法。

1) 查看变量`-`的值，如果值中包含了字母`i`，则表示交互式（interactive）。

【实例1】在 CentOS GNOME 桌面环境自带的终端下输出`-`的值：

```shell
[c.biancheng.net]$ echo $-
himBH
```

包含了`i`，为交互式。

【实例2】在 Shell 脚本文件中输出`-`的值：

```shell
[c.biancheng.net]$ cat test.sh
#!/bin/bash

echo $-
[c.biancheng.net]$ bash ./test.sh
hB
```

不包含`i`，为非交互式。注意，必须在新进程中[运行 Shell 脚本](http://c.biancheng.net/view/739.html)。

2) 查看变量`PS1`的值，如果非空，则为交互式，否则为非交互式，因为非交互式会清空该变量。

【实例1】在 CentOS GNOME 桌面环境自带的终端下输出 PS1 的值：

```shell
[mozhiyan@localhost]$ echo $PS1
[\u@\h \W]\$
```

非空，为交互式。

【实例2】在 Shell 脚本文件中输出 PS1 的值：

```shell
[c.biancheng.net]$ cat test.sh
#!/bin/bash

echo $PS1
[c.biancheng.net]$ bash ./test.sh
```

空值，为非交互式。注意，必须在新进程中运行 Shell 脚本。

#### 判断 Shell 是否为登录式

判断 Shell 是否为登录式也非常简单，只需执行`shopt login_shell`即可，值为`on`表示为登录式，`off`为非登录式。

shopt 命令用来查看或设置 Shell 中的行为选项，这些选项可以增强 Shell 的易用性。

【实例1】在 CentOS GNOME 桌面环境自带的终端下查看 login_shell 选项：

```shell
[c.biancheng.net]$ shopt login_shell
login_shell    off
```


【实例2】按下`Ctrl+Alt+Fn`组合键切换到虚拟终端，输入用户名和密码登录后，再查看 login_shell 选项：

```shell
[c.biancheng.net]$ shopt login_shell
login_shell    on
```


【实例3】在 Shell 脚本文件中查看 login_shel 选项：

```shell
[c.biancheng.net]$ cat test.sh
#!/bin/bash

shopt login_shell
[c.biancheng.net]$ bash ./test.sh
login_shell    off
```

#### 常见的 Shell 启动方式

1) 通过 Linux 控制台（不是桌面环境自带的终端）或者 ssh 登录 Shell 时（这才是正常登录方式），为交互式的登录 Shell。

```shell
[c.biancheng.net]$ echo $PS1;shopt login_shell
[\u@\h \W]\$
login_shell    on
```

2) 执行 bash 命令时默认是非登录的，增加`--login`选项（简写为`-l`）后变成登录式。

```shell
[c.biancheng.net]$ cat test.sh
#!/bin/bash

echo $-; shopt login_shell
[c.biancheng.net]$ bash -l ./test.sh
hB
login_shell    on
```

3) 使用由`()`包围的[组命令](http://c.biancheng.net/view/3023.html)或者[命令替换](http://c.biancheng.net/view/1164.html)进入子 Shell 时，子 Shell 会继承父 Shell 的交互和登录属性。

```shell
[c.biancheng.net]$ bash
[c.biancheng.net]$ (echo $PS1;shopt login_shell)
[\u@\h \W]\$
login_shell    off
[c.biancheng.net]$ bash -l
[c.biancheng.net]$ (echo $PS1;shopt login_shell)
[\u@\h \W]\$
login_shell    on
```

4) ssh 执行远程命令，但不登录时，为非交互非登录式。

```shell
[c.biancheng.net]$ ssh localhost 'echo $PS1;shopt login_shell'

login_shell     off
```

5) 在 [Linux 桌面环境](http://c.biancheng.net/view/2912.html)下打开终端时，为交互式的非登录 Shell。

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\交互式非登录shell.gif)

### 7.2.5 Shell配置文件加载

#### 预备知识

无论是否是交互式，是否是登录式，Bash Shell 在启动时总要配置其运行环境，例如初始化环境变量、设置命令提示符、指定系统命令路径等。这个过程是通过加载一系列配置文件完成的，这些配置文件其实就是 Shell 脚本文件。

与 Bash Shell 有关的配置文件主要有 /etc/profile、~/.bash_profile、~/.bash_login、~/.profile、~/.bashrc、/etc/bashrc、/etc/profile.d/*.sh，**不同的启动方式会加载不同的配置文件**

#### 登录式的 Shell

Bash 官方文档说：如果是登录式的 Shell，首先会读取和执行 /etc/profile，这是所有用户的全局配置文件，接着会到用户主目录中寻找 ~/.bash_profile、~/.bash_login 或者 ~/.profile，它们都是用户个人的配置文件。

不同的 Linux 发行版附带的个人配置文件也不同，有的可能只有其中一个，有的可能三者都有，笔者使用的是 CentOS 7，该发行版只有 ~/.bash_profile，其它两个都没有。

如果三个文件同时存在的话，到底应该加载哪一个呢？它们的优先级顺序是 ~/.bash_profile > ~/.bash_login > ~/.profile。

如果 ~/.bash_profile 存在，那么一切以该文件为准，并且到此结束，不再加载其它的配置文件。

如果 ~/.bash_profile 不存在，那么尝试加载 ~/.bash_login。~/.bash_login 存在的话就到此结束，不存在的话就加载 ~/.profile。

注意，/etc/profile 文件还会嵌套加载 /etc/profile.d/*.sh，请看下面的代码：

```shell
for i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; do
    if [ -r "$i" ]; then
        if [ "${-#*i}" != "$-" ]; then
            . "$i"
        else
            . "$i" >/dev/null
        fi
    fi
done
```

同样，~/.bash_profile 也使用类似的方式加载 ~/.bashrc：

```shell
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
```

#### 非登录的 Shell

如果以非登录的方式启动 Shell，那么就不会读取以上所说的配置文件，而是直接读取 **~/.bashrc**。

~/.bashrc 文件还会嵌套加载 /etc/bashrc，请看下面的代码：

```shell
if [ -f /etc/bashrc ]; then
. /etc/bashrc
fi
```

#### 总结

> https://blog.csdn.net/Field_Yang/article/details/51087178

##### 全局配置与个人配置

- 全局配置    /etc/profile， /etc/profile.d/\*.sh，/etc/bashrc
- 个人配置    ~/.bashrc , ~/.bash_profile

##### 加载顺序

- 登录式shell如何读取配置文件/etc/profile {嵌套加载/etc/profile.d/\*.sh和/etc/profile.d/sh.local }-->~/.bash_profile --> ~/.bashrc-->/etc/bashrc        
- 非登录式*shell*如何配置文件 ~/.bashrc -->/etc/bashrc-->/etc/profile.d/\*.sh

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\shell环境变量启动过程.png)

##### $PATH

决定了**shell**将到哪些目录中寻找命令或程序，**PATH**的值是一系列目录，当您运行一个程序时，**Linux**在这些目录下进行搜寻编译链接。8

### 7.2.6 如何编写自己的shell配置文件



# 8. 打包压缩命令

## 8.1 tar命令

tar命令用于对文件进行打包压缩或解压，格式为“tar[选项][文件]”。

```shell
.tar
压缩：tar cvf FileName.tar FileName
解压：tar xvf FileName.tar
--------------------------------------------- 
.gz
解压1：gunzip FileName.gz 
解压2：gzip -d FileName.gz 
压缩：gzip FileName 
.tar.gz 
解压：tar zxvf FileName.tar.gz 
压缩：tar zcvf FileName.tar.gz DirName 
--------------------------------------------- 
.bz2 
解压1：bzip2 -d FileName.bz2 
解压2：bunzip2 FileName.bz2 
压缩： bzip2 -z FileName 
.tar.bz2 
解压：tar jxvf FileName.tar.bz2 
压缩：tar jcvf FileName.tar.bz2 DirName 
--------------------------------------------- 
.bz 
解压1：bzip2 -d FileName.bz 
解压2：bunzip2 FileName.bz 
压缩：未知 
.tar.bz 
解压：tar jxvf FileName.tar.bz 
压缩：未知 
--------------------------------------------- 
.Z 
解压：uncompress FileName.Z 
压缩：compress FileName 
.tar.Z 
解压：tar Zxvf FileName.tar.Z 
压缩：tar Zcvf FileName.tar.Z DirName 
--------------------------------------------- 
.tgz 
解压：tar zxvf FileName.tgz 
压缩：未知 
.tar.tgz 
解压：tar zxvf FileName.tar.tgz 
压缩：tar zcvf FileName.tar.tgz FileName 
--------------------------------------------- 
.zip 
解压：unzip FileName.zip 
压缩：zip FileName.zip DirName 
--------------------------------------------- 
.rar 
解压：rar a FileName.rar 
压缩：rar e FileName.rar 
```

各个不同后缀的含义如下：

1. .tar打包格式：tar程序打包的数据，并没有压缩过
2. .z格式：compress程序压缩的文件
3. .gz压缩格式：gzip程序压缩的文件 .bz2压缩格式：bzip2程序压缩的文件
4. .tar.gz打包压缩：tar程序打包的文件，其中并且经过 gzip 的压缩
5. .tar.bz2打包压缩：tar程序打包的文件，其中并且经过 bzip2 的压缩

tar是打包命令，比较常见，下面给出他的不同参数的含义

1. -c: 建立压缩档案
2. -x：解压
3. -t：查看内容
4. -r：向压缩归档文件末尾追加文件
5. -u：更新原压缩包中的文件

## 8.2 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但这五个命令只能用其中一个。

下面的参数是根据需要在压缩或解压档案时可选的。

1. -z：有gzip属性的
2. -j：有bz2属性的
3. -z：有compress属性的
4. -v：显示所有过程
5. -o：将文件解开到标准输出

## 8.3 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名，并且是必须的。

下面给出一些例子

```shell
tar -cf FileName.tar DirName：这条命令是将DirName的文件夹打成一个名为FileName.tar的包。-c是表示产生新的包，-f指定包的文件名；

tar -cf FileName.tar *.jpg：这条命令是将所有.jpg的文件打成一个名为FileName.tar的包；

tar -rf FileName.tar *.gif：这条命令是将所有.gif的文件增加到FileName.tar的包里面去。-r是表示增加文件的意思；

tar -uf FileName.tar logo.gif：这条命令是更新原来tar包FileName.tar中logo.gif文件，-u是表示更新文件的意思；

tar -tf FileName.tar：这条命令是列出FileName.tar包中所有文件，-t是列出文件的意思；

tar -xf FileName.tar：这条命令是解出FileName.tar包中所有文件，-x是解开的意思。
```

# 9. Centos和UBUNTU区别

- centos中新建的普通用户是没有sudo权限的，如果想让普通用户拥有sudo权限需要在/etc/sudoers文件中添加用户的权限，而ubuntu系统普通用户想要使用sudo权限 直接使用sudo +命令行的方式就可以了
- 安装软件包命令格式不一样。centos使用yum的方式，而Ubuntu使用apt-get 方式
- 由于centos是基于redhat的，所以centos支持rpm包，但Ubuntu不支持
- centos比ubuntu稳定

# 10.Linux下载软件

以centos为例，安装程序的方式：

- 通用二进制格式：直接解压压缩文件，就可以使用。但一定要注意安装平台。
- 软件包管理器：如RPM。
- 软件包管理器的前端工具：如YUM。
- 源代码编译

软件包的组成部分：

- 二进制程序，位于 /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 等目录中。
- 库文件，位于 /lib, /usr/lib, /usr/local/lib 等目录中。Linux中库文件以 .so（动态链接库）或 .a（静态链接库）作为文件后缀名。
- 配置文件，位于 /etc 目录中。
- 帮助文件：手册, README, INSTALL (/usr/share/doc/)

## 10.1 源代码编译

- 绝大多数开源软件都是直接以原码形式发布的
- 源代码一般会被打成.tar.gz的归档压缩文件
- 源代码需要编译成为二进制形式之后才能够运行使用
- 源代码基本编译流程：
- - configure 检查编译环境；
  - make对源代码进行编译；
  - make insall 将生成的可执行文件安装到当前计算机中

### 10.1.1 wget

**wget命令详解**

https://www.cnblogs.com/sx66/p/11887022.html

yum是一种安装工具。如果你想安装软件，可以使用yum安装的时候，建议使用yum安装最好，基本上是一步完成。
比如安装Linux的rz/sz命令工具：
直接输入：yum install -y lrzsz 就会安装了。

wget是一种下载工具。可以下载网络上的资源，有点类似于迅雷。
比如安装redis时需要先下载redis软件然后再安装，那就用wget命令

**例子**

见lrzsz两种安装方式

## 10.2 rpm的使用

### 10.2.1 简介

这个命令可以用来查询，安装，卸载，更新软件包

RMP 是 LINUX 下的一种软件的可执行程序，你只要安装它就可以了。这种软件安装包通常是一个RPM包（Redhat Linux Packet Manager，就是Redhat的包管理器），后缀是.rpm。

RPM是Red Hat公司随Redhat Linux推出了一个软件包管理器，通过它能够更加轻松容易地实现软件的安装。

 1.安装软件：执行rpm -ivh rpm包名，如：
 \#rpm -ivh apache-1.3.6.i386.rpm 
 2.升级软件：执行rpm -Uvh rpm包名。
 3.反安装：执行rpm -e rpm包名。
 4.查询软件包的详细信息：执行rpm -qpi rpm包名
 5.查询某个文件是属于那个rpm包的：执行rpm -qf rpm包名
 6.查该软件包会向系统里面写入哪些文件：执行 rpm -qpl rpm包名

### 10.2.2 rpm与yum的关系与联系

**rpm :RedHat package manage的简写**

rpm 是linux的一种软件包名称，以.rmp结尾，安装的时候语法为：rpm -ivh，rpm包的安装有一个很大的缺点就是文件的关联性太大时，有时候装一个软件要安装很多其他的软件包，很麻烦

**yum（全称为 Yellow dog Updater, Modified）**

yum是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。
为了解决rpm安装时文件关联行太大的问题,RedHat小红帽开发了yum安装方法，他可以彻底解决这个关联性的问题，很方便，只要配置两个文件即可安装，安装方法是：yum -y install ，yum并不是一中包，而是安装包的软件
yum的命令形式一般是如下：yum [options] [command] [package ...]
其中的[options]是可选的，选项包括-h（帮助），-y（当安装过程提示选择全部为"yes"），-q（不显示安装的过程）等等。[command]为所要进行的操作，[package ...]是操作的对象。

### 10.2.3 搜索软件包

```shell
rpm -pa|grep sz
```

## 10.3 yum下载软件

### 10.3.1 yum简介

rpm软件包形式的管理虽然方便，但是需要手工解决软件包的依赖关系。很多时候安装一个软件安装一个软件需要安装1个或者多个其他软件，手动解决时，很复杂，yum解决这些问题。Yum是rpm的前端程序，主要目的是设计用来自动解决rpm的依赖关系，其特点：

1) 自动解决依赖关系

2) 可以对rpm进行分组，基于组进行安装操作

3) 引入仓库概念，支持多个仓库

4) 配置简单

### 10.3.2 yum管理软件仓库

yum仓库用来存放所有的现有的.rpm包，当使用yum安装一个rpm包时，需要依赖关系，会自动在仓库中查找依赖软件并安装。仓库可以是本地的，也可以是HTTP、FTP、nfs形式使用的集中地、统一的网络仓库。

### 10.3.3 配置

仓库的配置文件/etc/yum.repos.d目录下

### 10.3.4 使用

- yum install 安装；
- yum remove卸载；
- yum update 升级制定软件

### 10.3.5 镜像

安装的时候，会下载软件包.Rpm在安装，所以用国内仓库

改变镜像源

- 访问地址http://mirrors.163.com/
- 点centos使用帮助
- 按步骤来

### 10.3.6 查询

查询软件：可以使用

```shell
 yumsearch **
```

# 11. linux上传下载文件到Windows本地或服务器之间传输文件的方式

## 11.1 linux的rz、sz

ftp 的下载速度 是rz 的3倍以上

rz 命令新版linux 系统都会自带，如果没有请更新下源并且安装

```
 sz：将选定的文件发送（send）到本地机器
 rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到服务器(receive)设置上传和下载的默认目录:
options–>session options–>X/Y/Zmodem 下可以设置上传和下载的目录
```

### **检查是否安装sz rz**

```shell
[root@VM-4-15-centos ~]# rpm -qa |grep rz
lrzsz-0.12.20-36.el7.x86_64
```

### lrzsz两种安装方式

#### 通过yum 安装

```shell
yum install -y lrzsz
```

#### 下载文件

**下载**

wget http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz

**解压编译**

```shell
tar zxvf lrzsz-0.12.20.tar.gz
make：
cd lrzsz-0.12.20
./configure && make && make install
```

**创建软连接方便使用**

```shell
cd 编译目录
sudo ln -s 编译目录/lrz rz
sudo ln -s 编译目录/lsz sz
```

### rz 原理

使用的协议是ZMODEM协议

https://blog.csdn.net/ligerendaqiu123/article/details/44964791

## 11.2 linux ftp

### 11.2.1 介绍

FTP服务器简单地说，支持FTP协议的服务器就是FTP服务器。
与大多数Internet 服务一样，FTP也是一个客户机、服务器系统。用户通过一个支持FTP协议的客户机程序，连接到在远程主机上的FTP服务器程序。用户通过客户机程序向服务器程序发出命令，服务器程序执行用户所发出的命令，并将执行的结果返回到客户机。比如说，用户发出一条命令，要求服务器向用户传送某一个文件的一份拷贝，服务器会响应这条命令，将指定文件送至用户的机器上。客户机程序代表用户接收到这个文件，将其存放在用户目录中。

- **ftp的工作端口:** 

  ​            21 : 控制端口,用于在客户机和服务器之间建立连接

  ​            20 : 数据端口,用于服务器给客户机主动进行数据连接

- **vsftpd**:非常安全文件传输协议守护进程(very secure ftp daemon)

- **ftp的工作模式：主动port、被动passive模式**

  客户端与服务端传输数据时,服务端传输端口为20时为主动模式,传输端口为>1024的随机端口时为被动模式

### 11.2.2 ftp、sftp、vsftp、vsftpd这四个的区别

- **ftp** 是`File Transfer Protocol`的缩写，文件传输协议，用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议的应用层。
  [了解更多ftp](https://baike.baidu.com/item/ftp/13839?fr=aladdin)
- **sftp** 是`SSH File Transfer Protocol`的缩写，安全文件传输协议；
  [了解更多sftp](https://baike.baidu.com/item/sftp/1184182?fr=aladdin)
- **vsftp** 是一个基于GPL发布的类Unix系统上使用的ftp服务器软件，它的全称是`Very Secure FTP`从此名称可以看出来，编制者的初衷是代码的安全；
  [了解更多vsftp](https://baike.baidu.com/item/VSFTP/2596628?fr=aladdin)
- **vsftpd** 是`very secure FTP daemon`的缩写，安全性是它的一个最大的特点。vsftpd 是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、BSD、Solaris、 HP-UNIX等系统上面，是一个完全免费的、开放源代码的ftp服务器软件；
  [了解更多vsftpd](https://baike.baidu.com/item/vsftpd)

### 11.2.3 检查Linux上是否安装了ftp

```shell
rpm -qa |grep vsftpd
```

如果已经安装了ftp服务，则出现ftp的版本信息

### 11.2.4 安装和配置环境

#### 服务端

**安装**

```shell
yum install vsftpd
```

**启动并查看ftp服务**

```shell
[root@VM-4-15-centos ~]# systemctl start vsftpd
[root@VM-4-15-centos ~]# systemctl enable vsftpd
Created symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.
[root@VM-4-15-centos ~]# systemctl status vsftpd
● vsftpd.service - Vsftpd ftp daemon
   Loaded: loaded (/usr/lib/systemd/system/vsftpd.service; enabled; vendor preset: disabled)
   Active: active (running) since Sun 2020-11-08 19:02:46 CST; 1min 17s ago
 Main PID: 20962 (vsftpd)
   CGroup: /system.slice/vsftpd.service
           └─20962 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf

Nov 08 19:02:46 VM-4-15-centos systemd[1]: Starting Vsftpd ftp daemon...
Nov 08 19:02:46 VM-4-15-centos systemd[1]: Started Vsftpd ftp daemon.
```

**查看ftp的配置文件**

```shell
[root@VM-4-15-centos ~]# rpm -qc vsftpd
/etc/logrotate.d/vsftpd
/etc/pam.d/vsftpd
/etc/vsftpd/ftpusers
/etc/vsftpd/user_list
/etc/vsftpd/vsftpd.conf
```

#### linux客户端

**方式**

- 使用命令方式
- 使用浏览器地址栏
- **FTP客户端软件--->lftp/ftp**

lftp是一个文件客户端程序,它支持ftp、SETP、HTTP和FTPs等多种文件传输协议

**安装lftp软件**

```shell
yum install lftp -y /
yum install ftp
```

**连接**

```shell
[root@VM-4-15-centos ~]# lftp [hostname| ip-address]
lftp :~> quit
```

**windows的cmd客户端**

```shell
C:\Users\felixsfan>ftp [hostname| ip-address]
ftp>quit
```

**下载文件**

下载文件通常用get和mget这两条命令

- get
  格式：get [remote-file] [local-file]
  将文件从远端主机中传送至本地主机中。
  如要获取远程服务器上/usr/your/1.htm，则

```shell
  ftp> get /usr/your/1.htm1
```

- mget　　　　　　
  格式：mget [remote-files]
  从远端主机接收一批文件至本地主机。
  如要获取服务器上/usr/your/下的所有文件，则

```shell
ftp> cd /usr/your/
ftp> mget *.* (回车)
```

此时每下载一个文件，都会有提示。如果要除掉提示，则在mget *.* 命令前先执行:prompt off

注意：文件都下载到了linux主机的当前目录下。比如，在　/usr/my下运行的ftp命令，则文件都下载到了/usr/my下。

**上传文件**

- put

  格式：put local-file [remote-file]
  将本地一个文件传送至远端主机中。
  如要把本地的1.htm传送到远端主机/usr/your,并改名为2.htm

  ```shell
  ftp> put 1.htm /usr/your/2.htm (回车)
  ```

- mput
  格式：mput local-files
  将本地主机中一批文件传送至远端主机。
  如要把本地当前目录下所有html文件上传到服务器/usr/your/ 下

  ```shell
  ftp> cd /usr/your （回车）
  ftp> mput *.htm　（回车）
  ```

  注意：上传文件都来自于主机的当前目录下。比如，在　/usr/my下运行的ftp命令，则只有在/usr/my下的文件linux才会上传到服务器/usr/your 下

#### 创建用户

```shell
# 以root用户登录后，增加名为 xlftp 的用户，并指定 xlftp 用户的主目录为 /home/xlftp
[root@xl ~]# useradd -d /home/xlftp xlftp 
 
# 为 xlftp 设置或修改密码
[root@xl ~]# passwd xlftp
```

#### 用户登录

```shell
# 直接通过ftp命令登录
[root@xl ~]# ftp 192.168.1.100
 
# 在ftp命令模式下登录
ftp> open 192.168.1.100
 
# 指定ftp服务端口登录
[root@xl ~]# ftp 192.168.1.100 5005
```

## 11.3 linux下sz/rz,scp,sftp,ftp的区别与对比

1.sz/rz 传输速度慢,小文件可以直接使用,基于Zmodem

2.scp与sftp基于ssh,安全连接,但scp无管理文件的功能

3.sftp,替代ftp存在,但因为是加密传输,速度上有一定影响

4.ftp无加密传输,速度较快,但不安全



# 12. 常用指令

## 命令构成

 命令＋常用选项＋目录 

## 关机&重启命令

**shutdown**

- shutdown -h now :立即关机
- shutdown -h 1:一分钟后关机
- shutdown -r now:立即重启

**halt**：关机
**reboot**：重启系统
**sync**：将内存上的数据写入磁盘（建议重启或关机前使用）
**logout**:注销用户（图形界面无效）

## 帮助指令

通过Linux提供的帮助指令了解这个命令。
**man**[命令]

```shell
[root@VM-4-15-centos ~]# man ls
```

## echo

```
[root@VM-4-15-centos ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
```

## cat 、more、less



## head

用于显示文件开头部分内容，-n为指定显示多少行

```shell
[root@VM-4-15-centos ~]# head -n 5 felix
123
```

## tail

输出文件中尾部的内容

- tail 文件（查看文件后10行内容）
- tail -n 5 文件（查看文件后5行内容）
- **tail -f 文件**（实时追踪文件的所有更新）

## history

查看已经执行过的命令

```shell
[root@VM-4-15-centos ~]# history 5
  139  2020-11-17 17:49:34 ll
  140  2020-11-17 17:58:48 rm f -rf
  141  2020-11-17 17:58:50 ls
  142  2020-11-17 18:00:44 history
  143  2020-11-17 18:00:54 history 5
```

## ln

软链接也叫符号链接，类似于windows里面的快捷方式，主要存放了链接其他文件的路径

基本语法

```
ln -s[源文件或目录][软链接名] #给原文件创建一个软链接
```

实例

```shell
[root@VM-4-15-centos ~]# ln -s felix f
[root@VM-4-15-centos ~]# ll
total 8
drwxr-xr-x 11 root root 4096 Nov  2 21:03 Directory
lrwxrwxrwx  1 root root    5 Nov 17 17:49 f -> felix
```

删除软链接

```shell
[root@VM-4-15-centos ~]# rm f -rf
[root@VM-4-15-centos ~]# ls
Directory  felix  tencent.txt
```

## find

从指定目录向下递归遍历查找指定文件

语法：find [搜索范围] [选项]

- -name按指定文件名查找
- -user按文件拥有者查找
- -size按文件大小查找

```shell
[root@VM-4-15-centos ~]# find ~/ -name tencent.txt
/root/tencent.txt
```

## locate

locate 指令可以快速定位文件路径。locate 指令**利用事先建立的系统中所有文件名称及路径的locate 数据库**实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须**定期更新** locate 时刻

基础语法：locate 搜索文件

由于locate指令基于数据库查询，所以运行前，必须使用updatedb指令创建locate数据库

```shell
[root@VM-4-15-centos ~]# locate felix
/root/felix
/root/Directory/.idea/dictionaries/felixsfan.xml
```

## **grep 指令和 管道符号 |**

grep 过滤查找 ， 管道符：“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。
语法：grep [选项] 查找内容 源文件

- -n显示行号
- -i忽略大小写

在hello.txt中查找yes所在的行

```shell
cat hello.txt | grep yes
```

# 13. Linux 性能分析汇总

## 13.1 性能分析工具

首先来看一张图：

<img src="C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\性能分析工具汇总.png" style="zoom:50%;" />

上图是Brendan Gregg 的一次性能分析的分享，这里面的所有工具都可以通过man来获得它的帮助文档，下问简单介绍介绍一下常规的用法：

## 13.2 vmstat--虚拟内存统计

vmstat(VirtualMeomoryStatistics,虚拟内存统计) 是Linux中监控内存的常用工具,可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视。

vmstat的常规用法：vmstat interval times即每隔interval秒采样一次，共采样times次，如果省略times,则一直采集数据，直到用户手动停止为止。简单举个例子：

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\vmstat.png)

可以使用ctrl+c停止vmstat采集数据。

第一行显示了系统自启动以来的平均值，第二行开始显示现在正在发生的情况，接下来的行会显示每5秒间隔发生了什么，每一列的含义在头部，如下所示：

- procs：r这一列显示了多少进程在等待cpu，b列显示多少进程正在不可中断的休眠（等待IO）。
- memory：swapd列显示了多少块被换出了磁盘（页面交换），剩下的列显示了多少块是空闲的（未被使用），多少块正在被用作缓冲区，以及多少正在被用作操作系统的缓存。
- swap：显示交换活动：每秒有多少块正在被换入（从磁盘）和换出（到磁盘）。
- io：显示了多少块从块设备读取（bi）和写出（bo）,通常反映了硬盘I/O。
- system：显示每秒中断(in)和上下文切换（cs）的数量。
- cpu：显示所有的cpu时间花费在各类操作的百分比，包括执行用户代码（非内核），执行系统代码（内核），空闲以及等待IO。

内存不足的表现：free  memory急剧减少，回收buffer和cacher也无济于事，大量使用交换分区（swpd）,页面交换（swap）频繁，读写磁盘数量（io）增多，缺页中断（in）增多，上下文切换（cs）次数增多，等待IO的进程数（b）增多，大量CPU时间用于等待IO（wa）

## 13.3 iostat--用于报告中央处理器统计信息

iostat用于报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入/输出统计信息，默认显示了与vmstat相同的cpu使用信息，使用以下命令显示扩展的设备统计：

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\iostat.png)

第一行显示的是自系统启动以来的平均值，然后显示增量的平均值，每个设备一行。

常见linux的磁盘IO指标的缩写习惯：rq是request,r是read,w是write,qu是queue，sz是size,a是verage,tm是time,svc是service。

- rrqm/s和wrqm/s：每秒合并的读和写请求，“合并的”意味着操作系统从队列中拿出多个逻辑请求合并为一个请求到实际磁盘。
- r/s和w/s：每秒发送到设备的读和写请求数。
- rsec/s和wsec/s：每秒读和写的扇区数。
- avgrq –sz：请求的扇区数。
- avgqu –sz：在设备队列中等待的请求数。
- await：每个IO请求花费的时间。
- svctm：实际请求（服务）时间。
- %util：至少有一个活跃请求所占时间的百分比。

## 13.4 dstat--系统监控工具

dstat显示了cpu使用情况，磁盘io情况，网络发包情况和换页情况，输出是彩色的，可读性较强，相对于vmstat和iostat的输入更加详细且较为直观。在使用时，直接输入命令即可，当然也可以使用特定参数。

如下：dstat –cdlmnpsy

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\dstat.png)

## 13.5 iotop--LINUX进程实时监控工具

iotop命令是专门显示硬盘IO的命令，界面风格类似top命令，可以显示IO负载具体是由哪个进程产生的。是一个用来监视磁盘I/O使用状况的top类工具，具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息。

可以以非交互的方式使用：

```
iotop –bod interval，查看每个进程的I/O，可以使用pidstat，pidstat –d instat
```

## 13.6 pidstat--监控系统资源情况

pidstat主要用于监控全部或指定进程占用系统资源的情况,如CPU,内存、设备IO、任务切换、线程等。

使用方法：

```
pidstat –d interval
#统计CPU使用信息
pidstat –u interval
#统计内存信息
Pidstat –r interval
```

## 13.7 top

top命令的汇总区域显示了五个方面的系统性能信息：

- 负载：时间，登陆用户数，系统平均负载；
- 进程：运行，睡眠，停止，僵尸；
- cpu:用户态，核心态，NICE,空闲，等待IO,中断等；
- 内存：总量，已用，空闲（系统角度），缓冲，缓存；
- 交换分区：总量，已用，空闲

任务区域默认显示：进程ID,有效用户，进程优先级，NICE值，进程使用的虚拟内存，物理内存和共享内存，进程状态，CPU占用率，内存占用率，累计CPU时间，进程命令行信息。

## 13.8 htop

htop 是Linux系统中的一个互动的进程查看器,一个文本模式的应用程序(在控制台或者X终端中),需要ncurses。

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\htop.png)

htop可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。

与top相比，htop有以下优点：

- 可以横向或者纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。
- 在启动上，比top更快。
- 杀进程时不需要输入进程号。
- htop支持鼠标操作。

## 13.9 mpstat

mpstat 是Multiprocessor Statistics的缩写，是实时系统监控工具。其报告与CPU的一些统计信息，这些信息存放在/proc/stat文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且能够查看特定CPU的信息。常见用法：

```
mpstat –P ALL interval times
```

## 13.10 netstat

Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。

常见用法：

```
netstat –npl   #可以查看你要打开的端口是否已经打开。
netstat –rn    #打印路由表信息。
netstat –in    #提供系统上的接口信息，打印每个接口的MTU,输入分组数，输入错误，输出分组数，输出错误，冲突以及当前的输出队列的长度。
```

## 13.11 ps--显示当前进程的状态

ps参数太多，具体使用方法可以参考man ps，

常用的方法：

```
ps  aux  #hsserver
ps –ef |grep #hundsun

#杀掉某一程序的方法
ps  aux | grep mysqld | grep –v grep | awk ‘{print $2 }’ xargs kill -9

#杀掉僵尸进程
ps –eal | awk ‘{if ($2 == “Z”){print $4}}’ | xargs kill -9
```

## 13.12 strace

跟踪程序执行过程中产生的系统调用及接收到的信号，帮助分析程序或命令执行中遇到的异常情况。

举例：查看mysqld在linux上加载哪种配置文件，可以通过运行下面的命令：

```
strace –e stat64 mysqld –print –defaults > /dev/null
```

## 13.13 uptime

能够打印系统总共运行了多长时间和系统的平均负载，uptime命令最后输出的三个数字的含义分别是1分钟，5分钟，15分钟内系统的平均负荷。

## 13.14 lsof

lsof(list open files)是一个列出当前系统打开文件的工具。通过lsof工具能够查看这个列表对系统检测及排错，常见的用法：

```
#查看文件系统阻塞  
lsof /boot

#查看端口号被哪个进程占用   
lsof  -i : 3306

#查看用户打开哪些文件   
lsof –u username

#查看进程打开哪些文件   
lsof –p  4838

#查看远程已打开的网络链接  
lsof –i @192.168.34.128
```

## 13.15 perf

perf是Linux kernel自带的系统性能优化工具。优势在于与Linux Kernel的紧密结合，它可以最先应用到加入Kernel的new feature，用于查看热点函数，查看cashe miss的比率，从而帮助开发者来优化程序性能。

性能调优工具如 perf，Oprofile 等的基本原理都是对被监测对象进行采样，最简单的情形是根据 tick 中断进行采样，即在 tick 中断内触发采样点，在采样点里判断程序当时的上下文。假如一个程序 90% 的时间都花费在函数 foo() 上，那么 90% 的采样点都应该落在函数 foo() 的上下文中。运气不可捉摸，但我想只要采样频率足够高，采样时间足够长，那么以上推论就比较可靠。因此，通过 tick 触发采样，我们便可以了解程序中哪些地方最耗时间，从而重点分析。

汇总：结合以上常用的性能测试命令并联系文初的性能分析工具的图，就可以初步了解到性能分析过程中哪个方面的性能使用哪方面的工具（命令）。

# 14. 任务调度

## 14.1 介绍

任务调度：是指系统在某个时间执行的特定的命令或程序。相当于Windows任务管理器。
任务调度分类：

1. 系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等
2. 个别用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份

语法：crontab [选项]

常用选项

- -e：编辑定时crontab任务
- -l：查询crontab任务
- -r：删除当前用户所有的crontab任务
- service crond restart：[重启任务调度]任务的要求

## 14.2 两种方式

设置任务调度文件：/etc/crontab

设置个人任务调度。执行 crontab –e 命令。接着输入任务到调度文件

## 14.3 案例要求

如：*/1 * * * * ls –l	/etc/ > /tmp/to.txt

意思说每小时的每分钟执行 ls –l /etc/ > /tmp/to.txt 命令

## 14.4 步骤如下

1) cron -e

2) */ 1 * * * * ls -l /etc >> /tmp/to.txt

3) 当保存退出后就程序。

4) 在每一分钟都会自动的调用 ls -l /etc >> /tmp/to.txt

## 14.5 参数细节说明

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\crontab参数格式.png)

# 15. 进程管理



# 16. ssh

## 16.1 ssh协议及其实现

- SSH全称是Secure Shell，SSH协议是基于应用层的协议，为远程登录会话和其他网络服务提供安全性的协议。SSH使用最多的是远程登录和传输文件，实现此功能的传统协议都不安全（ftp，telnet等），因为它们使用明文传输数据。而SSH在传输过程中的数据是加密的，安全性更高。

- **OpenSSH**是ssh协议的开源实现，CentOS默认安装

- SSH协议版本

  v1: 基于CRC-32做MAC，不安全；man-in-middle
  v2：双方主机协议选择安全的MAC方式
  基于DH算法做密钥交换，基于RSA或DSA实现身份认证

- 两种方式的用户登录认证（见putty远程登录）

  **基于password**
  **基于密钥**

- Openssh软件组成

  - 相关包3个：
    openssh ：通用文件包
    openssh-clients ：客户端，可执行文件一般在bin下
    openssh-server ：服务器端，可执行文件一般在sbin下，后面带字母d
  - 工具：
    基于C/S结构
    Linux Client: ssh, scp, sftp，slogin
    Windows Client：xshell, putty, securecrt, sshsecureshellclient
    Server: sshd

## 16.2 ssh常用命令

<!--以下以openssh为例-->

## 16.3 linux下的OpenSSH

**查看**

```shell
[root@VM-4-15-centos ~]# ssh
usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]
           [-D [bind_address:]port] [-E log_file] [-e escape_char]
           [-F configfile] [-I pkcs11] [-i identity_file]
           [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec]
           [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]
           [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]
           [user@]hostname [command]
```

**查看openssh的软件安装**

```shell
[root@VM-4-15-centos ~]rpm -qa|grep -E -w 'openssh'
openssh-7.4p1-21.el7.x86_64
openssh-clients-7.4p1-21.el7.x86_64
openssh-server-7.4p1-21.el7.x86_64
```

**连接命令**

应用见WeTerm

## 16.4 windows下的OpenSSH服务

```shell
C:\Users\felixsfan>ssh
usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]
           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]
           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]
           [-i identity_file] [-J [user@]host[:port]] [-L address]
           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]
           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]
           [-w local_tun[:remote_tun]] destination [command]
```

cmd连接服务器

```shell
ssh -p 22 root@49.234.42.199
```

## 16.5 登录linux实例

### 16.5.1 使用远程登录软件登录 Linux 实例

#### 16.5.1.1 操作场景

本文以 PuTTY 软件为例，介绍如何在 Windows 系统的本地计算机中使用远程登录软件登录 Linux 实例。

#### 16.5.1.2 适用本地操作系统

Windows

#### 16.5.1.3 鉴权方式

**密码**或**密钥**

#### 16.5.1.4 前提条件

- 您已获取登录实例的用户名及密码（或密钥）。
- 请确认本地计算机与实例之间的网络连通正常，以及实例的防火墙已放行22端口（创建实例时默认已开通22端口）。

#### 16.5.1.5 操作步骤

##### 使用密码登录

1. 下载 Windows 远程登录软件，即 PuTTY。
   PuTTY 的获取方式：[点此获取](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)

2. 双击【putty.exe】，打开 PuTTY 客户端。

3. 在 PuTTY Configuration 窗口中，输入以下内容。如下图所示：

   1. ![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\putty登录远程linux.png)

   参数举例说明如下：

   - Host Name（or IP address）：轻量应用服务器的公网 IP（登录 [轻量应用服务器控制台](https://console.cloud.tencent.com/lighthouse/instance/index)，可在服务器列表页中获取公网 IP）。
   - Port：轻量应用服务器的连接端口，必须设置为22。
   - Connect type：选择 “SSH”。
   - Saved Sessions：填写会话名称，例如 test。
     配置 “Host Name” 后，再配置 “Saved Sessions” 并保存，则后续使用时您可直接双击 “Saved Sessions” 下保存的会话名称即可登录服务器。

4. 单击【Open】，进入 “PuTTY” 的运行界面，提示 “login as:”。

5. 在 “login as” 后输入用户名，如 `root`，按 **Enter**。

6. 在 “Password” 后输入密码，按 **Enter**。

##### 使用密钥登录

1. 下载 Windows 远程登录软件，即 PuTTy。
   请分别下载 putty.exe 和 puttygen.exe 软件，PuTTy 的获取方式：[点此获取](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)。

2. 使用PuTTY安装目录里的puttygen.exe工具生成公密钥

   <img src="C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\生成公密钥.png" style="zoom:50%;" />

3. 将生成的公钥保存到对应机器上 ~/.ssh/authorized_keys 文件

4. 将生成的私钥保存到本地机器上

   <img src="C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\putty秘钥登录.png" style="zoom:50%;" />

5. Putty→会话:将服务器IP填好

   Putty→连接→数据:填好自动登陆用户名

   Putty→连接→SSH→认证:选择认证私钥文件（setup3保存的密钥文件）

   回到Putty→会话:保存的会话

   ![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\putty1.png)

   ![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\putty2.png)

   - Host Name (IP address)：轻量应用服务器的公网 IP（登录 [轻量应用服务器控制台](https://console.cloud.tencent.com/lighthouse/instance/index)，可在服务器列表页中获取公网 IP）。
   - Port：轻量应用服务器的连接端口，必须设置为22。
   - Connect type：选择 “SSH”。
   - Saved Sessions：填写会话名称，例如 test。
     配置 “Host Name” 后，再配置 “Saved Sessions” 并保存，则后续使用时您可直接双击 “Saved Sessions” 下保存的会话名称即可登录服务器。

6. 单击【Open】，进入 “PuTTY” 的运行界面，提示 “login as:”。

7. 在 “login as” 后输入用户名，如 `root`，按 **Enter**。

8. 若按照 [步骤4](https://cloud.tencent.com/document/product/1207/44578#Step4) 设置了加密私钥的密码，则请输入后按 **Enter**，密码默认不显示。如下图所示：

#### 16.5.2 使用 SSH 登录 Linux 实例

##### 16.5.2.1 操作场景

本文介绍如何在 Linux、Mac OS 或者 Windows 系统的本地计算机中通过 SSH 登录 Linux 实例。

##### 16.5.2.2 适用本地操作系统

Linux、Mac OS 或 Windows（Windows 10 和 Windows Server 2019 版本）

##### 16.5.2.3鉴权方式

**密码**或**密钥**

##### 16.5.2.4 前提条件

- 您已获取登录实例的用户名（自定义用户名或默认用户名 root）及密码（或密钥）。
- 请确认本地计算机与实例之间的网络连通正常，以及实例的防火墙已放行22端口（创建实例时默认已开通22端口）。

##### 16.5.2.5 操作步骤

###### 使用密码登录

1. 执行以下命令，连接 Linux 云服务器。

   - 如果您的本地计算机使用非桌面版的 Linux 系统，可直接在系统界面执行以下命令。
   - 如果您的本地计算机使用桌面版 Linux 系统或 MacOS 系统，请先打开系统自带的终端（如 MacOS 的 Terminal），再执行以下命令。
   - 如果您的本地电脑为 Windows 10 或 Windows Server 2019 系统，需先打开命令提示符（CMD），再执行以下命令。

   ```shell
   ssh <username>@<IP address or domain name>
   #username 即为前提条件中已获取的用户名，如root、ubuntu等。
   #IP address or domain name 为您的 Linux 实例公网 IP 地址或自定义域名。
   ```

2. 输入已获取的密码，按 **Enter**，即可完成登录。

###### 使用密钥登录

1. 在你安装ssh后，自带了一个ssh-genkey的工具生成公钥和私钥。

2. 生成秘钥

   ```shell
   ssh-keygen -t rsa
   ```

   <img src="C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\ssh生成秘钥.png" style="zoom:50%;" />

   生成之后会在用户的根目录生成一个 “.ssh”的文件夹

   <img src="C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\生成ssh文件夹.png" style="zoom:50%;" />

   进入“.ssh”会生成以下几个文件

   ![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\ssh文件夹内容.png)

3. authorized_keys:存放远程免密登录的公钥,主要通过这个文件记录多台机器的公钥

   - id_rsa : 生成的私钥文件
   - id_rsa.pub ： 生成的公钥文件
   - know_hosts : 已知的主机公钥清单

   如果希望ssh公钥生效需满足至少下面两个条件：

   - .ssh目录的权限必须是700 

   - .ssh/authorized_keys文件权限必须是600

4. 我们只要把 id_rsa.pub里面的公钥添加到目的服务器 `~./.ssh/`文件夹下的 authorized_keys文件中就可以了

   ```shell
   ssh-copy-id hodoop102
   输入密码
   ```

   登录

   ```shell
   ssh hadoop102
   ```

5. 同样你可以把公钥上传到其他服务器，这样用同一个私钥就可以登录多台服务器了。

6. **ssh无密登录区分用户权限，每一个用户都需要配置无密登录**

## 16.6 authorized_keys和known_hosts

### 16.6.1 authorized_keys

我们需要本地机器ssh访问远程服务器时为了减少输入密码的步骤，基本上都会在本地机器生成ssh公钥，然后将本地ssh公钥复制到远程服务器的.ssh/authorized_keys中，这样就可以免密登录了。（ 服务器之间访问同理）。
流程如下

本机生成 ssh公钥；
复制本机公钥到远程服务器.ssh/authorized_keys中，authorized_keys文件不存在则创建；
本机直接ssh连接远程；
结束

### 16.6.2 known_hosts

第一次连接远程数据库时我们可以发现我们本地的.ssh/目录下多了一个文件known_hosts，里面有我们刚刚连接的服务器的信息（如果以前就存在known_hosts，则会发现多了刚刚连接的服务器的信息）。
known_hosts文件每连接一个新的远程服务器都会产生一份数据，如下：

0.0.0.0 ecdsa-sha2-nistp256 AAAA...........=
1
包括远程机器ip、远程机器公钥
known_hosts有什么用？
手动修改一下远程机器A的密钥，然后再连接远程机器A，提示：

The authenticity of host '0.0.0.0 (0.0.0.0)' can't be established.
ECDSA key fingerprint is SHA256:xxxxxxxx.
Are you sure you want to continue connecting (yes/no)?
1
2
3
得到类似这种提示，大概意思就是登录远程机器A验证失败，然后向你确定是否需要继续连接。
known_hosts的作用就很明显了，known_hosts的作用就是记录你曾经远程连接过的机器信息。如果远程机器信息不变，则直接连接，如果改变了ssh就会问你一下，小子，你还连不连了？
如果你yes， 他就重新保存一份到known_hosts文件了。

## 16.7 WETERM登录机器和数据库

登录机器

![](C:\Users\felixsfan\Desktop\踩过的坑\images\登录机器.png)

铁将军不需要用户名密码，需要提前申请权限即可

![](C:\Users\felixsfan\Desktop\踩过的坑\images\铁将军.png)

跳板机登录机器

![](C:\Users\felixsfan\Desktop\踩过的坑\images\跳板机.png)

![](C:\Users\felixsfan\Desktop\踩过的坑\images\跳板机2.png)

登录数据库

```shell
mysql -usett -psett@1234 -h9.88.10.64 -P15114 --default-character-set=utf8
```

一般是登录到网络策略符合的机器再去登录数据库

1.先配置用跳板机

![](C:\Users\felixsfan\Desktop\踩过的坑\images\登录数据库1.png)

2.通过跳板机登录铁将军机器，再登录沙箱测试数据库

![](C:\Users\felixsfan\Desktop\踩过的坑\images\登录数据库2.png)

## 16.8 Linux限制某些用户或IP登录SSH、允许特定IP登录SSH

https://www.cnblogs.com/eos666/p/10684902.html

### **限制用户SSH登录**

1. 只允许指定用户进行登录（白名单）

   在/etc/ssh/sshd_config配置文件中设置AllowUsers选项，（配置完成需要重启 SSHD 服务）格式如下：

   ```
   AllowUsers azureuser oracle@172.0.0.14 oracle@127.0.0.1
   
   ssh仅允许azureuser用户登录
   oracle用户仅允许本地IP地址172.0.0.14和127.0.0.1登录
   ```

2. 只拒绝指定用户进行登录（黑名单）：

   在/etc/ssh/sshd_config配置文件中设置DenyUsers选项，（配置完成需要重启SSHD服务）格式如下： 

   ```
   DenyUsers    jenkins   nginx    #Linux系统账户        
   # 拒绝 jenkins、nginx 帐户通过 SSH 登录系统
   ```

   重启SSH

   ```
   service sshd reload    # centos 6.x
   systemctl reload sshd  # centos 7.x
   ```

### **限制IP SSH登录**

**说明：这里的IP是指客户端IP，不是服务器IP，下面的例子使用了hosts.allow文件的配置方式，目的是快，但也有不灵活的，建议改成iptables的方案。
**

除了可以禁止某个用户登录，我们还可以针对**固定的IP进行禁止登录**，linux 服务器通过设置**/etc/hosts.allow**和**/etc/hosts.deny**这个两个文件，hosts.allow许可大于hosts.deny可以限制或者允许某个或者某段IP地址远程 SSH 登录服务器，方法比较简单，且设置后立即生效，不需要重启SSHD服务，具体如下：

/etc/hosts.allow添加

```
sshd:192.168.0.1:allow  #允许 192.168.0.1 这个IP地址SSH登录
sshd:192.168.0.:allow #允许192.168.0.1/24这段IP地址的用户登录，多个网段可以以逗号隔开，比如192.168.0.,192.168.1.:allow
```

/etc/hosts.allow添加

```
sshd:ALL #允许全部的ssh登录 
```

hosts.allow和hosts.deny两个文件同时设置规则的时候，**hosts.allow文件中的规则优先级高**，按照此方法设置后服务器只允许192.168.0.1这个IP地址的SSH登录，其它的IP都会拒绝。

/etc/hosts.deny添加

```
sshd:ALL #拒绝全部IP
```

# 17. 防火墙

查看防火墙状态

```shell
firewall-cmd --state
```

停止firewall

```shell
systemctl stop firewalld.service
```

禁止firewall开机启动

```shell
systemctl disable firewalld.service 
```

开启防火墙

```shell
systemctl start firewalld.service
```

开启8080端口

```shell
firewall-cmd --zone=public --add-port=8080/tcp --permanent；开启8080端口

 

　　--zone=public：表示作用域为公共的；

　　--add-port=8080/tcp：添加tcp协议的端口8080；

　　--permanent：永久生效，如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效
```

查看端口号占用

```shell
netstat -pan | grep 8080
```

# 18. MySQL常用指令

## 18.1 mysql数据库如何赋予远程某个IP访问权限

```mysql
例一：
1. 授权用户root使用密码root从任意主机连接到mysql服务器：
代码如下:
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;
flush privileges;

2.授权用户root使用密码root从指定ip为47.94.15.114的主机连接到mysql服务器：
代码如下:
GRANT ALL PRIVILEGES ON *.* TO 'root'@'47.94.15.114' IDENTIFIED BY 'root' WITH GRANT OPTION;
flush privileges;
例二：
#授权只读（mysql 5.7）
grant select on *.* to 'zabbix'@'localhost' identified by 'zabbix';

#授权读写所有权限（mysql 5.7）
grant all privileges on zabbix.* to 'zabbix'@'192.168.40.131' identified by 'mysqlZ125!' ;

grant all privileges on *.* to 'root'@'192.168.40.1' identified by '123456' ;

flush privileges;
例三：
#授权所有用户连接
#mysql 5.7
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'youpassword' WITH GRANT OPTION;

#mysql 8.0
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';

flush privileges;
```

## 18.2 查看授权用户IP

https://blog.csdn.net/qq_45004192/article/details/100120000

```mysql
select user,host from mysql.user;
```

![](C:\Users\felixsfan\Desktop\办公机备份\踩过的坑\images\MYSQL授权IP.png)

## 18.3 mysql创建表

```mysql
CREATE TABLE t_quanminkge_jiaochang_detail_data (
  date varchar(10) NOT NULL DEFAULT '',
  seq_no varchar(64) NOT NULL DEFAULT '',
  tran_type varchar(32) NOT NULL DEFAULT '',
  real_tran_amt double(15,4) NOT NULL DEFAULT '0.0000',
  tran_amt double(15,4) NOT NULL DEFAULT '0.0000',
  fpay_chan varchar(10) NOT NULL DEFAULT '',
  spoa_id varchar(20) NOT NULL DEFAULT '',
  posid varchar(20) NOT NULL DEFAULT '',
  source_top varchar(20) NOT NULL DEFAULT '',
  PRIMARY KEY (date,seq_no)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
```

## 18.4 mysql查询建表语

```sql
show create table;
```

## 18.5 查询表的字段信息

```sql
desc t_cp_sett_task;
```

## 18.6 查到的结构旋转90度变成纵向 

```mysql
select * from t_source_6666 limit 1 \G;
```

## 18.7 mysql修改表



## 18.8 mysql导出sql文件



## 18.9 Linux安装MySQL、卸载MySQL、查看MySQL安装路径

见尚硅谷课件

# 19. Python

## 19.1 windows环境

### 19.1.1 win10下python2和python3同时存在

分别修改python.exe为python2.exe和python3.exe,同时配置到环境变量中，建立软连接

### 19.1.2 python2和python3同时存在时pip的使用

https://www.cnblogs.com/yanqingxu/p/10735011.html

#### **Windows pip升级**

```shell
python -m pip install -U pip   # python2.x
python -m pip3 install -U pip    # python3.x
```

## 19.2 Linux环境

### **19.2.1 安装python模块**

python安装第三方模块的方式

1. whl包的安装：pip install **.whl(要有pip 和 下载好的whl文件)

2. tar.gz包的安装：python setup.py install (先将tar.gz解压到指定文件夹，在地址栏输入cmd)

3. pip install <PACKAGE-NAME>
4. easy_install <PACKAGE-NAME>

#### 19.2.1.1 easy_install

easy_install是由PEAK(Python Enterprise Application Kit)开发的setuptools包里带的一个命令，它用来安装egg包。制作和安装egg包？

##### 安装setuptools

ubuntu:

```shell
sudo apt-get install python-setuptools
```

centos:

```shell 
yum install -y setuptool
```

##### 使用

```shell
easy_install <PACKAGE-NAME>
```

##### 安装pip

```shell
easy_install pip
```

##### egg包

python的egg文件有点像java中的jar文件或者压缩包，是一个工程打包文件，便于安装部署。

而setuptools就是一个提供包管理的工具或者说是软件。

###### 制作

1.首先是制作一个干净的目录用于打包，本例中就简单粗暴的定义为~/project目录，要打包的package就命名为spawn-egg（注：这里只是用来Demo的名字，命名方式并不适合所有的python环境）。目录结构如下：

```shell
ilab@iLab-Dev:~/project$ find ./
./
./spawn-egg
./spawn-egg/Base.pyc
./spawn-egg/hello.py
./spawn-egg/Base.py
./spawn-egg/__init__.py
```

2.然后就是制作一个setup.py脚本，与其说是脚本，这个文件更像是一个配置文件

```shell
vi ~/project/setup.py
#文件内容
from setuptools import setup, find_packages

setup(
 name = "spawn-egg",
 version="0.1.0",
 packages = find_packages(),
 description = "test how to make eggs",
 author = "Litrin J.",
 author_email = "XXX@gmail.com",

 license = "GPL",
 keywords = ("test", "python"),
 platforms = "Independant",
 url = "",
 )
```

就是一个setup函数，入参真心不少，好在字面上很容易理解它的用途，总结起来就这几个比较常用：

- name：就是名字了
- version：版本号
- packages：包含的package，setuptools自带了一个find_packages()工具可以自动从name同名的folder下找到package。
- description：对于这个包的描述，如果描述内容很长，可以把这里当成摘要，更详细的内容使用long_description参数
- author/author_email：作者和邮箱
- keywords：关键字，便于发布到pip上，用于搜索。

3.准备打包环境。打包环境需要setuptools

4.生成egg

```shell
ilab@iLab-Dev:~/project$ python setup.py bdist_egg
running bdist_egg
running egg_info
creating spawn_egg.egg-info
writing spawn_egg.egg-info/PKG-INFO
...
reading manifest file 'spawn_egg.egg-info/SOURCES.txt'
writing manifest file 'spawn_egg.egg-info/SOURCES.txt'
installing library code to build/bdist.linux-x86_64/egg
running install_lib
running build_py
creating build
creating build/lib.linux-x86_64-2.7
creating build/lib.linux-x86_64-2.7/spawn-egg
...
creating dist
creating 'dist/spawn_egg-0.1.0-py2.7.egg' and adding 'build/bdist.linux-x86_64/egg' to it
removing 'build/bdist.linux-x86_64/egg' (and everything under it)
```

egg文件已经在dist文件夹下生成好了，其实就是一个zip文件包

###### 安装

```shell
ilab@iLab-Dev:~/project/dist$ sudo easy_install spawn_egg-0.1.0-py2.7.egg
[sudo] password for ilab:
Processing spawn_egg-0.1.0-py2.7.egg
creating /usr/local/lib/python2.7/dist-packages/spawn_egg-0.1.0-py2.7.egg
Extracting spawn_egg-0.1.0-py2.7.egg to /usr/local/lib/python2.7/dist-packages
Adding spawn-egg 0.1.0 to easy-install.pth file

Installed /usr/local/lib/python2.7/dist-packages/spawn_egg-0.1.0-py2.7.egg
Processing dependencies for spawn-egg==0.1.0
Finished processing dependencies for spawn-egg==0.1.0
```



#### 19.2.1.2 wheel安装

wheel文件本质上就是zip或者rar,我们可以使用pip install wheel 安装wheel,比egg+easy_install要先进

在安装了wheel之后我们可以使用pip install XXX.whl来安装.whl的文件了

1.下载 whl 文件

可以从下面；两个网站找到自己需要的whl文件，部分文件在国内网站上没有，pypi网站上是最全的。

pypi网站：https://pypi.python.org/pypi/

国内whl集合网：https://www.lfd.uci.edu/~gohlke/pythonlibs/

2.安装 whl 文件

```python
pip install wordcloud-1.3.3-cp36-cp36m-win32.whl
```

##### 案例：pip命令下载不了mysqldb

可以自己下载下来。whl文件，然后安装

**下载地址**http://www.lfd.uci.edu/~gohlke/pythonlibs/

![](C:\Users\felixsfan\Desktop\办公机备份\学习\linux\images\mysqldb下载.png)

#### 19.2.1.3 setup.py 安装

##### **引入内容**

```python
python setup.py sdist   #将自己的python文件打包

python setup.py install #安装第三方包
```

##### setup.py工作原理

setup.py文件可以对module文件进行打包和安装

详情如下：

打包module需要新建一个setup.py的脚本（作者自己建的），然后在脚本中输入下面的代码，假设你要打包的module名称为str.py

```shell
from distutils.core import setup
setup(name = 'str',
      version = '1.0',
      py_modules = ['str'],
     )
```

具体打包和安装过程详看下面的步骤

##### **注意点**

用setup.py安装的python包卸载， 必须手动删除，而且也容易出错

##### **打包步骤**

1. 准备一个python文件/felix/str.py

   代码如下：

   ```python
   list = ('liu','888','bin')
   print(list*2)
   dict = {}
   dict['one'] = 1
   dict['two'] = 2
   print(dict)
   print(dict.values())
   ```

2. 在准备一个python.py文件/felix/setup.py

   代码如下：

   ```python
   from setuptools import setup
   setup(
   name='str',
   version='0.1',
   py_modules=['str'],
   author='liu',
   )
   ```

3. dos命令下进入到felix目录下

   E:\PycharmProjects>cd felix

4. 执行python setup.py [sdist](javascript:;)命令

   E:\PycharmProjects\felix>python setup.py [sdist](javascript:;)

   运行结果如下：

   ```python
   running sdist
   running egg_info
   creating str.egg-info
   writing str.egg-info\PKG-INFO
   writing dependency_links to str.egg-info\dependency_links.txt
   writing top-level names to str.egg-info\top_level.txt
   writing manifest file 'str.egg-info\SOURCES.txt'
   reading manifest file 'str.egg-info\SOURCES.txt'
   writing manifest file 'str.egg-info\SOURCES.txt'
   warning: sdist: standard file not found: should have one of README, README.rst, README.txt
   running check
   warning: check: missing required meta-data: url
   warning: check: missing meta-data: if 'author' supplied, 'author_email' must be supplied too
   creating str-0.1
   creating str-0.1\str.egg-info
   copying files to str-0.1...
   copying setup.py -> str-0.1
   copying str.py -> str-0.1
   copying str.egg-info\PKG-INFO -> str-0.1\str.egg-info
   copying str.egg-info\SOURCES.txt -> str-0.1\str.egg-info
   copying str.egg-info\dependency_links.txt -> str-0.1\str.egg-info
   copying str.egg-info\top_level.txt -> str-0.1\str.egg-info
   Writing str-0.1\setup.cfg
   creating dist
   Creating tar archive
   removing 'str-0.1' (and everything under it)
   ```

5. 进入E:\PycharmProjects\felix目录，会发现多了一个文件夹dist，此文件夹下面多了一个str-0.1.tar.gz的压缩包，这个压缩包里面就是felix目录下的项目代码

##### **安装第三方包步骤**

本地学习安装上面那个我自己的第三方包str-0.1.tar.gz

安装命令python setup.py [install](javascript:;)

如下安装步骤：

1. 获取str-0.1.tar.gz 并解压到指定的目录我这里解压到E:\PycharmProjects目录下解压后E:\PycharmProjects\str-0.1

2. dos命令下进入到str-0.1 然后执行python setup.py [install](javascript:;) ，通过查看你会发现几乎每个python第三方包中都有这个setup.py文件，这个文件是作者打包时设置的文件，而我们安装第三方包时，也是先进入到setup.py文件所在目录，然后执行python setup.py install

   ```shell
   E:\PycharmProjects\str-0.1>python setup.py install
   ```

说明：

一般第三方包安装时先执行python setup.py build命令 在执行 python setup.py install命令

#### 19.2.1.4 pip安装模块

使用 pip 有一些额外的优势，pip 将自动下载包的所有依赖项。相反，如果使用的是 setup.py，则需要手动搜索和下载依赖项

easy_install 和 pip 都是用来管理、下载安装公共资源库pypi的相关资源包，
pip是easy_install的改进版

##### 1.可以访问外网直接

```shell
pip install kafka
pip3 install kafka
```

##### 2.使用镜像

下载超时需要使用国内镜像，并声明可靠站点

- 使用豆瓣镜像

```shell
pip install wheel -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com
```

- 公司镜像


```shell
 --index-url https://mirrors.cloud.tencent.com/pypi/simple/ --extra-index-url https://mirrors.tencent.com/repository/pypi/tencent_pypi/simple/ 
```

示例

```shell
[root@felixsfan1603804403293-0 /]# pip install kafka --index-url https://mirrors.cloud.tencent.com/pypi/simple/  --extra-index-url https://mirrors.tencent.com/repository/pypi/tencent_pypi/simple/
Collecting kafka
  Downloading https://mirrors.cloud.tencent.com/pypi/packages/21/71/73286e748ac5045b6a669c2fe44b03ac4c5d3d2af9291c4c6fc76438a9a9/kafka-1.3.5-py2.py3-none-any.whl (207kB)
    100% |################################| 215kB 4.7MB/s 
Installing collected packages: kafka
Successfully installed kafka-1.3.5
```

### 19.2.2 centos下安装python3，保留python2

由于ubuntu系统自带python2.7（默认）和python3.4，所以不需要自己安装python

#### 步骤

一.查看是否已经安装Python

 **CentOS 7.2 默认安装了python2.7.5** 因为一些命令要用它比如yum 它使用的是python2.7.5。

使用 python -V 命令查看一下是否安装Python

然后使用命令 which python 查看一下Python可执行文件的位置

```shell
[felixsfan@VM-242-103-centos /usr/bin]$ which python
/usr/bin/python
```

 可见**可执行文件**在/usr/bin/ 目录下，切换到该目录下执行 ll python* 命令查看  

```shell
[felixsfan@VM-242-103-centos /usr/bin]$ ll python*
lrwxrwxrwx 1 root root    7 Jun 19  2018 python -> python2
lrwxrwxrwx 1 root root    9 Jun 19  2018 python2 -> python2.7
-rwxr-xr-x 1 root root 4864 Feb 22  2016 python2.6
-rwxr-xr-x 1 root root 7136 Nov 20  2015 python2.7
```

 python 指向的是python2.7 

安装python3不需要管自带的python2

二.安装python3

1.官网下载python3源文件,上传到服务器并解压到相应目录 地址:https://www.python.org/getit/

或wget命令直接下载python3

```shell
wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz
```

2.个人习惯安装在/usr/local/python3 

a.创建目录

```shell 
# mkdir -p /usr/local/python3
```

b.解压下载好的Python-3.x.x.tgz包(具体包名因你下载的Python具体版本不不同⽽而不不同，如：我下载的是Python3.5.0.那我这里就是Python-3.5.0.tgz)

```shell
tar -zxvf Python-3.5.0.tgz
```

c.进入解压后的目录，编译安装。（编译安装前需要安装编译器yum install gcc，原因是源文件需要GCC编译成可执行文件）

```shell
# cd Python-3.6.1
# ./configure --prefix=/usr/local/python3   #/usr/local/python3为安装目录
# make
# make install
```

d.建立python3的软链

```shell 
#建立python3软链接
ln -s /usr/local/python3/bin/python3 /usr/bin/python3
```

e. 并将/usr/local/python3/bin加入PATH 

```shell
# vim ~/.bash_profile
# .bash_profile
# Get the aliases and functions
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
# User specific environment and startup programs
PATH=$PATH:$HOME/bin:/usr/local/python3/bin
export PATH
```

f.让上一步修改生效

```shell
source ~/.bash_profile
```

g.分别查看python2/3的路径

```shell
[root@VM-242-103-centos /usr/bin]# which python
/usr/bin/python
[root@VM-242-103-centos /usr/bin]# which python3
/usr/local/bin/python3
```

h.查看引用

python2和python3完成后

```shell
[root@VM-242-103-centos /usr/bin]# ll python*
lrwxrwxrwx 1 root root    7 Oct 26 17:32 python -> python2
lrwxrwxrwx 1 root root   14 Oct 26 17:32 python-config -> python2-config
lrwxrwxrwx 1 root root    9 Oct 26 17:32 python2 -> python2.7
lrwxrwxrwx 1 root root   16 Oct 26 17:32 python2-config -> python2.7-config
-rwxr-xr-x 1 root root 4864 Feb 22  2016 python2.6
-rwxr-xr-x 1 root root 7144 Sep 18 09:56 python2.7
-rwxr-xr-x 1 root root 1835 Sep 18 09:55 python2.7-config
lrwxrwxrwx 1 root root   30 Oct 26 17:08 python3 -> /usr/local/python3/bin/python3
```

#### ./configure,make,make install的作用

./configure是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。
make是用来编译的，它从Makefile中读取指令，然后编译。
make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。

AUTOMAKE和AUTOCONF是非常有用的用来发布C程序的东西。

\-----
1、configure，这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure –prefix=/usr 意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin),资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。

2、make，这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。

3、make insatll，这条命令来进行安装（当然有些软件需要先运行 make check 或 make test 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。

\-----
Linux的用户可能知道，在Linux下安装一个应用程序时，一般先运行脚本configure，然后用make来编译源程序，在运行make install，最后运行make clean删除一些临时文件。使用上述三个自动工具，就可以生成configure脚本。运行configure脚本，就可以生成Makefile文件，然后就可以运行make、make install和make clean。

configure是一个shell脚本，它可以自动设定源程序以符合各种不同平台上Unix系统的特性，并且根据系统叁数及环境产生合适的Makefile文件或是C的头文件(header file)，让源程序可以很方便地在这些不同的平台上被编译连接。

#### configure --prefix=/”的作用

1、如果不指定 `--prefix`

则 安装程序的

可执行文件默认放在 `/usr/local/bin` ；
库文件默认放在 `/usr/local/lib` ；
配置文件默认放在 `/usr/local/etc` ；
其它的资源文件放在 `/usr /local/share` 

2、如果指定 `--prefix`

比如： `--prefix=/usr/local/keepalived` ，则此软件的所有文件都放到 `/usr/local/keepalived` 目录下，很整齐

### **19.2.3 python2和python3共存时pip问题**

#### 默认

python3安装好后自带pip3,知道pip路径,可以添加软链接区分开

centos自带的python2没有安装pip,需要自己安装

#### 安装pip

目前如果你在 [python.org](https://www.python.org/) 下载最新版本的安装包，则是已经自带了该工具。

Python 2.7.9 + 或 Python 3.4+ 以上版本都自带 pip 工具。

pip 官网：https://pypi.org/project/pip/

##### 方法一:软件包管理工具

python-dev或python-devel称为是python的开发包，

其中包括了一些用C/Java/C#等编写的python扩展在编译的时候依赖的头文件等信息。

比如我们在编译一个用C语言编写的python扩展模块时，因为里面会有#include<Python.h>等这样的语句，因此我们就需要先安装python-devel开发包。

安装pip并自动关联python2

```shell
sudo yum -y install python3-devel
sudo yum -y install python-pip
```

安装pip3并自动关联python3

```shell
sudo yum -y install python3-pip
```

部分 Linux 发行版用包管理器安装 pip，如 Debian 和 Ubuntu

```shell
$ sudo apt-get install python-pip
```

##### 方法二：脚本安装

```shell
$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py   # 下载安装脚本
$ sudo python get-pip.py    # 运行安装脚本
```

*用哪个版本的 Python 运行安装脚本，pip 就被关联到哪个版本，如果是 Python3 则执行以下命令：*

```shell
$ sudo python3 get-pip.py    # 运行安装脚本。
```

*一般情况 pip 对应的是 Python 2.7，pip3 对应的是 Python 3.x*

##### 方法三：源码包安装

下载地址：https://pypi.org/search/?q=pip

```shell
wget --no-check-certific ate https://pypi.python.org/packages/source/p/pip/pip-10.0.1.tar.gz >>/dev/null
tar -zvxf pip-10.0.1.tar.gz >> /dev/null
cd pip.10.0.1
python3 setup.py build
python3 setup.py install
```

注意，这里是安装到python3中，默认是安装到python所链接的具体版本中。

#### 结果

python2使用pip

```shell
[root@VM-242-103-centos /usr/bin]# pip -V
pip 8.1.2 from /usr/lib/python2.7/site-packages (python 2.7)
```

python3使用pip3

```shell
[root@VM-242-103-centos /usr/bin]# pip3 -V
pip 9.0.1 from /usr/local/python3/lib/python3.6/site-packages (python 3.6)
```

#### pip升级

```
pip install --upgrade pip    # python2.x
pip3 install --upgrade pip   # python3.x
```



### 19.2.4 常用命令

#### **linux下查看python 安装目录**



```shell
方法1：whereis python 
查看所有python的路径，不止一个

方法2：which python 
查看当前使用的python路径
```

#### 查看PYTHONPATH路径

```shell
echo $PYTHONPATH
```

#### python添加模块路径

解决模块不在python的搜索路径下的问题

<https://www.cnblogs.com/crazymagic/p/9132309.html>

##### 方法一

```shell
export PYTHONPATH=$PYTHONPATH:/home/felix/workspace/reconciliation:/home/felix/workspace/reconciliation/src/0001
```

也可以修改配置文件（永久生效）

##### 方法二

```shell
>>> import sys  
>>> sys.path.append('路径')  
```

#### **如何查看python安装包路径**

1. 对于linux平台来说，很多运行的系统软件都是建立在python的基础之上，如果python出错了，那么整个系统可能会有出现重大问题的风险。Linux自带python2.7,例如devcloud

   ```shell
   [felixsfan@VM-242-103-centos ~/workspace/rebate_proj/zk_task]$ python 
   Python 2.7.5 (default, Sep 18 2020, 09:55:20) 
   [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2
   Type "help", "copyright", "credits" or "license" for more information.
   >>> 
   ```

2. python命令能够正确执行后，我们先找到python命令的位置，查找python的命令是：

   ```shell
   [felixsfan@VM-242-103-centos ~/workspace/rebate_proj/zk_task]$ whereis python
   python: /usr/bin/python2.7 /usr/bin/python2.7-config /usr/bin/python /usr/bin/python2.6 /usr/lib/python2.7 /usr/lib/python2.6 /usr/lib64/python2.7 /usr/lib64/python2.6 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz
   ```

3. 然后我们再根据这个命令来找到它的安装包是哪个，命令是：rpm -qf /usr/bin/python

   ```shell
   [felixsfan@VM-242-103-centos ~/workspace/rebate_proj/zk_task]$ rpm -qf /usr/bin/python
   python-2.7.5-89.tl2.x86_64
   ```

   

4. 然后我们就可以根据python的安装包，找到它的所有文件安装路径了，查询安装包的所有文件路径命令是：

   rpm -ql python-2.7.5

   ```shell
   [felixsfan@VM-242-103-centos ~/workspace/rebate_proj/zk_task]$ rpm -ql python-2.7.5
   /usr/bin/pydoc
   /usr/bin/python
   /usr/bin/python2
   /usr/bin/python2.7
   /usr/libexec/platform-python
   /usr/share/doc/python-2.7.5
   /usr/share/doc/python-2.7.5/LICENSE
   /usr/share/doc/python-2.7.5/README
   /usr/share/man/man1/python.1.gz
   /usr/share/man/man1/python2.1.gz
   /usr/share/man/man1/python2.7.1.gz
   ```

#### 常见错误

##### AttributeError: 'module' object has no attribute 'XXXX'

网上大概两种说法：1.XXX.pyc文件的存在；2.文件名和python关键字相同

而我的问题是Directory下的程序访问了另一个程序的的同名模块，原因是linux的PYTHONPATH路径搜索问题

查看PYTHONPATH路径

```shell
echo $PYTHONPATH
```

##### 找不到module

```python
C:\Python27\python.exe D:/python2.7/cloud_account_data_analysis/src/email.py
Traceback (most recent call last):
  File "D:/python2.7/cloud_account_data_analysis/src/email.py", line 10, in <module>
    import smtplib
  File "C:\Python27\lib\smtplib.py", line 46, in <module>
    import email.utils
  File "D:\python2.7\cloud_account_data_analysis\src\email.py", line 11, in <module>
    import email.utils
ImportError: No module named utils
```

检查模块在python搜索路径下，后来发现我自定义模块和第三方库同名

### 19.2.5 python2和python3共存时，相关文件和pip位置

#### python相关文件

```
[root@VM-4-15-centos ~]# whereis python
python: /usr/bin/python3.6m /usr/bin/python3.6 /usr/bin/python /usr/bin/python2.7-config /usr/bin/python2.7 /usr/lib/python3.6 /usr/lib/python2.7 /usr/lib64/python3.6 /usr/lib64/python2.7 /etc/python /usr/include/python3.6m /usr/include/python2.7 /usr/share/man/man1/python.1.gz
```

#### pip模块库位置

```shell
[root@VM-4-15-centos ~]# pip -V
pip 8.1.2 from /usr/lib/python2.7/site-packages (python 2.7)
[root@VM-4-15-centos ~]# pip3 -V
pip 9.0.3 from /usr/lib/python3.6/site-packages (python 3.6)
```

#### python2相关文件位置

```shell
[root@VM-4-15-centos ~]# cd /usr/lib64/python2.7
[root@VM-4-15-centos python2.7]# ls
_abcoll.py          copy_reg.py          HTMLParser.py          opcode.pyo          sched.pyo               tarfile.py
_abcoll.pyc         copy_reg.pyc         HTMLParser.pyc         optparse.py         sets.py                 tarfile.pyc
_abcoll.pyo         copy_reg.pyo         HTMLParser.pyo         optparse.pyc        sets.pyc                tarfile.pyo
abc.py              cProfile.py          httplib.py             optparse.pyo        sets.pyo                telnetlib.py
abc.pyc             cProfile.pyc         httplib.pyc            os2emxpath.py       sgmllib.py              telnetlib.pyc
abc.pyo             cProfile.pyo         httplib.pyo            os2emxpath.pyc      sgmllib.pyc             telnetlib.pyo
aifc.py             crypt.py             idlelib                os2emxpath.pyo      sgmllib.pyo             tempfile.py
aifc.pyc            crypt.pyc            ihooks.py              os.py               sha.py                  tempfile.pyc
aifc.pyo            crypt.pyo            ihooks.pyc             os.pyc              sha.pyc                 tempfile.pyo
antigravity.py      csv.py               ihooks.pyo             os.pyo              sha.pyo                 test
```

#### python3相关文件位置

```shell
[root@VM-4-15-centos python2.7]# cd /usr/lib64/python3.6
[root@VM-4-15-centos python3.6]# ls
abc.py                        dbm                 lib2to3            pyclbr.py         sunau.py
aifc.py                       decimal.py          lib-dynload        py_compile.py     symbol.py
antigravity.py                difflib.py          linecache.py       _pydecimal.py     symtable.py
argparse.py                   dis.py              locale.py          pydoc_data        _sysconfigdata_dm_linux_x86_64-linux-gnu.py
ast.py                        distutils           logging            pydoc.py          _sysconfigdata_m_linux_x86_64-linux-gnu.py
asynchat.py                   doctest.py          lzma.py            _pyio.py          sysconfig.py
asyncio                       dummy_threading.py  macpath.py         queue.py          tabnanny.py
asyncore.py                   _dummy_thread.py    macurl2path.py     quopri.py         tarfile.py
base64.py                     email               mailbox.py         random.py         telnetlib.py
bdb.py                        encodings           mailcap.py         reprlib.py        tempfile.py
binhex.py                     ensurepip           _markupbase.py     re.py             test
bisect.py                     enum.py             mimetypes.py       rlcompleter.py    textwrap.py
_bootlocale.py                filecmp.py          modulefinder.py    runpy.py          this.py
```

#### python可执行文件和软链接位置

```shell
[root@VM-4-15-centos python3.6]# cd /usr/bin
[root@VM-4-15-centos bin]# ll python*
lrwxrwxrwx 1 root root     7 Aug  5 15:32 python -> python2
lrwxrwxrwx 1 root root     9 Aug  5 15:32 python2 -> python2.7
-rwxr-xr-x 1 root root  7144 Apr  2  2020 python2.7
-rwxr-xr-x 1 root root  1835 Apr  2  2020 python2.7-config
lrwxrwxrwx 1 root root    16 Aug  5 15:33 python2-config -> python2.7-config
lrwxrwxrwx 1 root root     9 Sep  2 14:22 python3 -> python3.6
-rwxr-xr-x 2 root root 11336 Apr  2  2020 python3.6
-rwxr-xr-x 2 root root 11336 Apr  2  2020 python3.6m
lrwxrwxrwx 1 root root    14 Aug  5 15:33 python-config -> python2-config
```

#### pip可执行文件和软链接位置

```shell
[root@VM-4-15-centos bin]# ll pip*
-rwxr-xr-x 1 root root 282 Sep  3 14:03 pip
-rwxr-xr-x 1 root root 284 Sep  3 14:03 pip2
-rwxr-xr-x 1 root root 288 Sep  3 14:03 pip2.7
-rwxr-xr-x 1 root root 407 Mar 18  2020 pip3
lrwxrwxrwx 1 root root   9 Sep  2 14:22 pip-3 -> ./pip-3.6
lrwxrwxrwx 1 root root   8 Sep  2 14:22 pip-3.6 -> ./pip3.6
-rwxr-xr-x 1 root root 407 Mar 18  2020 pip3.6
```

### **19.2.6 linux删除python**

```shell
rpm -qa|grep python|xargs rpm -ev --allmatches --nodeps        #强制删除已安装程序及其关联
whereis python|xargs rm -frv 　　　　　　　　　　　　　　　　　　　　 #删除所有残余文件 #xargs，允许你对输出执行其他某些命令
```

### 19.2.7 Unix & Linux 平台安装 Python

以下为在 Unix & Linux 平台上安装 Python 的简单步骤：

- 打开 WEB 浏览器访问https://www.python.org/downloads/source/
- 选择适用 于Unix/Linux 的源码压缩包。
- 下载及解压压缩包。
- 如果你需要自定义一些选项修改*Modules/Setup*
- **执行** ./configure 脚本
- make
- make install

**执行以上操作后，Python 会安装在 /usr/local/bin 目录中，Python 库安装在 /usr/local/lib/pythonXX，XX 为你使用的 Python 的版本号。**

# 20. linux命令和shell的区别

**什么是shell，shell与linux命令的联系**

shell翻译成壳的意思，它是包裹在linux内核外层的、一个可通过一系列的linux命令对操作系统发出相关指令的人机界面。 shell可以通过其条件语句和循环语句等，把一系列linux命令结合在一起，形成一个相当于面向过程的程序，即shell script，来实现一些较为复杂的功能。

总括，shell是linux命令集的概称，是属于命令行的人机界面。shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。Shell 和Shell Script不是一回事，通常我们说的都是Shell Script。

由定义可知， shell相当于经过装饰的命令行，和命令行一样，都能操作linux。但是shell是面向过程的，相当于有了一定的逻辑和过程，而命令行只是单一的操作。

**shell与linux命令的区别**

1.直接在命令行执行，就是在当前的shell环境下执行，比如涉及到一些环境变量的时候，必须在当前shell环境里执行。

2.在脚本里执行的话，脚本执行的时候，会fork一个子进程，所有操作都在子进程进行。如果涉及到一些在脚本里设置环境变量的东西，脚本结束了，环境变量也就消失了。 如果是修改环境变量的话，需要特别注意下。

3.shell可以重复或批量地执行一些命令。你也可以把自己要重复执行的命令写到脚本里面执行。而命令行的话就需要一个一个的输入命令，相对而言麻烦一些。

**总结**

上面就是一些对于shell和命令行的对比。个人觉得除了非常专业的运维人员，对大多数开发人员来说，这两者的差别不大，也不影响大家对于linux系统的使用。