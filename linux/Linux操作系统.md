## 1.整体认识

## 1.1 Linux 启动

当计算机电源通电后，`BIOS`会进行`开机自检(Power-On-Self-Test, POST)`，对硬件进行检测和初始化。因为操作系统的启动会使用到磁盘、屏幕、键盘、鼠标等设备。下一步，磁盘中的第一个分区，也被称为 `MBR(Master Boot Record)` 主引导记录，被读入到一个固定的内存区域并执行。这个分区中有一个非常小的，只有 512 字节的程序。程序从磁盘中调入 boot 独立程序，boot 程序将自身复制到高位地址的内存从而为操作系统释放低位地址的内存。

复制完成后，boot 程序读取启动设备的根目录。boot 程序要理解文件系统和目录格式。然后 boot 程序被调入内核，把控制权移交给内核。直到这里，boot 完成了它的工作。系统内核开始运行。

内核启动代码是使用`汇编语言`完成的，主要包括创建内核堆栈、识别 CPU 类型、计算内存、禁用中断、启动内存管理单元等，然后调用 C 语言的 main 函数执行操作系统部分。

这部分也会做很多事情，首先会分配一个消息缓冲区来存放调试出现的问题，调试信息会写入缓冲区。如果调试出现错误，这些信息可以通过诊断程序调出来。

然后操作系统会进行自动配置，检测设备，加载配置文件，被检测设备如果做出响应，就会被添加到已链接的设备表中，如果没有相应，就归为未连接直接忽略。

配置完所有硬件后，接下来要做的就是仔细手工处理进程0，设置其堆栈，然后运行它，执行初始化、配置时钟、挂载文件系统。创建 `init 进程(进程 1 )` 和 `守护进程(进程 2)`。

init 进程会检测它的标志以确定它是否为单用户还是多用户服务。在前一种情况中，它会调用 fork 函数创建一个 shell 进程，并且等待这个进程结束。后一种情况调用 fork 函数创建一个运行系统初始化的 shell 脚本（即 /etc/rc）的进程，这个进程可以进行文件系统一致性检测、挂载文件系统、开启守护进程等。

然后 /etc/rc 这个进程会从 /etc/ttys 中读取数据，/etc/ttys 列出了所有的终端和属性。对于每一个启用的终端，这个进程调用 fork 函数创建一个自身的副本，进行内部处理并运行一个名为 `getty` 的程序。

getty 程序会在终端上输入

```shell
login:
```

等待用户输入用户名，在输入用户名后，getty 程序结束，登陆程序 `/bin/login` 开始运行。login 程序需要输入密码，并与保存在 `/etc/passwd` 中的密码进行对比，如果输入正确，login 程序以用户 shell 程序替换自身，等待第一个命令。如果不正确，login 程序要求输入另一个用户名。

整个系统启动过程如下

<img src="/Users/fanqingwei/Desktop/学习/linux/images/启动过程.png" style="zoom:50%;" />

## 1.2 Linux 接口

Linux 系统是一种金字塔模型的系统，如下所示

![](/Users/fanqingwei/Desktop/学习/linux/images/linux接口.png)


应用程序发起系统调用把参数放在寄存器中(有时候放在栈中)，并发出 `trap` 系统陷入指令切换用户态至内核态。因为不能直接在 C 中编写 trap 指令，因此 C 提供了一个库，库中的函数对应着系统调用。有些函数是使用汇编编写的，但是能够从 C 中调用。每个函数首先把参数放在合适的位置然后执行系统调用指令。因此如果你想要执行 read 系统调用的话，C 程序会调用 read 函数库来执行。这里顺便提一下，是由 POSIX 指定的库接口而不是系统调用接口。也就是说，POSIX 会告诉一个标准系统应该提供哪些库过程，它们的参数是什么，它们必须做什么以及它们必须返回什么结果。

除了操作系统和系统调用库外，Linux 操作系统还要提供一些标准程序，比如文本编辑器、编译器、文件操作工具等。直接和用户打交道的是上面这些应用程序。因此我们可以说 Linux 具有三种不同的接口：**「系统调用接口、库函数接口和应用程序接口」**

## 1.3 Linux系统调用

### 1.3.1 概念

**系统调用**，顾名思义，说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置定时器等。

从逻辑上来说，系统调用可被看成是一个内核与用户空间程序交互的接口——它好比一个中间人，把用户进程的请求传达给内核，待内核把请求处理完毕后再将处理结果送回给用户空间。

### 1.3.2 原因

系统服务之所以需要通过系统调用来提供给用户空间的根本原因是为了对系统进行“保护”，因为我们知道 Linux 的运行空间分为内核空间与用户空间，它们各自运行在不同的级别中，逻辑上相互隔离。所以用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用用户空间函数
但是很多情况下，用户进程需要获得系统服务（调用系统程序），这时就必须利用系统提供给用户的“特殊接口”——系统调用了，它的特殊性主要在于规定了用户进程进入内核的具体位置；换句话说，用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的陷入内核的统一访问路径限制才能保证内核安全无误。

### 1.3.3 系统调用的实现

系统调用是属于操作系统内核的一部分的，必须以某种方式提供给进程让它们去调用。CPU 可以在不同的特权级别下运行，而相应的操作系统也有不同的运行级别，用户态和内核态。运行在内核态的进程可以毫无限制的访问各种资源，而在用户态下的用户进程的各种操作都有着限制，比如不能随意的访问内存、不能开闭中断以及切换运行的特权级别。显然，属于内核的系统调用一定是运行在内核态下，但是如何切换到内核态呢？
答案是软件中断。软件中断和我们常说的中断（硬件中断）不同之处在于，它是通过软件指令触发而并非外设引发的中断，也就是说，又是编程人员开发出的一种异常（该异常为正常的异常）。操作系统一般是通过软件中断从用户态切换到内核态。     

中断有两个重要的属性，中断号和中断处理程序。中断号用来标识不同的中断，不同的中断具有不同的中断处理程序。在操作系统内核中维护着一个中断向量表（Interrupt Vector Table），这个数组存储了所有中断处理程序的地址，而中断号就是相应中断在中断向量表中的偏移量

### 1.3.4 系统调用和库函数的区别

<img src="/Users/fanqingwei/Desktop/学习/linux/images/系统调用1.png" style="zoom:50%;" />

系统调用是需要时间的，程序中频繁的使用系统调用会降低程序的运行效率。当运行内核代码时，CPU工作在内核态，在系统调用发生前需要保存用户态的栈和内存环境，然后转入内核态工作。系统调用结束后，又要切换回用户态。这种环境的切换会消耗掉许多时间。

### 1.3.5 其他一些常见的系统调用如下

| 系统调用指令 | 描述                             |
| :----------- | :------------------------------- |
| pause        | 挂起信号                         |
| nice         | 改变分时进程的优先级             |
| ptrace       | 进程跟踪                         |
| kill         | 向进程发送信号                   |
| pipe         | 创建管道                         |
| mkfifo       | 创建 fifo 的特殊文件（命名管道） |
| sigaction    | 设置对指定信号的处理方法         |
| msgctl       | 消息控制操作                     |
| semctl       | 信号量控制                       |



## 1.4 中断

### 分类

**内中断**（也称异常、例外、陷入）信号来源是CPU内部，与当前执行的指令有关，**外中断**（狭义的中断）信号的来源是CPU外部，与当前执行的指令无关。

**内中断**

内中断可以分为自愿中断和强迫中断，自愿中断是指指令中断，如系统调用时使用的访管指令（又叫陷入指令、trap指令），强迫中断是指硬件故和软件故障（如整数除0）

内中断还可以分为陷入（trap）、故障（fault）和终止（abort）。陷入指有意而为之的异常，如系统调用。故障指由错误条件引起的，可能被故障处理程序修复，如缺页。终止指不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除0。

**外中断**

外中断可以分为外设请求（如I/O操作完成发出的中断信号）和人工干预（如用户强行终止进程）。

### 外中断的处理过程

- 执行完每个指令之后，CPU都要检查当前是否有外部中断信号
- 如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器）
- 根据中断信号类型转入相应的中断处理程序
- 中断程序处理结束后，恢复原进程的CPU环境并退出中断，返回原进程继续往下执行程序

## 1.5 Linux 组成部分

事实上，Linux 操作系统可以由下面这几部分构成

- `引导程序(Bootloader)`：引导程序是管理计算机启动过程的软件，对于大多数用户而言，只是弹出一个屏幕，但其实内部操作系统做了很多事情
- `内核(Kernel)`：内核是操作系统的核心，负责管理 CPU、内存和外围设备等。
- `初始化系统(Init System)`：这是一个引导用户空间并负责控制守护程序的子系统。一旦从引导加载程序移交了初始引导，它就是用于管理引导过程的初始化系统。
- `后台进程(Daemon)`：后台进程顾名思义就是在后台运行的程序，比如打印、声音、调度等，它们可以在引导过程中启动，也可以在登录桌面后启动
- `图形服务器(Graphical server)`：这是在监视器上显示图形的子系统。通常将其称为 X 服务器或 X。
- `桌面环境(Desktop environment)`：这是用户与之实际交互的部分，有很多桌面环境可供选择，每个桌面环境都包含内置应用程序，比如文件管理器、Web 浏览器、游戏等
- `应用程序(Applications)`：桌面环境不提供完整的应用程序，就像 Windows 和 macOS 一样，Linux 提供了成千上万个可以轻松找到并安装的高质量软件。

## 1.6 Linux 应用程序

Linux 的命令行也就是 shell，它由大量标准应用程序组成。这些应用程序主要有下面六种

- 文件和目录操作命令
- 过滤器
- 文本程序
- 系统管理
- 程序开发工具，例如编辑器和编译器
- 其他

除了这些标准应用程序外，还有其他应用程序比如 **「Web 浏览器、多媒体播放器、图片浏览器、办公软件和游戏程序等」**。

我们在上面的例子中已经见过了几个 Linux 的应用程序，比如 sort、cp、ls、head

## 1.7 Linux 内核结构

在上面我们看到了 Linux 的整体结构，下面我们从整体的角度来看一下 Linux 的内核结构

![](/Users/fanqingwei/Desktop/学习/linux/images/linux内核结构.webp)

内核直接坐落在硬件上，内核的主要作用就是 I/O 交互、内存管理和控制 CPU 访问。上图中还包括了 `中断` 和 `调度器`，中断是与设备交互的主要方式。中断出现时调度器就会发挥作用。这里的低级代码停止正在运行的进程，将其状态保存在内核进程结构中，并启动驱动程序。进程调度也会发生在内核完成一些操作并且启动用户进程的时候。图中的调度器是 dispatcher

```shell
注意这里的调度器是 `dispatcher` 而不是 `scheduler`，这两者是有区别的

scheduler 和 dispatcher 都是和进程调度相关的概念，不同的是 scheduler 会从几个进程中随意选取一个进程；而 dispatcher 会给 scheduler 选择的进程分配 CPU注

```

然后，我们把内核系统分为三部分。

- I/O 部分负责与设备进行交互以及执行网络和存储 I/O 操作的所有内核部分。

从图中可以看出 I/O 层次的关系，最高层是一个`虚拟文件系统`，也就是说不管文件是来自内存还是磁盘中，都是经过虚拟文件系统中的。从底层看，所有的驱动都是字符驱动或者块设备驱动。二者的主要区别就是是否允许随机访问。网络驱动设备并不是一种独立的驱动设备，它实际上是一种字符设备，不过网络设备的处理方式和字符设备不同。

上面的设备驱动程序中，每个设备类型的内核代码都不同。字符设备有两种使用方式，有`一键式`的比如 vi 或者 emacs ，需要每一个键盘输入。其他的比如 shell ，是需要输入一行按回车键将字符串发送给程序进行编辑。

网络软件通常是模块化的，由不同的设备和协议来支持。大多数 Linux 系统在内核中包含一个完整的硬件路由器的功能，但是这个不能和外部路由器相比，路由器上面是`协议栈`，包括 TCP/IP 协议，协议栈上面是 socket 接口，socket 负责与外部进行通信，充当了门的作用。

磁盘驱动上面是 I/O 调度器，它负责排序和分配磁盘读写操作，以尽可能减少磁头的无用移动。

- I/O 右边的是内存部件，程序被装载进内存，由 CPU 执行，这里会涉及到虚拟内存的部件，页面的换入和换出是如何进行的，坏页面的替换和经常使用的页面会进行缓存。
- 进程模块负责进程的创建和终止、进程的调度、Linux 把进程和线程看作是可运行的实体，并使用统一的调度策略来进行调度。

在内核最顶层的是系统调用接口，所有的系统调用都是经过这里，系统调用会触发一个 trap，将系统从用户态转换为内核态，然后将控制权移交给上面的内核部件。

2.作业管理

# 2.作业管理

## 2.1 概念

- 作业是系统为完成一个用户的计算任务或一次事务处理所做的所有工作的总和
- *作业控制块(Job Control Block,JCB):记录与该作业有关的各种信息的登记表。是作业存在的唯一标识.*

## 2.2 状态

- 提交状态:作业由输入设备进入外存储器的过程.处于提交状态的作业,其信息正在进入系统

- 后备状态:当作业的全部信息进入外存后,系统就为该作业建立一个作业控制块(JCB)
- 执行状态.一个后备作业被作业调度程序选中,并分配了必要的资源病进入了内存,作业调度程序同时为其建立了相应的进程后,该作业就由后备状态变成了执行状态
-  完成状态:当作业正常运行结束,它所占用的资源未全部被系统回收时的状态

### 2.2.1 状态转换

作业有四种状态：提交、后备、执行和完成，操作系统通过作业控制块来实现状态的转换

![作业状态](/Users/fanqingwei/Desktop/学习/linux/images/作业状态.png)

后备转入执行,系统为作业创建一个作业进程**,**按照进程流程进行运行**,**作业终止后进入完成状态

![进程状态1](/Users/fanqingwei/Desktop/学习/linux/images/进程状态1.png)

## 2.3 作业调度算法

**先来先服务**

**最短作业算法**

**优先级调度**

**最高响应比优先**

# 3. Linux 进程和线程(重点)

系统调用是操作系统本身的接口，它对于创建进程和线程，内存分配，共享文件和 I/O 来说都很重要。

从各个版本的共性出发来进行探讨

## 3.1 进程概述

程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。**程序是静态的，进程是动态的**。

进程拥有自己独立的**处理环境**（如：当前需要用到哪些环境变量，程序运行的目录在哪，当前是哪个用户在运行此程序等）和**系统资源**

## 3.2 进程状态

![进程状态1](/Users/fanqingwei/Desktop/学习/linux/images/进程状态1.png)

**执行态-->阻塞态**

正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞态

**阻塞态-->就绪态**

处于等待态的进程，若其等待的事件发生，于是进程由等待状态变成就绪态

**就绪态-->执行态**

当就绪态的进程所等待的cpu时间片一到来，进程就会从就绪态变成执行态

**执行态-->就绪态**

处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出cpu，于是进程从执行状态转变成就绪状态

## 3.3 进程控制块

对于操作系统而言，它需要控制很多进程，同时，每个进程都有不同的状态，系统如何知道 A 执行完到 B 执行而不是 C？系统如何协调控制进程呢？

当我们运行一个程序使它成为一个进程时，系统会开辟一段内存空间存放与此进程相关的数据信息，而这个数据信息是通过结构体（task_struct）来存放，我们把这个存放进程相关数据信息的结构体称为进程控制块。

## 3.4 进程号

### 3.4.1 概念

**每个进程都由一个进程号来标识**，其类型为 pid_t（无符号整型），进程号的范围：0～32767。进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用。

系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。整个 Linux 系统的所有进程也是一个树形结构。树根是系统自动构造的，即在内核态下执行的 0 号进程，它是所有进程的祖先。进程号为 0 的进程通常是调度进程，常被称为交换进程( swapper )。由 0 号进程创建 1 号进程（内核态），1 号负责执行内核的部分初始化工作及进行系统配置，并创建若干个用于高速缓存和虚拟主存管理的内核线程。随后，1 号进程调用 execve() 运行可执行程序 init，并演变成用户态 1 号进程，即 init 进程。
**所以，在 Linux 下面所有的进程都由 init 进程直接或者间接创建。**

**进程号（PID）**
标识进程的一个非负整型数。

**父进程号（PPID）**
任何进程（ 除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。如，A 进程创建了 B 进程，A 的进程号就是 B 进程的父进程号。

**进程组号（PGID）**
进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID） 。这个过程有点类似于 QQ 群，组相当于 QQ 群，各个进程相当于各个好友，把各个好友都拉入这个 QQ 群里，主要是方便管理，特别是通知某些事时，只要在群里吼一声，所有人都收到，简单粗暴。但是，这个进程组号和 QQ 群号是有点区别的，默认的情况下，当前的进程号会当做当前的进程组号。

## 3.5 进程组

每个进程除了有一个进程ID之外，还属于一个进程组，那什么是进程组呢？

　　顾名思义，进程组就是一个或多个进程的集合。这些进程并不是孤立的，他们彼此之间或者存在父子、兄弟关系，或者在功能上有相近的联系。**每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构**。

　　那为啥Linux里要有进程组呢？其实，提供进程组就是为了方便对进程进行管理。假设要完成一个任务，需要同时并发100个进程。当用户处于某种原因要终止 这个任务时，要是没有进程组，就需要手动的一个个去杀死这100个进程，并且必须要严格按照进程间父子兄弟关系顺序，否则会扰乱进程树。有了进程组，就可以将这100个进程设置为一个进程组，它们共有1个组号（pgrp），并且有选取一个进程作为组长（通常是“辈分”最高的那个，通常该进程的ID也就作为进程组的ID）。现在就可以通过杀死整个进程组，来关闭这100个进程，并且是严格有序的。组长进程可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。

　　 进程必定属于一个进程组，也只能属于一个进程组。 一个进程组中可以包含多个进程。 进程组的生命周期从被创建开始，到其内所有进程终止或离开该组。

　　内核中，sys_getpgrp()系统调用用来获取当前进程所在进程组号；sys_setpgid(int pid, int pgid)调用用来设置置顶进程pid的进程组号为pgid。

## 3.5 可执行文件结构与进程结构

### 3.5.1 可执行文件结构

可执行文件在存储时（没有调入到内容）分为代码区（text）、数据区（data）和未初始化数据区（bss）3 个部分。各段基本内容说明如下：

**代码区**
存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。

代码区的指令包括操作码和操作对象（或对象地址引用）。如果是立即数（即是具体的数值），将直接包含在代码中，如果是局部数据，将在运行时在栈区分配空间，然后再引用该数据的地址，如果是未初始化数据区和数据区，在代码中同样将引用该数据的地址。

**全局初始化数据区/静态数据区（数据段）**

该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。

**未初始化数据区（又叫 BSS 区）**

存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。

### 3.5.2 Linux进程结构

![](/Users/fanqingwei/Desktop/学习/linux/images/进程结构.png)

**一个进程是一个运行着的程序段，一个进程主要包括在内存中申请的空间，代码（加载的程序，包括代码段，数据段，BSS），堆，栈，以及内核提供的内核进程信息结构体** 

task_struct 、打开的文件、上下文（指进程执行活动全过程的静态描述）信息以及挂起的信号等。

**（1）代码区（text segment）**。加载的是可执行文件代码段，其加载到内存中的位置由加载器完成。
**（2）全局初始化数据区/静态数据区（Data Segment）**。加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据）的数据的生存周期为整个程序运行过程。
**（3）未初始化数据区（BSS）**。加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。
**（4）栈区（stack）**。由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。
**（5）堆区（heap）**。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS回收。

系统之所以分成这么多个区域，主要基于以下考虑：

代码段和数据段分开，运行时便于分开加载，在哈佛体系结构的处理器将取得更好得流水线效率。
代码是依次执行的，是由处理器 PC 指针依次读入，而且代码可以被多个程序共享，数据在整个运行过程中有可能多次被调用，如果将代码和数据混合在一起将造成空间的浪费。
临时数据以及需要再次使用的代码在运行时放入栈中，生命周期短，便于提高资源利用率。
堆区可以由程序员分配和释放，以便用户自由分配，提高程序的灵活性。

### 3.5.3 结合JVM、java变量分配及python变量分配

![java变量分配](/Users/fanqingwei/Desktop/学习/linux/images/java变量分配.png)

![java虚拟机](/Users/fanqingwei/Desktop/学习/linux/images/java虚拟机.png)

### 3.5.4 线程中哪些变量存在安全性问题

#### 静态变量：线程非安全

**1、静态变量**：使用static关键字定义的变量。static可以修饰变量和方法，也有static静态代码块。被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。

用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它的类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。

**2、静态变量使用的场景：**

(1)对象间共享值时

(2)方便访问变量时

**3、静态方法使用注意事项：**

(1)不能在静态方法内使用非静态变量，即不能直接访问所属类的实例变量；

(2)不能在静态方法内直接调用非静态方法；

(3)静态方法中不能使用this和super关键字；

**4、结论**：静态变量也称为类变量，属于类对象所有，位于方法区，为所有对象共享，共享一份内存，一旦值被修改，则其他对象均对修改可见，故线程非安全。

#### 实例变量：单例时线程非安全，非单例时线程安全

**1、实例变量**：实例变量属于类对象的，也就是说，属于对象实例私有，在虚拟机的堆中分配。

**2、结论**：实例变量是实例对象私有的，系统单例模式只存在一个实例对象，则在多线程环境下，如果值改变后，则其它对象均可见，故线程非安全；如果每个线程都在不同的实例对象中执行，则对象与对象间的修改互不影响，故线程安全。

#### 局部变量：线程安全

**1、局部变量：**定义在方法内部的变量

**2、结论：**每个线程执行时都会把局部变量放在各自的帧栈的内存空间中，线程间不共享，故不存在线程安全问题

#### 静态方法的线程安全性

静态方法中如果没有使用静态变量，则没有线程安全的问题；

静态方法内的变量，每个线程调用时，都会新创建一份，不会公用一个存储单元，故不存在线程冲突的问题

## 3.6 程序计数器

每个进程都会运行一段独立的程序，并且在初始化的时候拥有一个独立的控制线程。换句话说，每个进程都会有一个自己的程序计数器，这个程序计数器用来记录下一个需要被执行的指令。Linux 允许进程在运行时创建额外的线程。

<img src="/Users/fanqingwei/Desktop/学习/linux/images/程序计数器.png" style="zoom:50%;" />

Linux 是一个多道程序设计系统，因此系统中存在彼此相互独立的进程同时运行。此外，每个用户都会同时有几个活动的进程。因为如果是一个大型系统，可能有数百上千的进程在同时运行。

## 3.7 Linux 进程和线程

### Linux 进程

在 Linux 内核结构中，进程会被表示为 `任务`，通过结构体 `structure` 来创建。不像其他的操作系统会区分进程、轻量级进程和线程，Linux 统一使用任务结构来代表执行上下文。因此，对于每个单线程进程来说，单线程进程将用一个任务结构表示，对于多线程进程来说，将为每一个用户级线程分配一个任务结构。Linux 内核是多线程的，并且内核级线程不与任何用户级线程相关联。

对于每个进程来说，在内存中都会有一个 `task_struct` 进程描述符与之对应。进程描述符包含了内核管理进程所有有用的信息，包括 **「调度参数、打开文件描述符等等」**。进程描述符从进程创建开始就一直存在于内核堆栈中。

Linux 和 Unix 一样，都是通过 `PID` 来区分不同的进程，内核会将所有进程的任务结构组成为一个双向链表。PID 能够直接被映射称为进程的任务结构所在的地址，从而不需要遍历双向链表直接访问。

我们上面提到了进程描述符，这是一个非常重要的概念，我们上面还提到了进程描述符是位于内存中的，这里我们省略了一句话，那就是进程描述符是存在用户的任务结构中，当进程位于内存并开始运行时，进程描述符才会被调入内存。

```
进程位于内存被称为 PIM(Process In Memory) ，这是冯诺伊曼体系架构的一种体现，加载到内存中并执行的程序称为进程。简单来说，一个进程就是正在执行的程序。
```

进程描述符可以归为下面这几类

- `调度参数(scheduling parameters)`：进程优先级、最近消耗 CPU 的时间、最近睡眠时间一起决定了下一个需要运行的进程
- `内存映像(memory image)`：我们上面说到，进程映像是执行程序时所需要的可执行文件，它由数据和代码组成。
- `信号(signals)`：显示哪些信号被捕获、哪些信号被执行
- `寄存器`：当发生内核陷入 (trap) 时，寄存器的内容会被保存下来。
- `系统调用状态(system call state)`：当前系统调用的信息，包括参数和结果
- `文件描述符表(file descriptor table)`：有关文件描述符的系统被调用时，文件描述符作为索引在文件描述符表中定位相关文件的 i-node 数据结构
- `统计数据(accounting)`：记录用户、进程占用系统 CPU 时间表的指针，一些操作系统还保存进程最多占用的 CPU 时间、进程拥有的最大堆栈空间、进程可以消耗的页面数等。
- `内核堆栈(kernel stack)`：进程的内核部分可以使用的固定堆栈
- `其他`：当前进程状态、事件等待时间、距离警报的超时时间、PID、父进程的 PID 以及用户标识符等

有了上面这些信息，现在就很容易描述在 Linux 中是如何创建这些进程的了，创建新流程实际上非常简单。**「为子进程开辟一块新的用户空间的进程描述符，然后从父进程复制大量的内容。为这个子进程分配一个 PID，设置其内存映射，赋予它访问父进程文件的权限，注册并启动」**。

当执行 fork 系统调用时，调用进程会陷入内核并创建一些和任务相关的数据结构，比如`内核堆栈(kernel stack)` 和 `thread_info` 结构。

> 关于 thread_info 结构可以参考
>
> https://docs.huihoo.com/doxygen/linux/kernel/3.7/arch_2avr32_2include_2asm_2thread__info_8h_source.html

这个结构中包含进程描述符，进程描述符位于固定的位置，使得 Linux 系统只需要很小的开销就可以定位到一个运行中进程的数据结构。

进程描述符的主要内容是根据`父进程`的描述符来填充。Linux 操作系统会寻找一个可用的 PID，并且此 PID 没有被任何进程使用，更新进程标示符使其指向一个新的数据结构即可。为了减少 hash table 的碰撞，进程描述符会形成`链表`。它还将 task_struct 的字段设置为指向任务数组上相应的上一个/下一个进程。

> task_struct ：Linux 进程描述符，内部涉及到众多 C++ 源码，我们会在后面进行讲解。

从原则上来说，为子进程开辟内存区域并为子进程分配数据段、堆栈段，并且对父进程的内容进行复制，但是实际上 fork 完成后，子进程和父进程没有共享内存，所以需要复制技术来实现同步，但是复制开销比较大，因此 Linux 操作系统使用了一种 `欺骗` 方式。即为子进程分配页表，然后新分配的页表指向父进程的页面，同时这些页面是只读的。当进程向这些页面进行写入的时候，会开启保护错误。内核发现写入操作后，会为进程分配一个副本，使得写入时把数据复制到这个副本上，这个副本是共享的，这种方式称为 `写入时复制(copy on write)`，这种方式避免了在同一块内存区域维护两个副本的必要，节省内存空间。

在子进程开始运行后，操作系统会调用 exec 系统调用，内核会进行查找验证可执行文件，把参数和环境变量复制到内核，释放旧的地址空间。

现在新的地址空间需要被创建和填充。如果系统支持映射文件，就像 Unix 系统一样，那么新的页表就会创建，表明内存中没有任何页，除非所使用的页面是堆栈页，其地址空间由磁盘上的可执行文件支持。新进程开始运行时，立刻会收到一个`缺页异常(page fault)`，这会使具有代码的页面加载进入内存。最后，参数和环境变量被复制到新的堆栈中，重置信号，寄存器全部清零。新的命令开始运行。

下面是一个示例，用户输出 ls，shell 会调用 fork 函数复制一个新进程，shell 进程会调用 exec 函数用可执行文件 ls 的内容覆盖它的内存。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQy1WGaMLqg7H8TV6Jd6Lqx9FdGp1j0HbQTpq3GmwYicWriaprubULUZaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### Linux 线程

现在我们来讨论一下 Linux 中的线程，线程是轻量级的进程，想必这句话你已经听过很多次了，`轻量级`体现在所有的进程切换都需要清除所有的表、进程间的共享信息也比较麻烦，一般来说通过管道或者共享内存，如果是 fork 函数后的父子进程则使用共享文件，然而线程切换不需要像进程一样具有昂贵的开销，而且线程通信起来也更方便。线程分为两种：用户级线程和内核级线程

#### 用户级线程

用户级线程避免使用内核，通常，每个线程会显示调用开关，发送信号或者执行某种切换操作来放弃 CPU，同样，计时器可以强制进行开关，用户线程的切换速度通常比内核线程快很多。在用户级别实现线程会有一个问题，即单个线程可能会垄断 CPU 时间片，导致其他线程无法执行从而 `饿死`。如果执行一个 I/O 操作，那么 I/O 会阻塞，其他线程也无法运行。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQ7xWcmN5ckaVRG3C2cbxAHKg0RPlU59TVia9PUatgmPB3OGk06QqvZgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

一种解决方案是，一些用户级的线程包解决了这个问题。可以使用时钟周期的监视器来控制第一时间时间片独占。然后，一些库通过特殊的包装来解决系统调用的 I/O 阻塞问题，或者可以为非阻塞 I/O 编写任务。

#### 内核级线程

内核级线程通常使用几个进程表在内核中实现，每个任务都会对应一个进程表。在这种情况下，内核会在每个进程的时间片内调度每个线程。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQFlf11vC57houOssnBYDFHDJm0qRMdyG2Wu0BP6dKle92jWicJ0DTnLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。

从用户空间 -> 内核空间 -> 用户空间的开销比较大，但是线程初始化的时间损耗可以忽略不计。这种实现的好处是由时钟决定线程切换时间，因此不太可能将时间片与任务中的其他线程占用时间绑定到一起。同样，I/O 阻塞也不是问题。

#### 混合实现

结合用户空间和内核空间的优点，设计人员采用了一种`内核级线程`的方式，然后将用户级线程与某些或者全部内核线程多路复用起来

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQibAKmae0rHnNZibGIR27jWIHSkQmzjd5OH6S2CMX6l6G0WNVHfjbf9Bw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。

## 3.8 Linux 调度

### 3.8.1 操作系统进程的调度算法

- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX操作系统采取的便是这种调度算法。
- **优先级调度** ：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以FCFS方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

### 3.8.2 Linux系统调度

下面我们来关注一下 Linux 系统的调度算法，首先需要认识到，Linux 系统的线程是内核线程，所以 Linux 系统是基于线程的，而不是基于进程的。

为了进行调度，Linux 系统将线程分为三类

- 实时先入先出
- 实时轮询
- 分时

实时先入先出线程具有最高优先级，它不会被其他线程所抢占，除非那是一个刚刚准备好的，拥有更高优先级的线程进入。实时轮转线程与实时先入先出线程基本相同，只是每个实时轮转线程都有一个时间量，时间到了之后就可以被抢占。如果多个实时线程准备完毕，那么每个线程运行它时间量所规定的时间，然后插入到实时轮转线程末尾。

> ❝
>
> 注意这个实时只是相对的，无法做到绝对的实时，因为线程的运行时间无法确定。它们相对分时系统来说，更加具有实时性
>
> ❞

Linux 系统会给每个线程分配一个 `nice` 值，这个值代表了优先级的概念。nice 值默认值是 0 ，但是可以通过系统调用 nice 值来修改。修改值的范围从 -20 - +19。nice 值决定了线程的静态优先级。一般系统管理员的 nice 值会比一般线程的优先级高，它的范围是 -20 - -1。

下面我们更详细的讨论一下 Linux 系统的两个调度算法，它们的内部与`调度队列(runqueue)` 的设计很相似。运行队列有一个数据结构用来监视系统中所有可运行的任务并选择下一个可以运行的任务。每个运行队列和系统中的每个 CPU 有关。

`Linux O(1)` 调度器是历史上很流行的一个调度器。这个名字的由来是因为它能够在常数时间内执行任务调度。在 O(1) 调度器里，调度队列被组织成两个数组，一个是任务**「正在活动」**的数组，一个是任务**「过期失效」**的数组。如下图所示，每个数组都包含了 140 个链表头，每个链表头具有不同的优先级。

<img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQKFHGLD5YOFKPSxF4vrFCmHsMnlIRb31709cJeL9rTJN5IBffkh8aLg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" style="zoom:50%;" />

大致流程如下：

调度器从正在活动数组中选择一个优先级最高的任务。如果这个任务的时间片过期失效了，就把它移动到过期失效数组中。如果这个任务阻塞了，比如说正在等待 I/O 事件，那么在它的时间片过期失效之前，一旦 I/O 操作完成，那么这个任务将会继续运行，它将被放回到之前正在活动的数组中，因为这个任务之前已经消耗一部分 CPU 时间片，所以它将运行剩下的时间片。当这个任务运行完它的时间片后，它就会被放到过期失效数组中。一旦正在活动的任务数组中没有其他任务后，调度器将会交换指针，使得正在活动的数组变为过期失效数组，过期失效数组变为正在活动的数组。使用这种方式可以保证每个优先级的任务都能够得到执行，不会导致线程饥饿。

在这种调度方式中，不同优先级的任务所得到 CPU 分配的时间片也是不同的，高优先级进程往往能得到较长的时间片，低优先级的任务得到较少的时间片。

这种方式为了保证能够更好的提供服务，通常会为 `交互式进程` 赋予较高的优先级，交互式进程就是`用户进程`。

Linux 系统不知道一个任务究竟是 I/O 密集型的还是 CPU 密集型的，它只是依赖于交互式的方式，Linux 系统会区分是`静态优先级` 还是 `动态优先级`。动态优先级是采用一种奖励机制来实现的。奖励机制有两种方式：**「奖励交互式线程、惩罚占用 CPU 的线程」**。在 Linux O(1) 调度器中，最高的优先级奖励是 -5，注意这个优先级越低越容易被线程调度器接受，所以最高惩罚的优先级是 +5。具体体现就是操作系统维护一个名为 `sleep_avg` 的变量，任务唤醒会增加 sleep_avg 变量的值，当任务被抢占或者时间量过期会减少这个变量的值，反映在奖励机制上。

> ❝
>
> O(1) 调度算法是 2.6 内核版本的调度器，最初引入这个调度算法的是不稳定的 2.5 版本。早期的调度算法在多处理器环境中说明了通过访问正在活动数组就可以做出调度的决定。使调度可以在固定的时间 O(1) 完成。
>
> ❞

O(1) 调度器使用了一种 `启发式` 的方式，这是什么意思？

> ❝
>
> 在计算机科学中，启发式是一种当传统方式解决问题很慢时用来快速解决问题的方式，或者找到一个在传统方法无法找到任何精确解的情况下找到近似解。
>
> ❞

O(1) 使用启发式的这种方式，会使任务的优先级变得复杂并且不完善，从而导致在处理交互任务时性能很糟糕。

为了改进这个缺点，O(1) 调度器的开发者又提出了一个新的方案，即 `公平调度器(Completely Fair Scheduler, CFS)`。CFS 的主要思想是使用一颗`红黑树`作为调度队列。

> ❝
>
> 数据结构太重要了。
>
> ❞

CFS 会根据任务在 CPU 上的运行时间长短而将其有序地排列在树中，时间精确到纳秒级。下面是 CFS 的构造模型

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQy2zU3onRpOs31WFJF9XnNdqek1LFRBMytu7MbXeoia6tdne8BUvEISg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

CFS 的调度过程如下：

CFS 算法总是优先调度哪些使用 CPU 时间最少的任务。最小的任务一般都是在最左边的位置。当有一个新的任务需要运行时，CFS 会把这个任务和最左边的数值进行对比，如果此任务具有最小时间值，那么它将进行运行，否则它会进行比较，找到合适的位置进行插入。然后 CPU 运行红黑树上当前比较的最左边的任务。

在红黑树中选择一个节点来运行的时间可以是常数时间，但是插入一个任务的时间是 `O(loog(N))`，其中 N 是系统中的任务数。考虑到当前系统的负载水平，这是可以接受的。

调度器只需要考虑可运行的任务即可。这些任务被放在适当的调度队列中。不可运行的任务和正在等待的各种 I/O 操作或内核事件的任务被放入一个`等待队列`中。等待队列头包含一个指向任务链表的指针和一个自旋锁。自旋锁对于并发处理场景下用处很大。

## 3.9 Linux 进程间通信

### 3.9.1 概述

进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。

但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。

**进程间通信的目的：**

数据传输：一个进程需要将它的数据发送给另一个进程。
通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。
进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

**Linux 操作系统支持的主要进程间通信的通信机制**

![进程间通信](/Users/fanqingwei/Desktop/学习/linux/images/进程间通信.png)

下面我们分别对其进行概述

### 3.9.2 信号 signal

信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送`异步事件信号`来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。

你可以在 Linux 系统上输入 `kill -l` 来列出系统使用的信号，下面是我提供的一些信号

![](/Users/fanqingwei/Desktop/学习/linux/images/系统使用的信号.png)

进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：`SIGSTOP` 和 `SIGKILL` 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。

操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。

例如：当进程收到 `SIGFPE` 浮点异常的信号后，默认操作是对其进行 `dump(转储)`和退出。信号没有优先级的说法。如果同时为某个进程产生了两个信号，则可以将它们呈现给进程或者以任意的顺序进行处理。

下面我们就来看一下这些信号是干什么用的

- SIGABRT 和 SIGIOT

SIGABRT 和 SIGIOT 信号发送给进程，告诉其进行终止，这个 信号通常在调用 C标准库的`abort()`函数时由进程本身启动

- SIGALRM 、 SIGVTALRM、SIGPROF

当设置的时钟功能超时时会将 SIGALRM 、 SIGVTALRM、SIGPROF 发送给进程。当实际时间或时钟时间超时时，发送 SIGALRM。当进程使用的 CPU 时间超时时，将发送 SIGVTALRM。当进程和系统代表进程使用的CPU 时间超时时，将发送 SIGPROF。

- SIGBUS

SIGBUS 将造成`总线中断`错误时发送给进程

- SIGCHLD

当子进程终止、被中断或者被中断恢复，将 SIGCHLD 发送给进程。此信号的一种常见用法是指示操作系统在子进程终止后清除其使用的资源。

- SIGCONT

SIGCONT 信号指示操作系统继续执行先前由 SIGSTOP 或 SIGTSTP 信号暂停的进程。该信号的一个重要用途是在 Unix shell 中的作业控制中。

- SIGFPE

SIGFPE 信号在执行错误的算术运算（例如除以零）时将被发送到进程。

- SIGUP

当 SIGUP 信号控制的终端关闭时，会发送给进程。许多守护程序将重新加载其配置文件并重新打开其日志文件，而不是在收到此信号时退出。

- SIGILL

SIGILL 信号在尝试执行非法、格式错误、未知或者特权指令时发出

- SIGINT

当用户希望中断进程时，操作系统会向进程发送 SIGINT 信号。用户输入 ctrl - c 就是希望中断进程。

- SIGKILL

SIGKILL 信号发送到进程以使其马上进行终止。与 SIGTERM 和 SIGINT 相比，这个信号无法捕获和忽略执行，并且进程在接收到此信号后无法执行任何清理操作，下面是一些例外情况

僵尸进程无法杀死，因为僵尸进程已经死了，它在等待父进程对其进行捕获

处于阻塞状态的进程只有再次唤醒后才会被 kill 掉

`init` 进程是 Linux 的初始化进程，这个进程会忽略任何信号。

SIGKILL 通常是作为最后杀死进程的信号、它通常作用于 SIGTERM 没有响应时发送给进程。

- SIGPIPE

SIGPIPE 尝试写入进程管道时发现管道未连接无法写入时发送到进程

- SIGPOLL

当在明确监视的文件描述符上发生事件时，将发送 SIGPOLL 信号。

- SIGRTMIN 至 SIGRTMAX

SIGRTMIN 至 SIGRTMAX 是`实时信号`

- SIGQUIT

当用户请求退出进程并执行核心转储时，SIGQUIT 信号将由其控制终端发送给进程。

- SIGSEGV

当 SIGSEGV 信号做出无效的虚拟内存引用或分段错误时，即在执行分段违规时，将其发送到进程。

- SIGSTOP

SIGSTOP 指示操作系统终止以便以后进行恢复时

- SIGSYS

当 SIGSYS 信号将错误参数传递给系统调用时，该信号将发送到进程。

- SYSTERM

我们上面简单提到过了 SYSTERM 这个名词，这个信号发送给进程以请求终止。与 SIGKILL 信号不同，该信号可以被过程捕获或忽略。这允许进程执行良好的终止，从而释放资源并在适当时保存状态。SIGINT 与SIGTERM 几乎相同。

- SIGTSIP

SIGTSTP 信号由其控制终端发送到进程，以请求终端停止。

- SIGTTIN 和 SIGTTOU

当 SIGTTIN 和SIGTTOU 信号分别在后台尝试从 tty 读取或写入时，信号将发送到该进程。

- SIGTRAP

在发生异常或者 trap 时，将 SIGTRAP 信号发送到进程

- SIGURG

当套接字具有可读取的紧急或带外数据时，将 SIGURG 信号发送到进程。

- SIGUSR1 和 SIGUSR2

SIGUSR1 和 SIGUSR2 信号被发送到进程以指示用户定义的条件。

- SIGXCPU

当 SIGXCPU 信号耗尽 CPU 的时间超过某个用户可设置的预定值时，将其发送到进程

- SIGXFSZ

当 SIGXFSZ 信号增长超过最大允许大小的文件时，该信号将发送到该进程。

- SIGWINCH

SIGWINCH 信号在其控制终端更改其大小（窗口更改）时发送给进程。

### 3.9.3 信号量

信号量是一个计数器,可以用来控制多个线程对共享资源的访问.,它不是用于交换大批数据,而用于多线程之间的同步.它常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源.因此,主要作为进程间以及同一个进程内不同线程之间的同步手段.

Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件sys/sem.h中。

```shell
semget函数 # 它的作用是创建一个新信号量或取得一个已有信号量
semop函数 # 它的作用是改变信号量的值
semctl函数 # 该函数用来直接控制信号量信息
```



### 3.9.4 无名管道 pipe

也叫无名管道

#### 无名管道特点

1、半双工，数据在同一时刻只能在一个方向上流动。

2、数据只能从管道的一端写入，从另一端读出。

3、写入管道中的数据遵循先入先出的规则。

4、管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息等。

5、管道不是普通的文件，不属于某个文件系统，其只存在于内存中。

6、管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。

7、从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据。

8、管道没有名字，只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用

9、**最主要的特点就是阻塞问题**，但是编程上可以设置非阻塞

10、未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。

#### shell 管道符

在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。**管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止**。shell 中的`|` 就是用管道实现的，当 shell 发现输出

```shell
sort <f | head
```

它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据

<img src="/Users/fanqingwei/Desktop/学习/linux/images/管道.png" style="zoom:50%;" />

管道实际上就是 `|`，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。

#### 管道的操作

int pipe(int filedes[2])

**功能**

创建无名管道。

**参数**

```
filedes: 为 int 型数组的首地址，其存放了管道的文件描述符 filedes[0]、filedes[1]。
```

当一个管道建立时，它会创建两个文件描述符 fd[0] 和 fd[1]。其中 fd[0] 固定用于读管道，而 fd[1] 固定用于写管道。一般文件 I/O 的函数都可以用来操作管道( lseek() 除外)。

**返回值**

```
成功：0

失败：-1
```

```C
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
 
int main(int argc, char *argv[])
{
	int fd_pipe[2] = {0};
	pid_t pid;
	
	if( pipe(fd_pipe) < 0 ){// 创建无名管道
		perror("pipe");
	}
	
	pid = fork(); // 创建进程
	if( pid < 0 ){ // 出错
		perror("fork");
		exit(-1);
	}
	
	if( pid == 0 ){ // 子进程
		char buf[] = "I am sunplus";
		// 往管道写端写数据
		write(fd_pipe[1], buf, strlen(buf));
		
		_exit(0);
	}else if( pid > 0){// 父进程
		wait(NULL);	// 等待子进程结束，回收其资源
		
		char str[50] = {0};
		
		// 从管理里读数据
		read(fd_pipe[0], str, sizeof(str));
		
		printf("str=[%s]\n", str); // 打印数据
	}
	
	return 0;
}
```

### 3.9.5 命名管道(先入先出队列 FIFO)

无名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了命名管道（FIFO），也叫有名管道、FIFO 文件。

命名管道（FIFO）不同于无名管道之处在于它提供了一个路径名与之关联，**以 FIFO 的文件形式存在于文件系统中**，这样，即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，**因此，通过 FIFO 不相关的进程也能交换数据**。

命名管道（FIFO)和无名管道（pipe）有一些特点是相同的，**不一样的地方在于**:

> 1、FIFO 在文件系统中作为一个特殊的文件而存在，但 FIFO 中的内容却存放在内存中。
>
> 2、当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。
>
> 3、FIFO 有名字，不相关的进程可以通过打开命名管道进行通信。

![](/Users/fanqingwei/Desktop/学习/linux/images/FIFO.png)

写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。



### 3.9.6 共享内存 shared memory

两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。

<img src="/Users/fanqingwei/Desktop/学习/linux/images/共享内存.png" style="zoom:50%;" />

在使用共享内存前，需要经过一系列的调用流程，流程如下

- 创建共享内存段或者使用已创建的共享内存段`(shmget())`
- 将进程附加到已经创建的内存段中`(shmat())`
- 从已连接的共享内存段分离进程`(shmdt())`
- 对共享内存段执行控制操作`(shmctl())`

### 3.9.7 消息队列 Message Queue

一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是`严格模式`， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 `非严格模式`，消息的顺序性不是非常重要。

### 3.9.8 套接字 Socket

还有一种管理两个进程间通信的是使用 `socket`，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如`TCP（传输控制协议）`或较低级别`UDP（用户数据报协议）`等基础协议的支持。

套接字有以下几种分类

- `顺序包套接字(Sequential Packet Socket)`：此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。
- `数据报套接字(Datagram Socket)`：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。
- `流式套接字(Stream Socket)`：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。
- `原始套接字(Raw Socket)`：可以使用原始套接字访问基础通信协议。

## 3.10 Linux 中进程管理系统调用

现在关注一下 Linux 系统中与进程管理相关的系统调用。在了解之前你需要先知道一下什么是系统调用。

操作系统为我们屏蔽了硬件和软件的差异，它的最主要功能就是为用户提供一种抽象，隐藏内部实现，让用户只关心在 GUI 图形界面下如何使用即可。操作系统可以分为两种模式

- 内核态：操作系统内核使用的模式
- 用户态：用户应用程序所使用的模式

我们常说的`上下文切换` 指的就是内核态模式和用户态模式的频繁切换。而`系统调用`指的就是引起内核态和用户态切换的一种方式，系统调用通常在后台静默运行，表示计算机程序向其操作系统内核请求服务。

系统调用指令有很多，下面是一些与进程管理相关的最主要的系统调用

### 3.10.1 fork

#### 3.10.1.1 介绍

**功能**

用于从一个已存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。

**参数**

无

**返回值**
成功：子进程中返回 0，父进程中返回子进程 ID。pid_t，为无符号整型。
失败：返回 -1。

**失败的两个主要原因是**

1）当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN。
2）系统内存不足，这时 errno 的值被设置为 ENOMEM。

#### 3.10.1.2 深入

![fork函数](/Users/fanqingwei/Desktop/学习/linux/images/fork函数.png)

使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用 fork() 函数的代价是很大的。

实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (Copy- On-Write，COW技术) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。

因为一个进程会 fork 很多子进程，子进程也会 fork 子进程，所以 PID 是非常重要的。我们把第一次调用 fork 后的进程称为 `原始进程`，一个原始进程可以生成一颗继承树

![](/Users/fanqingwei/Desktop/学习/linux/images/进程树.png)



#### 3.10.1.3 示例

子进程是父进程的一个复制品，可以简单认为父子进程的代码一样的。那大家想过没有，这样的话，父进程做了什么事情，子进程也做什么事情（如上面的例子），是不是不能实现满足我们实现多任务的要求呀，那我们是不是要想个办法区别父子进程呀，这就通过 fork() 的返回值。

fork() 函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是 0，而父进程的返回值则是新子进程的进程 ID。

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
 
int main(int argc, char *argv[])
{
	pid_t pid;
	pid = fork();
	
	if( pid < 0 ){	// 没有创建成功
		perror("fork");
	}
	
	if(0 == pid){ // 子进程
		while(1){
			printf("I am son\n");
			sleep(1);
		}
	}else if(pid > 0){ // 父进程
		while(1){
			printf("I am father\n");
			sleep(1);
		}
	}
	
	return 0;
}

```

通过运行结果，可以看到，父子进程各做一件事（各自打印一句话）。这里，我们只是看到只有一份代码，实际上，fork() 以后，有两个地址空间在独立运行着，有点类似于有两个独立的程序（父子进程）在运行着。需要注意的是，在子进程的地址空间里，子进程是从 fork() 这个函数后才开始执行代码。

一般来说，在 fork() 之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法

### 3.10.2 vfork

#### 3.10.2.1 介绍

**功能：**

vfork() 函数和 fork() 函数（fork()如何使用，请点此链接）一样都是在已有的进程中创建一个新的进程，但它们创建的子进程是有区别的。

**参数：**

无

**返回值：**

成功：子进程中返回 0，父进程中返回子进程 ID。pid_t，为无符号整型。

失败：返回 -1。

#### 3.10.2.2 区别

- fork()： 父子进程的执行次序不确定。

   vfork()：保证子进程先运行,在它调用 exec（进程替换） 或 exit（退出进程）之后父进程才可能被调度运行。

- fork()： 子进程拷贝父进程的地址空间，子进程是父进程的一个复制品。

  vfork()：子进程共享父进程的地址空间（准确来说，在调用 exec（进程替换） 或 exit（退出进程） 之前与父进程数据是共享的）

  ![vfork](/Users/fanqingwei/Desktop/学习/linux/images/vfork.png)

用 vfork() 创建进程，子进程里一定要调用 exec（进程替换） 或 exit（退出进程），否则，程序会出问题，没有意义。

### 3.10.3 exec

exec 系统调用用于执行驻留在活动进程中的文件，调用 exec 后，新的可执行文件会替换先前的可执行文件并获得执行。也就是说，调用 exec 后，会将旧文件或程序替换为新文件或执行，然后执行文件或程序。新的执行程序被加载到相同的执行空间中，因此进程的 `PID`不会修改，因为我们**「没有创建新进程，只是替换旧进程」**。但是进程的数据、代码、堆栈都已经被修改。如果当前要被替换的进程包含多个线程，那么所有的线程将被终止，新的进程映像被加载执行。

这里需要解释一下`进程映像(Process image)` 的概念

**「什么是进程映像呢」**？进程映像是执行程序时所需要的可执行文件，通常会包括下面这些东西

- **「代码段（codesegment/textsegment）」**

又称文本段，用来存放指令，运行代码的一块内存空间

此空间大小在代码运行前就已经确定

内存空间一般属于只读，某些架构的代码也允许可写

在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

- **「数据段（datasegment）」**

可读可写

存储初始化的全局变量和初始化的 static 变量

数据段中数据的生存期是随程序持续性（随进程持续性） 随进程持续性：进程创建就存在，进程死亡就消失

- **「bss 段（bsssegment）：」**

可读可写

存储未初始化的全局变量和未初始化的 static 变量

bss 段中的数据一般默认为 0

- **「Data 段」**

是可读写的，因为变量的值可以在运行时更改。此段的大小也固定。

- **「栈（stack）：」**

可读可写

存储的是函数或代码中的局部变量(非 static 变量)

栈的生存期随代码块持续性，代码块运行就给你分配空间，代码块结束，就自动回收空间

- **「堆（heap）：」**

可读可写

存储的是程序运行期间动态分配的 malloc/realloc 的空间

堆的生存期随进程持续性，从 malloc/realloc 到 free 一直存在

下面是这些区域的构成图

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQrdzMycWgsR1zHCPYrzanUU9Wc7libxmgcdJ42KWXuqUjtiaepribovqRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

exec 系统调用是一些函数的集合，这些函数是

- execl
- execle
- execlp
- execv
- execve
- execvp

下面来看一下 exec 的工作原理

1. 当前进程映像被替换为新的进程映像
2. 新的进程映像是你做为 exec 传递的灿睡
3. 结束当前正在运行的进程
4. 新的进程映像有 PID，相同的环境和一些文件描述符(因为未替换进程，只是替换了进程映像)
5. CPU 状态和虚拟内存受到影响，当前进程映像的虚拟内存映射被新进程映像的虚拟内存代替。

### 3.10.4 waitpid

当一个进程正常或异常终止时，内核就向其父进程发送 SIGCHLD 信号，相当于告诉父亲他哪个儿子挂了，而父进程可以通过 wait() 或 waitpid() 函数等待子进程结束，获取子进程结束时的状态，同时回收他们的资源（相当于，父亲听听死去儿子的遗言同时好好安葬它）。

wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。

#### 3.10.4.1 pid_t wait()

**功能**

等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。

在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块的信息（包括进程号、退出状态、运行时间等）。

调用 wait() 函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒（相当于继续往下执行）。

若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。

所以，wait()函数的主要功能为回收已经结束子进程的资源。

**参数**

status: 进程退出时的状态信息。

如果参数 status 的值不是 NULL，wait() 就会把子进程退出时的状态取出并存入其中，这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的。

这个退出信息在一个 int 中包含了多个字段，直接使用这个值是没有意义的，我们需要用宏定义取出其中的每个字段。

下面我们来学习一下其中最常用的两个宏定义，取出子进程的退出信息：

WIFEXITED(status)

如果子进程是正常终止的，取出的字段值非零。

WEXITSTATUS(status)

返回子进程的退出状态，退出状态保存在 status 变量的 8~16 位。在用此宏前应先用宏 WIFEXITED 判断子进程是否正常退出，正常退出才可以使用此宏。

**返回值**

成功：已经结束子进程的进程号

失败：-1

#### 3.10.4.2 pid_t waitpid()

**功能**

等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。

**参数**

pid: 参数 pid 的值有以下几种类型：

```shell
pid > 0 # 等待进程 ID 等于 pid 的子进程。
pid = 0 # 等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid 不会等待它。
pid = -1 # 等待任一子进程，此时 waitpid 和 wait 作用一样。
pid < -1 # 等待指定进程组中的任何子进程，这个进程组的 ID 等于 pid 的绝对值。
```

status: 进程退出时的状态信息。和 wait() 用法一样。

options: options 提供了一些额外的选项来控制 waitpid()。

```shell
0： # 同 wait()，阻塞父进程，等待子进程退出。

WNOHANG； #没有任何已经结束的子进程，则立即返回。

WUNTRACED： # 如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。（由于涉及到一些跟踪调试方面的知识，加之极少用到，这里就不多费笔墨了，有兴趣的读者可以自行查阅相关材料）
```

**返回值**


waitpid() 的返回值比 wait() 稍微复杂一些，一共有 3 种情况：

当正常返回的时候，waitpid() 返回收集到的已经子进程的进程号；

如果设置了选项 WNOHANG，而调用中 waitpid() 发现没有已退出的子进程可等待，则返回 0；

如果调用中出错，则返回 -1，这时 errno 会被设置成相应的值以指示错误所在，如：当 pid 所对应的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid() 就会出错返回，这时 errno 被设置为 ECHILD；

#### 3.10.4.3 示例

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
 
int main(int argc, char *argv[])
{
	pid_t pid;
	
	pid = fork(); // 创建进程
	if( pid < 0 ){ // 出错
		perror("fork");
		exit(0);
	}
	
	if( pid == 0 ){// 子进程
		int i = 0;
		for(i=0;i<5;i++)
		{
			printf("this is son process\n");
			sleep(1);
		}
		
		_exit(2); // 子进程退出，数字 2 为子进程退出的状态
		
	}else if( pid > 0){ // 父进程
		
		int status = 0;
		
		// 等待子进程结束，回收子进程的资源
		// 此函数会阻塞
		// status 某个字段保存子进程调用 _exit(2) 的 2，需要用宏定义取出
		wait(&status); 
		// waitpid(-1, &status, 0); // 和 wait() 没区别，0：阻塞
		// waitpid(pid, &status, 0); // 指定等待进程号为 pid 的子进程， 0 阻塞
		// waitpid(pid, &status, WNOHANG); // WNOHANG：不阻塞
		if(WIFEXITED(status) != 0){ // 子进程是否正常终止
			printf("son process return %d\n", WEXITSTATUS(status));
		}
		
		printf("this is father process\n");	
	}
	
	return 0;
}
```



### 3.10.5 exit

在许多计算机操作系统上，计算机进程的终止是通过执行 `exit` 系统调用命令执行的。0 表示进程能够正常结束，其他值表示进程以非正常的行为结束。

exit() 和 _exit() 函数功能和用法是一样的，无非时所包含的头文件不一样，还有的区别就是：exit()属于标准库函数，_exit()属于系统调用函数。

![exit](/Users/fanqingwei/Desktop/学习/linux/images/exit.png)

下面的例子验证调用 exit() 函数，会刷新 I/O 缓冲区

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
 
int main(int argc, char *argv[])
{
	printf("hi,you are so good"); // 打印，没有换行符"\n"
	
	exit(0);      // 结束进程，标准库函数，刷新缓冲区，printf()的内容能打印出来
	// _exit(0);  // 结束进程，系统调用函数，printf()的内容不会显示到屏幕
	
	while(1);	// 不让程序结束
 
	return 0;
}
```

运行结果：

```
hi,you are so good
```

上面的例子，结束进程的时候改为调用 _exit()

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
 
int main(int argc, char *argv[])
{
	printf("hi, mike, you are so good"); // 打印，没有换行符"\n"
	
	//exit(0);      // 结束进程，标准库函数，刷新缓冲区，printf()的内容能打印出来
	_exit(0);  // 结束进程，系统调用函数，printf()的内容不会显示到屏幕
	
	while(1);	// 不让程序结束
 
	return 0;
}
```

运行结果：没有内容

接下来，我们一起验证一下结束函数（ return ）和结束进程（ exit() ）的区别。

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
 
void fun()
{
	sleep(2);
	
	return;  // 结束 fun() 函数
	
	while(1);
}
 
 
int main(int argc, char *argv[])
{
	fun();
	
	printf("after fun\n");
	
	while(1);	// 不让程序结束
 
	return 0;
}
```

运行结果：程序没有结束

return 的作用只是结束调用 return 的所在函数，只要这个函数不是主函数（ main() ），只要主函数没有结束，return 并不能结束进程。

## 3.11 僵尸进程

### 3.11.1 概念

进程已运行结束，但进程的占用的资源未被回收，这样的进程称为僵尸进程。

在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。 但是仍然为其保留一定的信息，这些信息主要主要指进程控制块的信息（包括进程号、退出状态、运行时间等）。直到父进程通过 wait() 或 waitpid() 来获取其状态并释放。

这样就会导致一个问题，如果进程不调用wait() 或 waitpid() 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程.此即为僵尸进程的危害，应当避免。

子进程已运行结束，父进程未调用 wait() 或 waitpid() 函数回收子进程的资源是子进程变为僵尸进程的原因。

僵尸进程测试程序如下：

```C

#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>
 
int main(int argc, char *argv[])
{
    pid_t pid;
    pid = fork();	//创建进程
	
    if( pid < 0 ){ // 出错
        perror("fork error:");
        exit(1);
    }else if( 0 == pid ){ // 子进程
	
        printf("I am child process.I am exiting.\n");
		printf("[son id]: %d\n", getpid() );
		
        exit(0);
    }else if( pid > 0){ // 父进程
		// 父进程没有调用 wati() 或 watipid() 
		sleep(1); // 保证子进程先运行
		printf("I am father process.I will sleep two seconds\n");
		printf("[father id]: %d\n", getpid() );
		
		while(1); // 不让父进程退出
	}
	
    return 0;
}

```

运行结果：

```
[son_id]:34001
[father_id]:3400
```

在终端敲：ps -ef | grep defunct，后面尖括号里是 defunct 的都是僵尸进程。

### 3.11.2 如何避免僵尸进程

- 最简单的方法，父进程通过 wait() 和 waitpid() 等函数等待子进程结束，但是，这会导致父进程挂起。具体用法，请看《进程的控制：结束进程、等待进程结束》。

- 如果父进程要处理的事情很多，不能够挂起，通过 signal()  函数人为处理信号 SIGCHLD ， 只要有子进程退出自动调用指定好的回调函数，因为子进程结束后， 父进程会收到该信号 SIGCHLD ，可以在其回调函数里调用 wait() 或 waitpid() 回收。

  ```C
  #include <stdio.h>
  #include <unistd.h>
  #include <errno.h>
  #include <stdlib.h>
  #include <signal.h>
   
  void sig_child(int signo)
  {
      pid_t  pid;  
  	 
      //处理僵尸进程, -1 代表等待任意一个子进程, WNOHANG代表不阻塞
      while( (pid = waitpid(-1, NULL, WNOHANG)) > 0 ){
  		printf("child %d terminated.\n", pid);
  	}
  }
   
  int main()
  {
      pid_t pid;
  	
      // 创建捕捉子进程退出信号
  	// 只要子进程退出，触发SIGCHLD，自动调用sig_child()
      signal(SIGCHLD, sig_child);
  	
      pid = fork();	// 创建进程
  	
      if (pid < 0){ // 出错
          perror("fork error:");
          exit(1);
      }else if(pid == 0){ // 子进程
          printf("I am child process,pid id %d.I am exiting.\n",getpid());
          exit(0);
  		
      }else if(pid > 0){ // 父进程
  		sleep(2);	// 保证子进程先运行
  		printf("I am father, i am exited\n\n");
  		system("ps -ef | grep defunct"); // 查看有没有僵尸进程
  	
  	}
  	
      return 0;
  }
  ```

  

- 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCHLD, SIG_IGN）通知内核，自己对子进程的结束不感兴趣，父进程忽略此信号，那么子进程结束后，内核会回收， 并不再给父进程发送信号。

```C
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>
#include <signal.h>
 
int main()
{
    pid_t pid;
	
    // 忽略子进程退出信号的信号
	// 那么子进程结束后，内核会回收， 并不再给父进程发送信号
    signal(SIGCHLD, SIG_IGN);
	
    pid = fork();	// 创建进程
	
    if (pid < 0){ // 出错
        perror("fork error:");
        exit(1);
    }else if(pid == 0){ // 子进程
        printf("I am child process,pid id %d.I am exiting.\n",getpid());
        exit(0);
		
    }else if(pid > 0){ // 父进程
		sleep(2);	// 保证子进程先运行
		printf("I am father, i am exited\n\n");
		system("ps -ef | grep defunct"); // 查看有没有僵尸进程
	
	}
	
    return 0;
}
```

- 还有一些技巧，就是 fork()  两次，父进程 fork() 一个子进程，然后继续工作，子进程 fork() 一 个孙进程后退出，那么孙进程被 init 接管，孙进程结束后，init （1 号进程）会回收。不过子进程的回收还要自己做。《UNIX环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为 init 进程（1 号进程），通过 init 进程（1 号进程）可以处理僵尸进程。

  ```C
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <errno.h>
   
  int main()
  {
      pid_t  pid;
      //创建第一个子进程
      pid = fork();
  	
      if (pid < 0){ // 出错
          perror("fork error:");
          exit(1);
      }else if (pid == 0){//子进程
      
          //子进程再创建子进程
          printf("I am the first child process.pid:%d\tppid:%d\n",getpid(),getppid());
          pid = fork();
          if (pid < 0){
              perror("fork error:");
              exit(1);
          }else if(pid == 0){ // 子进程
  			//睡眠3s保证下面的父进程退出，这样当前子进程的父亲就是 init 进程
  			sleep(3);
  			printf("I am the second child process.pid: %d\tppid:%d\n",getpid(),getppid());
  			exit(0);
  			
  		}else if (pid >0){ //父进程退出
              printf("first procee is exited.\n");
              exit(0);
          }
  		
      }else if(pid > 0){ // 父进程
  	
  		// 父进程处理第一个子进程退出，回收其资源
  		if (waitpid(pid, NULL, 0) != pid){
  			perror("waitepid error:");
  			exit(1);
  		}
  		
  		exit(0);
  	}
  	
      return 0;
  }
  ```

## 3.12 孤儿进程

父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程（Orphan Process）。孤儿进程最终会被 init 进程（进程号为 1 ）所收养，并由 init 进程对它们完成状态收集工作。

孤儿进程是没有父进程的进程，为避免孤儿进程退出时无法释放所占用的资源而变为僵尸进程（什么是僵尸进程，请看《僵尸进程》），进程号为 1 的 init 进程将会接受这些孤儿进程，这一过程也被称为“收养”。init 进程就好像是一个孤儿院，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
 
int main()
{
    pid_t  pid;
    //创建进程
    pid = fork();
	
    if (pid < 0){ // 出错
        perror("fork error:");
        exit(1);
    }else if (pid == 0){//子进程
		sleep(2); // 保证父进程先结束
		
		printf("son proess: [son id] = %d, [son's father id] = %d\n", getpid(), getppid());
		
		exit(0);
		
    }else if(pid > 0){ // 父进程
		printf("father process, i am exited\n");
		
		exit(0);
	}
	
    return 0;
}
```

## 3.13 守护进程

### 什么是守护进程

守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在某些用户空间中，即使用户退出登录，仍然会有一些后台进程在运行，这些进程被称为 `守护进程(daemon)`。

守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。

Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。

### 如何查看守护进程

```sh
ps axj

# a 表示不仅列当前用户的进程，也列出所有其他用户的进程
# x 表示不仅列有控制终端的进程，也列出所有无控制终端的进程
# j 表示列出与作业控制相关的信息
```

从上图可以看出守护进行的一些特点：

- 守护进程基本上都是以超级用户启动（ UID 为 0 ）
- 没有控制终端（ TTY 为 ？）
- 终端进程组 ID 为 -1 （ TPGID 表示终端进程组 ID）

### 如何启动守护进程

- 在系统启动时由启动脚本启动，这些启动脚本通常放在 /etc/rc.d 目录下
- 利用 inetd 超级服务器启动，如 telnet 等
- 由 cron 定时启动
- 终端用 nohup 启动的进程也是守护进程

### 编写守护进程

**屏蔽一些控制终端操作的信号**

这是为了防止守护进行在没有运行起来前，控制终端受到干扰退出或挂起

```c
signal(SIGTTOU,SIG_IGN); 
signal(SIGTTIN,SIG_IGN); 
signal(SIGTSTP,SIG_IGN); 
signal(SIGHUP ,SIG_IGN);
```

**在后台运行**

```c
if( pid = fork() ){ // 父进程
	exit(0); 	    //结束父进程，子进程继续
}
```

**脱离控制终端、登录会话和进程组**

有必要先介绍一下 Linux 中的 **进程与控制终端，登录会话和进程组之间的关系**：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的 shell 登录终端。 控制终端、登录会话和进程组通常是从父进程继承下来的。 **我们的目的就是要摆脱它们 ，使之不受它们的影响**。因此需要调用 setsid() 使子进程成为新的会话组长，示例代码如下：

```c
setsid();
```

setsid() 调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。 

**禁止进程重新打开控制终端**

现在，进程已经成为无终端的会话组长， **但它可以重新申请打开一个控制终端**。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端，采用的方法是再次创建一个子进程，示例代码如下：

```c
if( pid=fork() ){ // 父进程
	exit(0);      // 结束第一子进程，第二子进程继续（第二子进程不再是会话组长） 
}
```

**关闭打开的文件描述符**

进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。按如下方法关闭它们：

```c
// NOFILE 为 <sys/param.h> 的宏定义
// NOFILE 为文件描述符最大个数，不同系统有不同限制
for(i=0; i< NOFILE; ++i){// 关闭打开的文件描述符
	close(i);
}
```

**改变当前工作目录**

进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 /tmp。示例代码如下：

```c
chdir("/");
```

**重设文件创建掩模**

```c
umask(0);
```

**处理 SIGCHLD 信号**

但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源（关于僵尸进程的更多详情， [请看《特殊进程之僵尸进程》](http://blog.csdn.net/tennysonsky/article/details/45966571)）。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在 Linux 下可以简单地将 SIGCHLD 信号的操作设为 SIG_IGN 。

```c
signal(SIGCHLD, SIG_IGN);
```

这样，内核在子进程结束时不会产生僵尸进程。

示例代码如下：

```c
#include <unistd.h> 
#include <signal.h> 
#include <fcntl.h>
#include <sys/syslog.h>
#include <sys/param.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
 
int init_daemon(void)
{ 
	int pid; 
	int i;
	
	// 1）屏蔽一些控制终端操作的信号
	signal(SIGTTOU,SIG_IGN); 
	signal(SIGTTIN,SIG_IGN); 
	signal(SIGTSTP,SIG_IGN); 
	signal(SIGHUP ,SIG_IGN);
 
	// 2）在后台运行
    if( pid=fork() ){ // 父进程
        exit(0); //结束父进程，子进程继续
	}else if(pid< 0){ // 出错
		perror("fork");
		exit(EXIT_FAILURE);
	}
	
	// 3）脱离控制终端、登录会话和进程组
	setsid();  
	
	// 4）禁止进程重新打开控制终端
	if( pid=fork() ){ // 父进程
		exit(0);      // 结束第一子进程，第二子进程继续（第二子进程不再是会话组长） 
	}else if(pid< 0){ // 出错
		perror("fork");
		exit(EXIT_FAILURE);
	}  
	
	// 5）关闭打开的文件描述符
	// NOFILE 为 <sys/param.h> 的宏定义
	// NOFILE 为文件描述符最大个数，不同系统有不同限制
	for(i=0; i< NOFILE; ++i){
		close(i);
	}
	
	// 6）改变当前工作目录
	chdir("/tmp"); 
	
	// 7）重设文件创建掩模
	umask(0);  
	
	// 8）处理 SIGCHLD 信号
	signal(SIGCHLD,SIG_IGN);
	
	return 0; 
} 
 
int main(int argc, char *argv[]) 
{
	init_daemon();
	
	while(1);
 
	return 0;
}
```

## 3.14 多任务的同步与互斥

现代操作系统基本都是多任务操作系统，即同时有大量可调度实体在运行。在多任务操作系统中，同时运行的多个任务可能：

- 都需要访问/使用同一种资源

- 多个任务之间有依赖关系，某个任务的运行依赖于另一个任务

  这两种情形是多任务编程中遇到的最基本的问题，也是多任务编程中的核心问题，同步和互斥就是用于解决这两个问题的。

**互斥**：是指散步在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。

**同步**：是指散步在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。

显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个任务之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）！因此互斥具有唯一性和排它性，但互斥并不限制任务的运行顺序，即任务是无序的，而同步的任务之间则有顺序关系。

# 4. 内存管理

## 4.1 计算机操作系统存储器管理

### 4.1.1 程序的装入和链接

#### 步骤

用户程序在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序，通常都要经过以下几个步骤：
（1）编译，由编译程序对用户源程序进行编译，形成若干个目标模块；
（2）链接，由链接程序将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块；
（3）装入，由装入程序将装入模块装入内存。

#### 程序的装入

**1.绝对装入方式**
仅能运行单道程序时可以采用该种方式。装入模块被装入内存后，程序中的逻辑地址与实际内存地址完全相同。
**2.可重定位装入方式**
采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。值得注意的是，在采用可重定位装入程序将装入模块装入内存后，会使装入模块中的所有逻辑地址与实际装入内存的物理地址不同。通常是把在装入时对目标程序中指令和数据地址的修改过程称为重定位。又因为地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位。
**3.动态运行时装入方式**
动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址都仍是相对地址。为使地址转换不影响指令的执行速度，这种方式需要一个重定位寄存器的支持。

#### **程序的链接**

**静态链接方式**
在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。
在将几个目标模块装配成一个装入模块时，须解决以下两个问题：
（1）对相对地址进行修改；
（2）变换外部调用符号。
**装入时动态链接**
将用户源程序编译后所得到的一组目标模块装入内存时，采用边装入边链接的链接方式。
该方式的优点是：便于修改和更新、便于实现对目标模块的共享。
**运行时动态链接**
涉及到的模块不一定用到，例如异常处理模块。因此将对某些模块的链接推迟到程序执行时才进行链接，亦即，在执行过程中，当发现一个被调用模块尚未装入内存时，立即由 OS 去找到该模块并将之装入内存，把它链接到调用者模块上。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。

### 4.1.2  连续分配存储管理方式

连续分配方式是最早出现的一种存储器分配方式，该方式为一个用户程序分配一个连续的内存空间，即代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻。

#### 单一连续分配

在单道程序环境下，当时的存储器管理方式是把内存分为系统区和用户区两部分，系统区仅提供给OS使用，它通常是放在内存的低址部分。而在用户区内存中，仅装有一道用户程序，即整个内存的用户空间由该程序独占。这样的存储器分配方式被称为单一连续分配方式。

#### 固定分区分配

多道程序系统为了能在内存中装入多道程序，且使这些程序之间又不会发生相互干扰，于是将整个用户空间化分为若干个固定大小的区域，在每个分区中只装入一道作业，这样就形成了最早的、也是最简单的一种可运行多道程序的分区式存储管理方式。
**1.划分分区的方法**
（1）分区大小相等。其缺点是缺乏灵活性，即当程序太小时，会造成内存空间的浪费。当程序太大时，一个分区又不足以装入该程序，致使该程序无法运行。
（2）分区大小不等。为了增加存储器分配的灵活性，应将存储器分区划分为若干个大小不等的分区。
**2.内存分配**
为了便于内存分配，通常将分区按其大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配）。

**固定分区分配每个分区的大小固定，必然造成存储空间的浪费**

#### 动态分区分配

根据进程的实际需要，动态地为之分配内存空间。
**1.动态分区分配中的数据结构**
（1）空闲分区表。在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区号、分区大小和分区始址等数据项。
（2）空闲分区链。为了实现对空闲分区的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接个分区所用的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。
**2.动态分区分配算法**
稍后介绍
**3.分区分配操作**
（1）分配内存。
（2）回收内存。

##### 基于顺序搜索的动态分区分配算法

1.首次适应（first fit，FF）算法
在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区位置。
该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区。这为以后到达的大作业分配大的内存空间创造了条件。其缺点是低址部分不断被划分，会留下许多难以利用的很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销。
2.循环首次适应（next fit，NF）算法
不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。
该算法能使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区。
3.最佳适应（best fit，BF）算法
该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。这样第一次找到的能满足要求的空闲区必然是最佳的。但存储器中会留下许多难以利用的碎片。
4.最坏适应（worst fit，WF）算法
该方法的策略正好与最佳适应算法相反。
它的优点是可使剩下的空闲区不至于太小，产生碎片的可能性最小，对中、小作业有利。同时最坏适应分配算法查找效率很高，该算法要求将所有的空闲分区按其容量以从大到小的顺序形成一空闲分区链，查找时，只要看第一个分区能否满足作业要求即可。

##### 基于索引搜索的动态分区分配算法

1.快速适应（quick fit）算法
（1）第一步是根据进程的长度，从索引表中去寻找到能容纳它的最小空闲区链表；
（2）第二步是从链表中取下第一块进行分配即可。
优点：不会产生内存碎片、查找效率高；
缺点：为了有效合并分区，在分区归还主存时的算法复杂，系统开销较大、分配空闲空间是以进程为单位的，或多或少存在着浪费，这是典型的以空间换时间的做法。
2.伙伴系统
在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比快速适应算法差，但由于它采用了索引搜索算法，比顺序搜索算法好。而其空间性能，由于对空闲分区进行合并，减少了小的空闲分区，提高了空闲分区的可使用率，故优于快速适应算法，比顺序搜索法略差。
3.哈希算法
进行空闲分区分配时，根据空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。

#### 动态可重定位分区分配

1.紧凑
把原来多个分散的小分区拼接成一个大分区的方法，称为“拼凑”或“紧凑”。
经过拼凑后的用户程序在内存中的位置发生了变化，为此在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。
2.动态重定位
为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即须在系统中增设一个**重定位寄存器**，用它来存放程序（数据）在内存中的起始地址。
当系统对内存进行了“紧凑”，而使若干程序从内存的某处移至另一处时，不需对程序做任何修改，只要用该程序在内存的新起始地址去置换原来的起始地址即可。
3.动态重定位分区分配算法
该算法与动态分区分配算法基本上相同，差别在于增加了紧凑的功能。

### 4.1.3 对换

#### 多道程序环境下的对换技术

1.**对换的引入**
一方面，在内存中的某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞，而无可运行之进程，迫使CPU停止下来等待的情况；另一方面，却又有着许多作业，因内存空间不足，一直驻留在外存上，而不能进入内存运行。显然这对系统资源是一种严重的浪费，且是系统吞吐量下降。因此，系统中又增设了对换（也称交换）设施。
所谓“对换”，是指把内存中暂时不能运行的进程或者暂时不用的程序和数据换出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据换入内存。对换是改善内存利用率的有效措施，它可以直接提高处理机的利用率和系统的吞吐量。
2.**对换的类型**
（1）整体对换。即处理机中级调度。
（2）页面（分段）对换。这种对换方法是实现请求分页和请求分段式存储管理的基础，其目的是为了支持虚拟存储系统。
为了实现进程对换，系统必须提供三方面的功能：对对换空间的管理、进程的换出和进程的换入。

#### 对换空间的管理

通常将磁盘空间分为文件区和对换区两部分。

1.对换空间的主要目标
（1）对文件区管理的主要目标：提高文件存储空间的利用率，然后是提高对文件的访问速度。
采取离散分配方式。
（2）对对换空间管理的主要目标：提高进程换入和换出的速度，然后是提高文件存储空间的利用率。
采取连续分配方式，较少考虑外存中的碎片问题。
2.对换区空闲盘块管理中的数据结构
与内存在分区分配方式中的数据结构相似，即同样可以用空闲分区表或空闲分区链。
空闲分区表的每个表目中应包含：对换区的首址及其大小，分别用盘块号和盘块数表示。
3.对换空间的分配和回收
由于对换分区的分配采用的是连续分配方式，因而对换空间的分配和回收与动态分区方式时的内存分配与回收方法雷同。

#### 进程的换出与换入

1.进程的换出
（1）选择被换出的进程。首先选择处于阻塞或睡眠状态的进程，当有多个这样的进程时，应当选择优先级最低的进程作为换出进程。为了防止低优先级进程在被调入内存后很快又被换出，还需考虑进程在内存的驻留时间。如果系统中已无阻塞进程，而现在的内存空间仍不足以满足需要，便选择优先级最低的就绪进程换出。
（2）进程换出过程。在对进程换出时，只能换出非共享的程序和数据段，而对那些共享的程序和数据段，只要还有进程需要它，就不能被换出。
2.进程的换入

### 4.1.4 分页存储管理方式

**连续分配方式会形成许多碎片，虽然可通过紧凑方法将许多碎品拼接成可用的大块空间，但需为之付出很大开销。如果允许将一个进程直接分散的装入许多不相邻的分区中，便可充分地利用内存空间，而无需再进行紧凑。根据在离散分配时所分配地址空间的基本单位不同，又可将离散分配分为一下三种。分页存储管理方式、分段存储管理方式、段页式存储管理方式。**

#### 概念

**1.页面和物理块**
（1）页面。分页存储管理将进程的逻辑地址空间分成若干个页，并为各页加以编号。相应的也把内存的物理地址空间分成若干个块，也为它们加以编号。在为进程分配内存时，以块为单位，将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块，而形成了不可利用的碎片，称之为“业内碎片”。
（2）页面大小若选择的页面大小，虽然一方面可以减少内存碎片，起到减少内存碎片总空间的作用，有利于内存利用率的提高，但另一方面却会造成每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存，还会降低页面换进换出的效率。如果选择的页面过大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此页面的大小应选择适中，且页面大小应是2的幂，通常为1KB~8KB。
**2.地址结构**
它包含两部分，前一部分为页号P，后一部分为位（偏）移量W，即业内地址。地址空间最多允许有1M页。
若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和业内地址d可按下式求得：
P=INT[A/L]，d=[A] MOD L
其中INT是整除函数，MOD是取余函数。
**3.页表**
页表的作用是实现从页号到物理块号的地址映射。
在简单的分页系统中，也常在页表的表项中设置一存取控制字段，用于对该存储块中的内容加以保护。当存取控制字段仅有一位时，可用来规定该存储块中的内容是允许读/写还是只读；若存取控制字段为二位，则可规定为读/写、只读和只执行等存取方式。如果有一进程试图去写一个只允许读的存储块时，将引起操作系统的一次中断，如果要利用分页系统去实现虚拟存储器，则还须增设一个数据块。

<img src="/Users/fanqingwei/Desktop/学习/linux/images/页表作用1.png" alt="页表作用1" style="zoom:50%;" />

#### 地址变换机构

该机构的基本任务是实现从逻辑地址到物理地址的转换。地址变换机构的任务实际上只是将逻辑地址中的页号转换为内存中的物理块号。

又因为页面映射表的作用就是用于实现从页号到物理块号的变换，因此，**地址变换任务是借助页表来完成的**。

1.基本的地址变换机构

<img src="/Users/fanqingwei/Desktop/学习/linux/images/分页地址变化机构.png" alt="分页地址变化机构" style="zoom:50%;" />

2.具有快表的地址变换机构
为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”（Associative Memory），或称为“快表”，用以存放当前访问的那些页表项。

<img src="/Users/fanqingwei/Desktop/学习/linux/images/分页快表地址变换机构.png" alt="分页快表地址变换机构" style="zoom:50%;" />

#### 访问内存的有效时间

从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间（Effective Access Time，EAT）。
假设访问一次内存的时间为t，在基本分页存储管理方式中，有效访问时间为第一次访问内存时间（查找页表对应的页表项所耗费的时间t）与第二次访问内存时间（将页表项中的物理块号与页内地址拼接成实际物理地址所耗费的时间t）之和：
EAT=t+t=2t
在引入快表的分页存储管理方式中，有效访问时间的计算公式即为：
EAT=a×λ+（t+λ）（1-a）+t=2t+λ-t×a
式中，λ表示查找快表所需要的时间，a表示命中率，t表示访问一次内存所需要的时间。
正是由于引入了快表，CPU访问数据所耗费的时间明显减少。

#### 两级和多级页表

现在计算机系统支持非常大的逻辑地址空间，因此页表就变得非常大，要占用相当大的内存空间。，基本上每个进程页表中的页表可占达1MB之多，而且要求是连续的。显然这是不现实的。解决办法：

（1）对于页表所需的内存空间，可采用离散分配方式，以解决难以找到一块连续的大内存空间的问题；
（2）只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入。

**1.两级页表（Two-Level Page Table）**
针对难于找到大的连续的内存空间来存放页表的问题，可利用将页表进行分页的方法，使每个页面的大小与内存物理块的大小相同，并为它们编号。然后离散地将各个层面分别存放在不同的物理快中。同样也要为离散分配的页表再建立一张页表，称为外层页表，在每个页表项中记录了页表页面的物理块号。
对页表实施离散分配的方法虽然解决了对于大页表无需大片连续存储空间的问题，但并未解决用较少的内存空间去存放大页表的问题。能够用较少的内存空间存放页表的唯一方法是，仅把当前需要的一批页表项调入内存，以后再根据需要陆续调入。

<img src="/Users/fanqingwei/Desktop/学习/linux/images/二级页表.png" alt="二级页表" style="zoom:50%;" />

**2.多级页表**

#### 反置页表

1.反置页表的引入
2.地址变换

#### 快表

为了解决虚拟地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把块表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。

使用快表之后的地址转换流程是这样的：

1. 根据虚拟地址中的页号查快表；
2. 如果该页在快表中，直接从快表中读取相应的物理地址；
3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

#### 多级页表

引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章

- 多级页表如何节约内存：https://www.polarxiong.com/archives/多级页表如何节约内存.html

不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。

### 4.1.5 分段存储管理

#### 分段的引入

- 通常程序分为若干段，如主程序段、子程序段A、B...，每一个段大多是一个相对独立的逻辑单位
- 实现和满足信息共享、信息保护、动态链接以及信息的动态增长。

#### **分段系统的基本原理**

**1.分段**

作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。每个段都从 0 开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间由于是分成多个段，因而呈现出二维特性。其逻辑地址由短号和段内地址组成。

<img src="/Users/fanqingwei/Desktop/学习/linux/images/分段地址.png" alt="分段地址" style="zoom:50%;" />

**2.段表**

在分段式存储管理系统中，则是为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区中。在系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址(又称为“基址”)和段的长度。可见，段表是用于实现从逻辑段到物理内存区的映射。
<img src="/Users/fanqingwei/Desktop/学习/linux/images/段表映射.png" alt="段表映射" style="zoom:50%;" />

**3.地址变换机构**

为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址和段表长度 TL。在进行地址变换时，系统将逻辑地址中的段号与段表长度TL 进行比较。若 S>TL，表示段号太大，是访问越界，于是产生越界中断信号；若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存的起始地址，然后，再检查段内地址 d 是否超过该段的段长 SL。若超过，即 d>SL，同样发出越界中断信号；若未越界，则将该段的基址与段内地址相加，即可得到要访问的内存物理地址。
<img src="/Users/fanqingwei/Desktop/学习/linux/images/段表地址变换机构.png" alt="段表地址变换机构" style="zoom:50%;" />

#### 分页和分段的主要区别

相似之处：
两者都采用离散分配方式，且都要通过地址映射机构来实现地址变换。
不同：
1）页是信息的物理单位，分页是为了提高内存的利用率。段则是信息的逻辑单位，分段的目的是为了能更好地满足用户的需要。
2）页的大小固定且由系统决定。而段的长度却不固定，决定于用户所编写的程序。
3）分页中用户程序的的逻辑地址空间是一维的，分页完全是系统的行为，只需要一个记忆符即可表示一个地址。而分段中用户程序的逻辑地址空间是二维的，在标识一个地址时，既需给出段名， 又需给出段内地址（正是因为段的大小不固定导致的）。

### 4.1.6 段页式存储管理方式

#### 段页式地址结构

段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成。

<img src="/Users/fanqingwei/Desktop/学习/linux/images/段页式1.png" alt="段页式1" style="zoom:50%;" />

#### 段页式表

为了实现从逻辑地址到物理地址的变换，系统中需要同时配置段表和页表。段表的内容与分段系统略有不同，它不再是内存始址和段长，而是页表始址和页表长度。即一个分段对应一个页表。

<img src="/Users/fanqingwei/Desktop/学习/linux/images/段页式2.png" alt="段页式2" style="zoom:50%;" />

#### **地址变换过程**

为了便于实现地址变换，须配置一个段表寄存器，其中存放段表始址和段长TL。进行地址变换时，首先利用段号S，将它与段长TL进行比较。若S < TL，表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址。
<img src="/Users/fanqingwei/Desktop/学习/linux/images/段表地址变换机构.png" alt="段表地址变换机构" style="zoom:50%;" />

在段页式系统中，为了获得一条指令或数据，须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正从第二次访问所得的地址中，取出指令或数据。
解决方法仍类似快表。在地址变换机构中增
设一个高速缓冲寄存器。每次访问它时，都须同时利用段号和页号去检索高速缓存，若找到匹配的表项，便可从中得到相应页的物理块号，用来与页内地址一起形成物理地址；若未找到匹配表项，则仍须再三次访问内存。

## 4.2 虚拟内存

**虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）**。这样会更加有效地管理内存并减少出错。

**虚拟内存** 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。

### 过程

1. 在程序装入时, 将程序中很快会用到的部分装入内存, 暂时用不到的部分留在外存, 就可以让程序开始执行.
2. 在程序执行过程中, 当所访问的信息不在内存时, 由操作系统负责将所需信息由外存调入内存, 然后继续执行程序.
3. 内存空间不够时, 操作系统负责将内存中暂时用不到的信息换出到外存
4. 在用户看来, 就有一个比实际内存大很多的内存, 这就叫虚拟内存

### 局部性原理

局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。

局部性原理表现在以下两个方面：

1. **时间局部性** ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
2. **空间局部性** ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。

### 虚拟存储器

基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——**虚拟存储器**

### 虚拟内存的大小

虚拟内存的最大容量是由计算机的地址结构 ( CPU的寻址范围 ) 确定的, 虚拟内存的实际容量 = 𝑚𝑖𝑛(内存容量+外存容量,𝐶𝑃𝑈寻址范围)

### 虚拟内存的技术实现

**虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。** 虚拟内存的实现有以下三种方式：

**虚拟内存的实现** :

- 请求分页存储管理：建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。
- 请求分段存储管理
- 请求段页式存储管理

**操作系统需要提供的功能** :

1. 缺页中断 ( 段 )：如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**，然后继续执行程序；
2. 页面置换 ( 段置换 )

缺页时请求掉页不一定页面置换, 若还有可用的内存块, 就不用进行页面置换

### 页面置换算法

地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。

当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。

- **OPT页面置换算法（最佳页面置换算法）** ：理想情况，不可能实现，一般作为衡量其他置换算法的方法。
- **FIFO页面置换算法（先进先出页面置换算法）**  : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
- **LRU页面置换算法（最近未使用页面置换算法）** ：LRU（Least Currently Used）算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当须淘汰一个页面时，选择现有页面中其T值最大的，即最近最久未使用的页面予以淘汰。
- **LFU页面置换算法（最少使用页面排序算法）** : LFU（Least Frequently Used）算法会让系统维护一个按最近一次访问时间排序的页面链表，链表首节点是最近刚刚使用过的页面，链表尾节点是最久未使用的页面。访问内存时，找到相应页面，并把它移到链表之首。缺页时，置换链表尾节点的页面。也就是说内存内使用越频繁的页面，被保留的时间也相对越长。

## 4.3 Linux 内存管理

### 4.3.1 基本概念

每个 Linux 进程都会有地址空间，这些地址空间由三个段区域组成：**「text 段、data 段、stack 段」**。下面是进程地址空间的示例。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQGIsOaYrW0qBfsbKmpvRC9krgybwGxAiaSOJcxX4icBQdwnrDU1B2heMQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

`数据段(data segment)` 包含了程序的变量、字符串、数组和其他数据的存储。数据段分为两部分，已经初始化的数据和尚未初始化的数据。其中`尚未初始化的数据`就是我们说的 BSS。数据段部分的初始化需要编译期确定的常量以及程序启动就需要一个初始值的变量。所有 BSS 部分中的变量在加载后被初始化为 0 。

和 `代码段(Text segment)` 不一样，data segment 数据段可以改变。程序总是修改它的变量。而且，许多程序需要在执行时动态分配空间。Linux 允许数据段随着内存的分配和回收从而增大或者减小。为了分配内存，程序可以增加数据段的大小。在 C 语言中有一套标准库 `malloc` 经常用于分配内存。进程地址空间描述符包含动态分配的内存区域称为 `堆(heap)`。

第三部分段是 `栈段(stack segment)`。在大部分机器上，栈段会在虚拟内存地址顶部地址位置处，并向低位置处（向地址空间为 0 处）拓展。举个例子来说，在 32 位 x86 架构的机器上，栈开始于 `0xC0000000`，这是用户模式下进程允许可见的 3GB 虚拟地址限制。如果栈一直增大到超过栈段后，就会发生硬件故障并把页面下降一个页面。

当程序启动时，栈区域并不是空的，相反，它会包含所有的 shell 环境变量以及为了调用它而向 shell 输入的命令行。举个例子，当你输入

```
cp cxuan lx
```

时，cp 程序会运行并在栈中带着字符串 `cp cxuan lx` ，这样就能够找出源文件和目标文件的名称。

当两个用户运行在相同程序中，例如`编辑器(editor)`，那么就会在内存中保持编辑器程序代码的两个副本，但是这种方式并不高效。Linux 系统支持`共享文本段作`为替代。下面图中我们会看到 A 和 B 两个进程，它们有着相同的文本区域。

<img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQiaDc002s7h67ZPaynMwwVwnR5YDQ2xcBnrwUPETMJZtf4DlCem4oHibw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" style="zoom:50%;" />

数据段和栈段只有在 fork 之后才会共享，共享也是共享未修改过的页面。如果任何一个都需要变大但是没有相邻空间容纳的话，也不会有问题，因为相邻的虚拟页面不必映射到相邻的物理页面上。

除了动态分配更多的内存，Linux 中的进程可以通过`内存映射文件`来访问文件数据。这个特性可以使我们把一个文件映射到进程空间的一部分而该文件就可以像位于内存中的字节数组一样被读写。把一个文件映射进来使得随机读写比使用 read 和 write 之类的 I/O 系统调用要容易得多。共享库的访问就是使用了这种机制。如下所示

<img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQCicSciaEFlvMc9H4bHPHhu72diavPfmKCCQwbCiaqrV3OQiaNsBVvFU58fQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" style="zoom:50%;" />

我们可以看到两个相同文件会被映射到相同的物理地址上，但是它们属于不同的地址空间。

映射文件的优点是，两个或多个进程可以同时映射到同一文件中，任意一个进程对文件的写操作对其他文件可见。通过使用映射临时文件的方式，可以为多线程共享内存`提供高带宽`，临时文件在进程退出后消失。但是实际上，并没有两个相同的地址空间，因为每个进程维护的打开文件和信号不同。

### 4.3.2 Linux 内存管理系统调用

下面我们探讨一下关于内存管理的系统调用方式。事实上，POSIX 并没有给内存管理指定任何的系统调用。然而，Linux 却有自己的内存系统调用，主要系统调用如下

| 系统调用                                | 描述           |
| --------------------------------------- | -------------- |
| s = brk(addr)                           | 改变数据段大小 |
| a = mmap(addr,len,prot,flags,fd,offset) | 进行映射       |
| s = unmap(addr,len)                     | 取消映射       |

如果遇到错误，那么 s 的返回值是 -1，a 和 addr 是内存地址，len 表示的是长度，prot 表示的是控制保护位，flags 是其他标志位，fd 是文件描述符，offset 是文件偏移量。

`brk` 通过给出超过数据段之外的第一个字节地址来指定数据段的大小。如果新的值要比原来的大，那么数据区会变得越来越大，反之会越来越小。

`mmap` 和 `unmap` 系统调用会控制映射文件。mmp 的第一个参数 addr 决定了文件映射的地址。它必须是页面大小的倍数。如果参数是 0，系统会分配地址并返回 a。第二个参数是长度，它告诉了需要映射多少字节。它也是页面大小的倍数。prot 决定了映射文件的保护位，保护位可以标记为 **「可读、可写、可执行或者这些的结合」**。第四个参数 flags 能够控制文件是私有的还是可读的以及 addr 是必须的还是只是进行提示。第五个参数 fd 是要映射的文件描述符。只有打开的文件是可以被映射的，因此如果想要进行文件映射，必须打开文件；最后一个参数 offset 会指示文件从什么时候开始，并不一定每次都要从零开始。

### 4.3.3 Linux 内存管理实现

内存管理系统是操作系统最重要的部分之一。从计算机早期开始，我们实际使用的内存都要比系统中实际存在的内存多。`内存分配策略`克服了这一限制，并且其中最有名的就是 `虚拟内存(virtual memory)`。通过在多个竞争的进程之间共享虚拟内存，虚拟内存得以让系统有更多的内存。虚拟内存子系统主要包括下面这些概念。

**「大地址空间」**

操作系统使系统使用起来好像比实际的物理内存要大很多，那是因为虚拟内存要比物理内存大很多倍。

**「保护」**

系统中的每个进程都会有自己的虚拟地址空间。这些虚拟地址空间彼此完全分开，因此运行一个应用程序的进程不会影响另一个。并且，硬件虚拟内存机制允许内存保护关键内存区域。

**「内存映射」**

内存映射用来向进程地址空间映射图像和数据文件。在内存映射中，文件的内容直接映射到进程的虚拟空间中。

**「公平的物理内存分配」**

内存管理子系统允许系统中的每个正在运行的进程公平分配系统的物理内存。

**「共享虚拟内存」**

尽管虚拟内存让进程有自己的内存空间，但是有的时候你是需要共享内存的。例如几个进程同时在 shell 中运行，这会涉及到 IPC 的进程间通信问题，这个时候你需要的是共享内存来进行信息传递而不是通过拷贝每个进程的副本独立运行。

下面我们就正式探讨一下什么是 `虚拟内存`

#### 虚拟内存的抽象模型

在考虑 Linux 用于支持虚拟内存的方法之前，考虑一个不会被太多细节困扰的抽象模型是很有用的。

处理器在执行指令时，会从内存中读取指令并将其`解码(decode)`，在指令解码时会获取某个位置的内容并将他存到内存中。然后处理器继续执行下一条指令。这样，处理器总是在访问存储器以获取指令和存储数据。

在虚拟内存系统中，所有的地址空间都是虚拟的而不是物理的。但是实际存储和提取指令的是物理地址，所以需要让处理器根据操作系统维护的一张表将虚拟地址转换为物理地址。

为了简单的完成转换，虚拟地址和物理地址会被分为固定大小的块，称为 `页(page)`。这些页有相同大小，如果页面大小不一样的话，那么操作系统将很难管理。Alpha AXP系统上的 Linux 使用 8 KB 页面，而 Intel x86 系统上的 Linux 使用 4 KB 页面。每个页面都有一个唯一的编号，即`页面框架号（PFN）`。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQZmuBGqTDD9iaYonIwn8JmQCP6uyV8HWzkAMhNlibYsgGGk7QEicF9Tia9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

上面就是 Linux 内存映射模型了，在这个页模型中，虚拟地址由两部分组成：**「偏移量和虚拟页框号」**。每次处理器遇到虚拟地址时都会提取偏移量和虚拟页框号。处理器必须将虚拟页框号转换为物理页号，然后以正确的偏移量的位置访问物理页。

上图中展示了两个进程 A 和 B 的虚拟地址空间，每个进程都有自己的页表。这些页表将进程中的虚拟页映射到内存中的物理页中。页表中每一项均包含

- `有效标志(valid flag)`：表明此页表条目是否有效
- 该条目描述的物理页框号
- 访问控制信息，页面使用方式，是否可写以及是否可以执行代码

要将处理器的虚拟地址映射为内存的物理地址，首先需要计算虚拟地址的页框号和偏移量。页面大小为 2 的次幂，可以通过移位完成操作。

如果当前进程尝试访问虚拟地址，但是访问不到的话，这种情况称为 `缺页异常`，此时虚拟操作系统的错误地址和页面错误的原因将通知操作系统。

通过以这种方式将虚拟地址映射到物理地址，虚拟内存可以以任何顺序映射到系统的物理页面。

#### 按需分页

由于物理内存要比虚拟内存少很多，因此操作系统需要注意尽量避免直接使用`低效`的物理内存。节省物理内存的一种方式是仅加载执行程序当前使用的页面（这何尝不是一种懒加载的思想呢？）。例如，可以运行数据库来查询数据库，在这种情况下，不是所有的数据都装入内存，只装载需要检查的数据。这种仅仅在需要时才将虚拟页面加载进内中的技术称为按需分页。

#### 交换

如果某个进程需要将虚拟页面传入内存，但是此时没有可用的物理页面，那么操作系统必须丢弃物理内存中的另一个页面来为该页面腾出空间。

如果页面已经修改过，那么操作系统必须保留该页面的内容，以便以后可以访问它。这种类型的页面被称为脏页，当将其从内存中移除时，它会保存在称为`交换文件`的特殊文件中。相对于处理器和物理内存的速度，对交换文件的访问非常慢，并且操作系统需要兼顾将页面写到磁盘的以及将它们保留在内存中以便再次使用。

Linux 使用`最近最少使用(LRU)`页面老化技术来公平的选择可能会从系统中删除的页面，这个方案涉及系统中的每个页面，页面的年龄随着访问次数的变化而变化，如果某个页面访问次数多，那么该页就表示越 `年轻`，如果某个呃页面访问次数太少，那么该页越容易被`换出`。

#### 物理和虚拟寻址模式

大多数多功能处理器都支持 `物理地址`模式和`虚拟地址`模式的概念。物理寻址模式不需要页表，并且处理器不会在此模式下尝试执行任何地址转换。Linux 内核被链接在物理地址空间中运行。

Alpha AXP 处理器没有物理寻址模式。相反，它将内存空间划分为几个区域，并将其中两个指定为物理映射的地址。此内核地址空间称为 KSEG 地址空间，它包含从 0xfffffc0000000000 向上的所有地址。为了从 KSEG 中链接的代码（按照定义，内核代码）执行或访问其中的数据，该代码必须在内核模式下执行。链接到 Alpha 上的 Linux内核以从地址 0xfffffc0000310000 执行。

#### 访问控制

页面表的每一项还包含访问控制信息，访问控制信息主要检查进程是否应该访问内存。

必要时需要对内存进行`访问限制`。例如包含可执行代码的内存，自然是只读内存；操作系统不应允许进程通过其可执行代码写入数据。相比之下，包含数据的页面可以被写入，但是尝试执行该内存的指令将失败。大多数处理器至少具有两种执行模式：内核态和用户态。你不希望访问用户执行内核代码或内核数据结构，除非处理器以内核模式运行。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaSicLbrJkEad90RjMUnOOIbQtjKNcrH7FvLZHLjMXPQayp50UFWgxH0tHtkvriauDWYd7nES9rb4z9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

访问控制信息被保存在上面的 Page Table Entry ，页表项中，上面这幅图是 Alpha AXP的 PTE。位字段具有以下含义

- V

表示 valid ，是否有效位

- FOR

读取时故障，在尝试读取此页面时出现故障

- FOW

写入时错误，在尝试写入时发生错误

- FOE

执行时发生错误，在尝试执行此页面中的指令时，处理器都会报告页面错误并将控制权传递给操作系统，

- ASM

地址空间匹配，当操作系统希望清除转换缓冲区中的某些条目时，将使用此选项。

- GH

当在使用`单个转换缓冲区`条目而不是`多个转换缓冲区`条目映射整个块时使用的提示。

- KRE

内核模式运行下的代码可以读取页面

- URE

用户模式下的代码可以读取页面

- KWE

以内核模式运行的代码可以写入页面

- UWE

以用户模式运行的代码可以写入页面

- 页框号

对于设置了 V 位的 PTE，此字段包含此 PTE 的物理页面帧号（页面帧号）。对于无效的 PTE，如果此字段不为零，则包含有关页面在交换文件中的位置的信息。

除此之外，Linux 还使用了两个位

- _PAGE_DIRTY

如果已设置，则需要将页面写出到交换文件中

- _PAGE_ACCESSED

Linux 用来将页面标记为已访问。

# 5.文件系统

## 5.1 文件描述符

对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读或写一个文件时,使用 open 或 creat 返回的文件描述符标识该文件,将其作为参数传送给 read 或 write。

# 6.I/O管理

磁盘或文件IO、网络IO

# 7.CPU调度

一些调度算法，了解即可

# 8.设备管理

