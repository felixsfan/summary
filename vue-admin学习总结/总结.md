# 官方文档

Node.js官网:http://nodejs.cn/learn/the-package-json-guide

vue官网：https://cn.vuejs.org/v2/guide/

Vue-cli官网：https://cli.vuejs.org/zh/guide/cli-service.html

vue-admin-element：https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/#%E5%8A%9F%E8%83%BD

# 1.登录权限

https://blog.csdn.net/qq_37143673/article/details/90256713

https://blog.csdn.net/hanguofei/article/details/106396581

# 2.请求后台

https://blog.csdn.net/wangdandan01/article/details/103478357

https://blog.csdn.net/weixin_45835850/article/details/116228701

# 2.常见问题

## 2.1 Promise的基本使用

https://www.jianshu.com/p/1ec8d1c4e287

https://www.cnblogs.com/fdxjava/p/11622490.html

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/promise.png" alt="promise" style="zoom: 33%;" />

## 2.2 Vuex

### 2.2.1 const actions

https://vuex.vuejs.org/zh/guide/actions.html#%E5%88%86%E5%8F%91-action

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/actions.png" alt="actions" style="zoom:33%;" />

### 2.2.2 this.$store.dispatch()

https://www.jianshu.com/p/14357dcef1ae

## 2.3 组件、模块、模版区别

1.commonjs规范中每一个js文件都可以是模块,通过export import导入导出

2.符合vue组件格式的模块可以直接注册到vue里作为组件。但是模块不太规范，vue结尾的文件就是为了更规范和方便定义组件，遵循一定的规范。

3.vue组件里templates 是模版,也是可以抽离的

## 2.4 render: h => h(App)的解释

https://www.cnblogs.com/gopark/p/11445679.html

## 2.5 解决跨域请求

前端解决：https://www.cnblogs.com/codeluojay/p/13191052.html

后端解决：

```
1.
/Users/fanqingwei/Desktop/学习/vue-admin-template/.env.development
VUE_APP_BASE_API = 'http://9.134.236.231:8080'

2.后端代码：
app = Flask(__name__)
CORS(app)  # 解决跨域

3.不需要/Users/fanqingwei/Desktop/学习/vue-admin-template/vue.config.js添加一下代码
    proxy: {
      '/dev-api': {	
        target: `http://9.134.236.231:8080`, // 后台服务地址
        changeOrigin: true,
        pathRewrite: {
          '^/dev-api': '/dev-api' // 路径重写
        }
      }
    }
```



# 3. flask蓝图总结

https://blog.csdn.net/weixin_41973615/article/details/82252501

蓝图中使用日志

https://blog.csdn.net/fujiafeihudui/article/details/104472649/

# 5.模块化导入导出

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/commonJS.png" alt="commonJS" style="zoom:25%;" />

**ES导入导出**

https://blog.csdn.net/weixin_46016926/article/details/113653247

导出

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/es导出.png" alt="es导出" style="zoom:80%;" />

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/es6导出2.png" alt="es6导出2" style="zoom: 80%;" />



导入

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/es6.png" alt="es6" style="zoom:80%;" />

# 6.vue函数和方法定义和js函数定义

## 6.1 js函数定义及与vue函数区别![方法和函数区别](/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/方法和函数区别.png)

### 区别

- 在vue实例或组件中定义的是vue函数，在js文件中定义的是js函数。vue实例或组件也可以导入js函数。两者函数没有区别。

### js函数定义

- `function a(){}`
- `a=function(){}`
- 区别是`a=function(){}`必须在定义之后调用

### vue函数定义

- 在vue中函数常规写成`a:function(){}`，等价于js里的`a=function(){}`

## 6.2 vue函数的定义

### 6.2.1 ES5普通写法

ES5语法在vue中写成`a:function(){}`，等价于js里的`a=function(){}`，因为vue的函数都是定义在vue实例或组件中，是键值对的形式。

### 6.2.2 js的ES6语法函数增强写法可以用到对象字面量里,也可以用到vue实例或组件中

 <img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/对象字面量里函数写法.png" alt="对象字面量里函数写法" style="zoom:25%;" />

**例子**

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/对象字面量函数写法例子.png" alt="对象字面量函数写法例子" style="zoom:25%;" />

### 6.2.2 vue定义函数方式总结

#### 1.ES5普通写法

ES5语法在vue中写成`a:function(){}`，等价于js里的`a=function(){}`，因为vue的函数都是定义在vue实例或组件中，是键值对的形式。

#### 2. js的ES6语法函数增强写法可以用到对象字面量里,也可以用到vue实例或组件中

![定义函数方式总结](/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/定义函数方式总结.png)

#### 3.箭头函数

https://blog.csdn.net/qq_32614411/article/details/80897256

![箭头函数](/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/箭头函数.png)

![箭头函数1](/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/箭头函数1.png)

# 7.new Promise()

https://blog.csdn.net/qq_29483485/article/details/86605396

# 7.echarts

https://segmentfault.com/a/1190000023252526?utm_source=tag-newest

# 8.vue2.0和vue3.0

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/vue2和vue3区别.png" alt="vue2和vue3区别" style="zoom:25%;" />

## 8.1 从目录结构上看区别

- vue-cli2创建的项目目录文件有清晰的文件结构，文件内容可以按照项目需求自行配置

![vue2目录](/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/vue2目录.png)

- 而vue-cli3项目文件目录结构就很简单，因为在项目创建的时候，就帮我们自动配置了80%左右的基本配置，其余的配置需要我们自行创建 `vue.config.js` 文件进行配置。

![vue3目录](/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/vue3目录.png)

### 8.1.2 vue3目录解析

![vue3目录作用](/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/vue3目录作用.png)



| 目录/文件     | 说明                                                         |
| ------------- | :----------------------------------------------------------- |
| build         | 项目构建(webpack)相关代码，打包的路径和输出路径等            |
| config        | 配置目录，包括端口号等。我们初学可以使用默认的。存的是键值对 |
| node_modules  | npm 加载的项目依赖模块                                       |
| src           | 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件。index.css: 样式文件。 |
| static        | 静态资源目录，如图片、字体等。                               |
| public        | 公共资源目录。                                               |
| test          | 初始测试目录，可删除                                         |
| .xxxx文件     | 这些是一些配置文件，包括语法配置，git配置等。                |
| index.html    | 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。       |
| package.json  | 项目配置文件。描述这个NPM包的所有相关信息，包括作者、简介、包依赖、构建等信息，区分不同环境；还有脚本命令映射； |
| README.md     | 项目的说明文档，markdown 格式                                |
| dist          | 使用 **npm run build** 命令打包后会生成该目录。              |
| vue.config.js | vue3自动配置了80%左右的基本配置，其余的配置需要我们自行创建 `vue.config.js` 文件进行配置 |

## 8.2 node_modules

node_modules是安装node后用来存放用包管理工具下载安装的包的文件夹，和python的site-packages一样。

### 8.2.1 npm包全局安装和局部安装

https://www.cnblogs.com/huancheng/p/10959509.html

#### 8.2.1.1 初始化

```shell
node init
```

生成`package.json`文件

#### 8.2.1.2 全局安装

##### 命令

```shell
npm install xxx -g
```

##### 安装位置

全局安装是将npm包安装在你的node安装目录下的node_modules文件夹中。在windows和mac中，全局安装的默认路径是不同的。在mac中默认是安装到`/usr/locla/lib`中。在windows默认安装目录是`C:\Program Files\nodejs`，当然你也可以通过一下命令来查看全局安装路径。

```shell
// 查看全局安装路径
npm root -g

// 查看npm的基础设置
npm config ls

// 查看安装目录路径
npm config get prefix
```

npm包在全局安装之后，这个包的命令就会被注册到全局，你就可以直接在命令行中执行这个命令了。其实当你全局安装一个npm包之后，这个包被存放在`/usr/locla/lib/node_modules`或者`C:\Program Files\nodejs\node_modules`目录下。而在这个包的`package.json`文件中，在`bin`属性下配置的执行命令，会放在`/usr/locla/bin`或者`C:\Program Files\nodejs`文件中。当你在命令行执行这个命令，系统就会执行`/usr/locla/bin`目录下对应的文件。

#### 8.2.1.3 本地安装

**因为我们需要的包可能有十个，他们之间相互依赖的，如果我们使用全局包，那么每次包的升级、更新等就会影响你的多个项目，那么依赖关系就会被破坏，所以使用本地安装有利于不同项目之间的独立性。**

在特定项目中执行`npm install xxx`，那么这个包会被安装在这个项目的`node_moduels`目录下。

```shell
npm install xxx --save #生产环境
npm install xxx --save-dev #开发环境
```

##### 生产环境和开发环境安装的区别

会在`package.json`的dependencies、devDependencies位置显示版本，

```json
{
  "name": "vue-admin-template",
  "version": "4.4.0",
  "description": "A vue admin template with Element UI & axios & iconfont & permission control & lint",
  "author": "felixsfan <felixsfan@tencent.com>",
  "scripts": {
    "dev": "vue-cli-service serve",
    "build:prod": "vue-cli-service build",
    "build:stage": "vue-cli-service build --mode staging",
    "preview": "node build/index.js --preview",
    "svgo": "svgo -f src/icons/svg --config=src/icons/svgo.yml",
    "lint": "eslint --ext .js,.vue src",
    "test:unit": "jest --clearCache && vue-cli-service test:unit",
    "test:ci": "npm run lint && npm run test:unit"
  },
  "dependencies": {
    "axios": "0.18.1",
    "codemirror": "^5.65.2",
    "core-js": "3.6.5",
    "echarts": "^4.9.0",
    "element-ui": "2.13.2",
    "js-cookie": "2.2.0",
    "normalize.css": "7.0.0",
    "nprogress": "0.2.0",
    "path-to-regexp": "2.4.0",
    "vue": "2.6.10",
    "vue-router": "3.0.6",
    "vuex": "3.1.0"
  },
  "devDependencies": {
    "@vue/cli-plugin-babel": "4.4.4",
    "@vue/cli-plugin-eslint": "4.4.4",
    "@vue/cli-plugin-unit-jest": "4.4.4",
    "@vue/cli-service": "4.4.4",
    "@vue/test-utils": "1.0.0-beta.29",
    "autoprefixer": "9.5.1",
    "babel-eslint": "10.1.0",
    "babel-jest": "23.6.0",
    "babel-plugin-dynamic-import-node": "2.3.3",
    "chalk": "2.4.2",
    "connect": "3.6.6",
    "eslint": "6.7.2",
    "eslint-plugin-vue": "6.2.2",
    "html-webpack-plugin": "3.2.0",
    "less": "^4.1.2",
    "mockjs": "1.0.1-beta3",
    "runjs": "4.3.2",
    "sass": "1.26.8",
    "sass-loader": "8.0.2",
    "script-ext-html-webpack-plugin": "2.1.3",
    "serve-static": "1.13.2",
    "svg-sprite-loader": "4.1.3",
    "svgo": "1.2.2",
    "vue-template-compiler": "2.6.10"
  },
  "browserslist": [
    "> 1%",
    "last 2 versions"
  ],
  "engines": {
    "node": ">=8.9",
    "npm": ">= 3.0.0"
  },
  "license": "MIT"
}

```

## 8.3 vue生产环境、开发环境

- `npm run dev`开发环境下默认选中.env.development 
- `npm run build` 命令运行时 系统则会使用 .env.production 

原理是通过node.js的npm和package.json的scripts把`npm run dev`、`npm run build` 命令映射到webpack的命令。webpack命令本来就是来打包构建项目到dist,需要手动部署启动。但是为了开发方便,webpack提供了本地开发时服务webpack-dev-server，可以本地启动项目。因此`webpack`命令构建打包项目使用product环境，webpack-dev-server本地启动项目使用dev环境。vue脚手架可能命令不一样，但是底层还是webpack的这两个命令。

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/npm_run_build.png" alt="npm_run_build" style="zoom:33%;" />

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/npm_run_dev.png" alt="npm_run_build" style="zoom:33%;" />

### 8.3.1 vue里package.json中的dependencies和devDependencies

<img src="/Users/fanqingwei/Desktop/学习/vue-admin学习总结/images/vue_package_json.png" alt="vue_package_json" style="zoom: 50%;" />

**dependencies：**

应用能够正常运行所依赖的包。这种 dependencies 是最常见的，用户在使用 npm install 安装你的包时会自动安装这些依赖。

**devDependencies：**

开发应用时所依赖的工具包。通常是一些开发、测试、打包工具，例如 webpack、ESLint、Mocha。应用正常运行并不依赖于这些包，用户在使用 npm install 安装你的包时也不会安装这些依赖。

**peerDependencies：**

应用运行依赖的宿主包。最典型的就是插件，例如各种 jQuery 插件，这些插件本身不包含 jQeury，需要外部提供。用户使用 npm 1 或 2 时会自动安装这种依赖，npm 3 不会自动安装，会提示用户安装。

**bundledDependencies：**

发布包时需要打包的依赖，似乎很少见。

**optionalDependencies：**

可选的依赖包。此种依赖不是程序运行所必须的，但是安装后可能会有新功能，例如一个图片解码库，安装了 optionalDependencies 后会支持更多的格式。

我们在使用npm install 安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，比如：

```shell
npm i 【包名】 --save-dev

npm i 【包名】 --save
```

在 package.json 文件里面提现出来的区别就是：

```shell
使用 npm i 【包名】 --save-dev 安装的包，会被写入到 devDependencies 对象里面去；

而使用 npm i 【包名】 --save 安装的包，则被写入到 dependencies 对象里面去。
```

那么 package.json 文件里面的 devDependencies  和 dependencies 对象有什么区别呢？

devDependencies  里面的插件(比如各种loader，babel全家桶及各种webpack的插件等)只用于开发环境，不用于生产环境，因此不需要打包；而 dependencies  是需要发布到生产环境的，是要打包的。

## 8.4 vue-cli开发环境和生产环境原理

https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-serve

# 9.npm,node,webpack, package.json的联系

https://www.jianshu.com/p/3d9e88a5b5d9

`package.json` 文件是node.js项目安装的包的清单。  `npm` 和 `yarn` 存储所有已安装软件包的名称和版本的地方。

# 10. node.js

## 10.1 Node.js 开发环境与生产环境

可以为生产环境和开发环境使用不同的配置。
 Node.js 假定其始终运行在开发环境中。 可以通过设置 NODE_ENV=production 环境变量来向 Node.js 发出正在生产环境中运行的信号。

通常通过在 shell 中执行以下命令来完成：

```bash
export NODE_ENV=production
```

但最好将其放在的 shell 配置文件中（例如，使用 Bash shell 的 .bash_profile），否则当系统重启时，该设置不会被保留。

也可以通过将环境变量放在应用程序的初始化命令之前来应用它：

```shell
NODE_ENV=production 
node app.js
```

此环境变量是一个约定，在外部库中也广泛使用。

设置环境为 production 通常可以确保：

- logging is kept to a minimum, essential level
- more caching levels take place to optimize performance
  For example Pug, the templating library used by Express, compiles in debug mode if NODE_ENV is not set to production. Express views are compiled in every request in development mode, while in production they are cached. There are many more examples.

You can use conditional statements to execute code in different environments:

```shell
if (process.env.NODE_ENV === "development") {
  //...
}
if (process.env.NODE_ENV === "production") {
  //...
}
if(['production', 'staging'].indexOf(process.env.NODE_ENV) >= 0) {
  //...
})
```

For example, in an Express app, you can use this to set different error handlers per environment:

```shell
if (process.env.NODE_ENV === "development") {
  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }))
})

if (process.env.NODE_ENV === "production") {
  app.use(express.errorHandler())
})
```

## 10.2 官网挺简单的

http://nodejs.cn/learn/how-to-use-or-execute-a-package-installed-using-npm
